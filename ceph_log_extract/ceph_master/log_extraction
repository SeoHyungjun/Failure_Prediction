./tools/rbd_mirror/ImageSync.cc:340:  ldout(cct, 20) << ": sync_point=" << *sync_point << dendl;
./tools/rbd_mirror/ImageSync.cc:355:  ldout(cct, 20) << ": r=" << r << dendl;
./mgr/MgrClient.cc:52:  ldout(cct, 10) << dendl;
./mgr/MgrClient.cc:66:    ldout(cct, 10) << "closing mgr session" << dendl;
./mgr/MgrClient.cc:103:    ldout(cct, 30) << "Not handling " << *m << dendl; 
./mgr/MgrClient.cc:113:    ldout(cct, 4) << "Terminating session with "
./mgr/MgrClient.cc:125:    ldout(cct, 4) << "No active mgr available yet" << dendl;
./mgr/MgrClient.cc:142:      ldout(cct, 4) << "waiting to retry connect until " << when << dendl;
./mgr/MgrClient.cc:152:  ldout(cct, 4) << "Starting new session with " << map.get_active_addr()
./mgr/MgrClient.cc:205:  ldout(cct, 20) << *m << dendl;
./mgr/MgrClient.cc:208:  ldout(cct, 4) << "Got map version " << map.epoch << dendl;
./mgr/MgrClient.cc:211:  ldout(cct, 4) << "Active mgr is now " << map.get_active_addr() << dendl;
./mgr/MgrClient.cc:226:    ldout(cct, 4) << __func__ << " con " << con << dendl;
./mgr/MgrClient.cc:276:      ldout(cct,20) << " undeclare " << path << dendl;
./mgr/MgrClient.cc:305:	ldout(cct,20) << " declare " << path << dendl;
./mgr/MgrClient.cc:329:    ldout(cct, 20) << "sending " << session->declared.size() << " counters ("
./mgr/MgrClient.cc:336:  ldout(cct, 20) << "encoded " << report->packed.length() << " bytes" << dendl;
./mgr/MgrClient.cc:375:  ldout(cct, 20) << *m << dendl;
./mgr/MgrClient.cc:383:  ldout(cct, 4) << "stats_period=" << m->stats_period << dendl;
./mgr/MgrClient.cc:386:    ldout(cct, 4) << "updated stats threshold: " << m->stats_threshold << dendl;
./mgr/MgrClient.cc:414:  ldout(cct, 20) << "cmd: " << cmd << dendl;
./mgr/MgrClient.cc:417:    ldout(cct,20) << " no MgrMap, assuming EACCES" << dendl;
./mgr/MgrClient.cc:433:    ldout(cct, 4) << "start_command: no mgr session, waiting" << dendl;
./mgr/MgrClient.cc:442:  ldout(cct, 20) << *m << dendl;
./mgr/MgrClient.cc:446:    ldout(cct, 4) << "handle_command_reply tid " << m->get_tid()
./mgr/MgrClient.cc:488:  ldout(cct,1) << service << "." << name << " metadata " << metadata << dendl;
./mgr/MgrClient.cc:507:  ldout(cct,10) << status << dendl;
./common/ceph_crypto_cms.cc:111:	ldout(cct, 0) << "ERROR: failed to set up message decoder" << dendl;
./common/ceph_crypto_cms.cc:116:	ldout(cct, 0) << "ERROR: failed to decode message" << dendl;
./common/ceph_crypto_cms.cc:122:	ldout(cct, 0) << "ERROR: failed to decode message" << dendl;
./common/ceph_crypto_cms.cc:127:	ldout(cct, 20) << "SMIME: " << dendl;
./common/ceph_crypto_cms.cc:138:	ldout(cct, 20) << "level=" << decodeOptions->headerLevel << "." << nlevels - i << dendl;
./common/ceph_crypto_cms.cc:149:		ldout(cct, 20) << "type=signedData; " << dendl;
./common/ceph_crypto_cms.cc:152:		ldout(cct, 0) << "ERROR: signedData component missing" << dendl;
./common/ceph_crypto_cms.cc:166:		    ldout(cct, 0) << "ERROR: Out of memory" << dendl;
./common/ceph_crypto_cms.cc:172:		    ldout(cct, 0) << "ERROR: problem computing message digest" << dendl;
./common/ceph_crypto_cms.cc:178:		    ldout(cct, 0) << "ERROR: problem setting message digests" << dendl;
./common/ceph_crypto_cms.cc:191:		ldout(cct, 0) << "ERROR: cert import failed" << dendl;
./common/ceph_crypto_cms.cc:198:		ldout(cct, 20) << "nsigners=" << nsigners << dendl;
./common/ceph_crypto_cms.cc:209:		    ldout(cct, 0) << "ERROR: Verify certs-only failed!" << dendl;
./common/ceph_crypto_cms.cc:217:		ldout(cct, 0) << "ERROR: no message digests" << dendl;
./common/ceph_crypto_cms.cc:235:		    ldout(cct, 20) << "\t\tsigner" << j << ".id=" << signercn << dendl;
./common/ceph_crypto_cms.cc:245:		    ldout(cct, 20) << "signer" << j << "status=" << svs << dendl;
./common/ceph_crypto_cms.cc:248:		    ldout(cct, 0) << "ERROR: signer " << j << " status = " << svs << dendl;
./common/ceph_crypto_cms.cc:258:		ldout(cct, 20) << "type=envelopedData; " << dendl;
./common/ceph_crypto_cms.cc:261:		ldout(cct, 0) << "ERROR: envelopedData component missing" << dendl;
./common/ceph_crypto_cms.cc:270:		ldout(cct, 20) << "type=encryptedData; " << dendl;
./common/ceph_crypto_cms.cc:273:		ldout(cct, 0) << "ERROR: encryptedData component missing" << dendl;
./common/ceph_crypto_cms.cc:280:		ldout(cct, 20) << "type=data; " << dendl;
./common/ceph_crypto_cms.cc:319:	ldout(cct, 0) << "ERROR: No default cert DB" << dendl;
./common/ceph_crypto_cms.cc:332:        ldout(cct, 0) << "ERROR: problem decoding" << dendl;
./common/dns_resolve.cc:167:  ldout(cct, 20) << "name=" << host << dendl;
./common/dns_resolve.cc:182:  ldout(cct, 20) << "cname host=" << host << dendl;
./common/dns_resolve.cc:232:    ldout(cct, 20) << "no address found for hostname " << hostname << dendl;
./common/dns_resolve.cc:240:    ldout(cct, 20) << "no address found for hostname " << hostname << dendl;
./common/dns_resolve.cc:309:    ldout(cct, 20) << "No hosts found for service " << query_str << dendl;
./common/dns_resolve.cc:319:    ldout(cct, 20) << "No hosts found for service " << query_str << dendl;
./common/OutputDataSocket.cc:134:  ldout(m_cct, 5) << "bind_and_listen " << sock_path << dendl;
./common/OutputDataSocket.cc:204:  ldout(m_cct, 5) << "entry start" << dendl;
./common/OutputDataSocket.cc:233:  ldout(m_cct, 5) << "entry exit" << dendl;
./common/OutputDataSocket.cc:243:  ldout(m_cct, 30) << "OutputDataSocket: calling accept" << dendl;
./common/OutputDataSocket.cc:246:  ldout(m_cct, 30) << "OutputDataSocket: finished accept" << dendl;
./common/OutputDataSocket.cc:332:  ldout(m_cct, 5) << "init " << path << dendl;
./common/OutputDataSocket.cc:371:  ldout(m_cct, 5) << "shutdown" << dendl;
./common/OutputDataSocket.cc:395:    ldout(m_cct, 20) << "dropping data output, max backlog reached" << dendl;
./common/LogClient.cc:150:  ldout(cct, 20) << __func__ << " log_to_monitors " << log_to_monitors
./common/LogClient.cc:191:  ldout(cct, 10) << __func__
./common/LogClient.cc:216:    ldout(cct,-1) << "log " << prio << " : " << s << dendl;
./common/LogClient.cc:218:    ldout(cct,0) << "log " << prio << " : " << s << dendl;
./common/LogClient.cc:238:    ldout(cct,0) << __func__ << " log to syslog"  << dendl;
./common/LogClient.cc:244:    ldout(cct,0) << __func__ << " log to graylog"  << dendl;
./common/LogClient.cc:288:  ldout(cct,10) << " log_queue is " << log_queue.size() << " last_log " << last_log << " sent " << last_log_sent
./common/LogClient.cc:303:    ldout(cct,10) << " will send " << *p << dendl;
./common/LogClient.cc:318:  ldout(cct,10) << __func__ << " log to self" << dendl;
./common/LogClient.cc:355:  ldout(cct,10) << "handle_log_ack " << *m << dendl;
./common/LogClient.cc:364:    ldout(cct,10) << " logged " << entry << dendl;
./common/admin_socket.cc:149:  ldout(m_cct, 5) << "bind_and_listen " << sock_path << dendl;
./common/admin_socket.cc:188:	ldout(m_cct, 20) << "socket " << sock_path << " is in use" << dendl;
./common/admin_socket.cc:191:	ldout(m_cct, 20) << "unlink stale file " << sock_path << dendl;
./common/admin_socket.cc:225:  ldout(m_cct, 5) << "entry start" << dendl;
./common/admin_socket.cc:254:  ldout(m_cct, 5) << "entry exit" << dendl;
./common/admin_socket.cc:285:  ldout(m_cct, 30) << "AdminSocket: calling accept" << dendl;
./common/admin_socket.cc:288:  ldout(m_cct, 30) << "AdminSocket: finished accept" << dendl;
./common/admin_socket.cc:351:    ldout(m_cct, 0) << "AdminSocket: " << errss.str() << dendl;
./common/admin_socket.cc:402:      ldout(m_cct, 0) << "AdminSocket: request '" << match << "' args '" << args
./common/admin_socket.cc:406:      ldout(m_cct, 5) << "AdminSocket: request '" << match << "' '" << args
./common/admin_socket.cc:448:    ldout(m_cct, 5) << "register_command " << command << " hook " << hook
./common/admin_socket.cc:452:    ldout(m_cct, 5) << "register_command " << command << " hook " << hook
./common/admin_socket.cc:469:    ldout(m_cct, 5) << "unregister_command " << command << dendl;
./common/admin_socket.cc:481:    ldout(m_cct, 5) << "unregister_command " << command << " ENOENT" << dendl;
./common/admin_socket.cc:567:  ldout(m_cct, 5) << "init " << path << dendl;
./common/admin_socket.cc:617:  ldout(m_cct, 5) << "shutdown" << dendl;
./common/Timer.cc:55:  ldout(cct,10) << "init" << dendl;
./common/Timer.cc:62:  ldout(cct,10) << "shutdown" << dendl;
./common/Timer.cc:79:  ldout(cct,10) << "timer_thread starting" << dendl;
./common/Timer.cc:93:      ldout(cct,10) << "timer_thread executing " << callback << dendl;
./common/Timer.cc:106:    ldout(cct,20) << "timer_thread going to sleep" << dendl;
./common/Timer.cc:111:    ldout(cct,20) << "timer_thread awake" << dendl;
./common/Timer.cc:113:  ldout(cct,10) << "timer_thread exiting" << dendl;
./common/Timer.cc:129:  ldout(cct,10) << __func__ << " " << when << " -> " << callback << dendl;
./common/Timer.cc:131:    ldout(cct,5) << __func__ << " already shutdown, event not added" << dendl;
./common/Timer.cc:157:    ldout(cct,10) << "cancel_event " << callback << " not found" << dendl;
./common/Timer.cc:161:  ldout(cct,10) << "cancel_event " << p->second->first << " -> " << callback << dendl;
./common/Timer.cc:171:  ldout(cct,10) << "cancel_all_events" << dendl;
./common/Timer.cc:176:    ldout(cct,10) << " cancelled " << p->second->first << " -> " << p->first << dendl;
./common/Timer.cc:187:  ldout(cct,10) << "dump " << caller << dendl;
./common/Timer.cc:192:    ldout(cct,10) << " " << s->first << "->" << s->second << dendl;
./common/HeartbeatMap.cc:44:  ldout(m_cct, 10) << "add_worker '" << name << "'" << dendl;
./common/HeartbeatMap.cc:60:  ldout(m_cct, 10) << "remove_worker '" << h->name << "'" << dendl;
./common/HeartbeatMap.cc:72:    ldout(m_cct, 1) << who << " '" << h->name << "'"
./common/HeartbeatMap.cc:78:    ldout(m_cct, 1) << who << " '" << h->name << "'"
./common/HeartbeatMap.cc:91:  ldout(m_cct, 20) << "reset_timeout '" << h->name << "' grace " << grace
./common/HeartbeatMap.cc:109:  ldout(m_cct, 20) << "clear_timeout '" << h->name << "'" << dendl;
./common/HeartbeatMap.cc:124:    ldout(m_cct, 0) << "is_healthy injecting failure for next " << m_cct->_conf->heartbeat_inject_failure << " seconds" << dendl;
./common/HeartbeatMap.cc:132:    ldout(m_cct, 0) << "is_healthy = false, injected failure for next "
./common/HeartbeatMap.cc:153:  ldout(m_cct, 20) << "is_healthy = " << (healthy ? "healthy" : "NOT HEALTHY")
./common/HeartbeatMap.cc:178:	ldout(m_cct, 0) << "unable to touch " << path << ": "
./common/WorkQueue.cc:87:  ldout(cct,10) << "worker start" << dendl;
./common/WorkQueue.cc:98:      ldout(cct,1) << " worker shutting down; too many threads (" << _threads.size() << " > " << _num_threads << ")" << dendl;
./common/WorkQueue.cc:115:	  ldout(cct,12) << "worker wq " << wq->name << " start processing " << item
./common/WorkQueue.cc:124:	  ldout(cct,15) << "worker wq " << wq->name << " done processing " << item
./common/WorkQueue.cc:136:    ldout(cct,20) << "worker waiting" << dendl;
./common/WorkQueue.cc:145:  ldout(cct,1) << "worker finish" << dendl;
./common/WorkQueue.cc:157:    ldout(cct, 10) << "start_threads creating and starting " << wt << dendl;
./common/WorkQueue.cc:172:    ldout(cct, 10) << "join_old_threads joining and deleting " << _old_threads.front() << dendl;
./common/WorkQueue.cc:181:  ldout(cct,10) << "start" << dendl;
./common/WorkQueue.cc:184:    ldout(cct, 10) << " registering config observer on " << _thread_num_option << dendl;
./common/WorkQueue.cc:191:  ldout(cct,15) << "started" << dendl;
./common/WorkQueue.cc:196:  ldout(cct,10) << "stop" << dendl;
./common/WorkQueue.cc:199:    ldout(cct, 10) << " unregistering config observer on " << _thread_num_option << dendl;
./common/WorkQueue.cc:220:  ldout(cct,15) << "stopped" << dendl;
./common/WorkQueue.cc:225:  ldout(cct,10) << "pause" << dendl;
./common/WorkQueue.cc:231:  ldout(cct,15) << "paused" << dendl;
./common/WorkQueue.cc:236:  ldout(cct,10) << "pause_new" << dendl;
./common/WorkQueue.cc:244:  ldout(cct,10) << "unpause" << dendl;
./common/WorkQueue.cc:254:  ldout(cct,10) << "drain" << dendl;
./common/WorkQueue.cc:271:    ldout(cct,10) << __func__ 
./common/WorkQueue.cc:296:  ldout(cct,10) << "worker start" << dendl;
./common/WorkQueue.cc:343:  ldout(cct,10) << "sharded worker finish" << dendl;
./common/WorkQueue.cc:356:    ldout(cct, 10) << "start_threads creating and starting " << wt << dendl;
./common/WorkQueue.cc:365:  ldout(cct,10) << "start" << dendl;
./common/WorkQueue.cc:370:  ldout(cct,15) << "started" << dendl;
./common/WorkQueue.cc:375:  ldout(cct,10) << "stop" << dendl;
./common/WorkQueue.cc:386:  ldout(cct,15) << "stopped" << dendl;
./common/WorkQueue.cc:391:  ldout(cct,10) << "pause" << dendl;
./common/WorkQueue.cc:400:  ldout(cct,10) << "paused" << dendl; 
./common/WorkQueue.cc:405:  ldout(cct,10) << "pause_new" << dendl;
./common/WorkQueue.cc:411:  ldout(cct,10) << "paused_new" << dendl;
./common/WorkQueue.cc:416:  ldout(cct,10) << "unpause" << dendl;
./common/WorkQueue.cc:422:  ldout(cct,10) << "unpaused" << dendl;
./common/WorkQueue.cc:427:  ldout(cct,10) << "drain" << dendl;
./common/WorkQueue.cc:439:  ldout(cct,10) << "drained" << dendl;
./common/PluginRegistry.cc:74:  ldout(cct, 1) << __func__ << " " << type << " " << name << dendl;
./common/PluginRegistry.cc:94:  ldout(cct, 1) << __func__ << " " << type << " " << name
./common/PluginRegistry.cc:130:  ldout(cct, 1) << __func__ << " " << type << " " << name
./common/PluginRegistry.cc:139:  ldout(cct, 1) << __func__ << " " << type << " " << name << dendl;
./common/PluginRegistry.cc:210:  ldout(cct, 1) << __func__ << ": " << type << " " << name
./common/Throttle.cc:99:      ldout(cct, 2) << "_wait waiting..." << dendl;
./common/Throttle.cc:105:      ldout(cct, 2) << "_wait finished waiting" << dendl;
./common/Throttle.cc:128:  ldout(cct, 10) << "wait" << dendl;
./common/Throttle.cc:138:  ldout(cct, 10) << "take " << c << dendl;
./common/Throttle.cc:158:  ldout(cct, 10) << "get " << c << " (" << count.load() << " -> " << (count.load() + c) << ")" << dendl;
./common/Throttle.cc:192:    ldout(cct, 10) << "get_or_fail " << c << " failed" << dendl;
./common/Throttle.cc:198:    ldout(cct, 10) << "get_or_fail " << c << " success (" << count.load()
./common/Throttle.cc:218:  ldout(cct, 10) << "put " << c << " (" << count.load() << " -> "
./common/MemoryModel.cc:23:    ldout(cct, 0) << "check_memory_usage unable to open " PROCPREFIX "/proc/self/status" << dendl;
./common/MemoryModel.cc:47:    ldout(cct, 0) << "check_memory_usage unable to open " PROCPREFIX "/proc/self/maps" << dendl;
./common/MemoryModel.cc:55:    //ldout(cct, 0) << "line is " << line << dendl;
./common/MemoryModel.cc:69:    //ldout(cct, 0) << std::hex << as << " to " << ae << std::dec << dendl;
./common/MemoryModel.cc:83:    //ldout(cct, 0) << "size " << size << " mode is '" << mode << "' end is '" << end << "'" << dendl;
./common/Finisher.cc:12:  ldout(cct, 10) << __func__ << dendl;
./common/Finisher.cc:18:  ldout(cct, 10) << __func__ << dendl;
./common/Finisher.cc:26:  ldout(cct, 10) << __func__ << " finish" << dendl;
./common/Finisher.cc:33:    ldout(cct, 10) << "wait_for_empty waiting" << dendl;
./common/Finisher.cc:37:  ldout(cct, 10) << "wait_for_empty empty" << dendl;
./common/Finisher.cc:45:  ldout(cct, 10) << "finisher_thread start" << dendl;
./common/Finisher.cc:59:      ldout(cct, 10) << "finisher_thread doing " << ls << dendl;
./common/Finisher.cc:70:      ldout(cct, 10) << "finisher_thread done with " << ls << dendl;
./common/Finisher.cc:80:    ldout(cct, 10) << "finisher_thread empty" << dendl;
./common/Finisher.cc:86:    ldout(cct, 10) << "finisher_thread sleeping" << dendl;
./common/Finisher.cc:93:  ldout(cct, 10) << "finisher_thread stop" << dendl;
./common/config.cc:271:    ldout(cct, 4) << __func__ << " no callback set" << dendl;
./common/config.cc:276:      ldout(cct, 4) << __func__ << " callback consumed " << i.first << dendl;
./common/config.cc:279:      ldout(cct, 4) << __func__ << " callback ignored " << i.first << dendl;
./common/config.cc:283:      ldout(cct,10) << __func__ << " " << i.first << " = " << i.second
./common/config.cc:298:      ldout(cct,20) << __func__ << " " << i.first << " = " << i.second
./common/config.cc:301:      ldout(cct,10) << __func__ << " " << i.first << " = " << i.second << dendl;
./common/config.cc:310:	ldout(cct,10) << __func__ << " " << name
./os/kstore/KStore.cc:609:  ldout(store->cct, 20) << __func__ << " oid " << oid << " key "
./os/kstore/KStore.cc:614:  ldout(store->cct, 20) << " r " << r << " v.len " << v.length() << dendl;
./os/FuseStore.cc:126:  ldout(cct, 10) << __func__ << " path " << path << " -> " << v << dendl;
./os/FuseStore.cc:236:  ldout(fs->store->cct, 10) << __func__ << " " << path << dendl;
./os/FuseStore.cc:393:  ldout(fs->store->cct, 10) << __func__ << " " << path << " offset " << offset
./os/FuseStore.cc:479:      ldout(fs->store->cct, 10) << __func__ << std::hex
./os/FuseStore.cc:561:  ldout(fs->store->cct, 10) << __func__ << " " << path << dendl;
./os/FuseStore.cc:724:  ldout(fs->store->cct, 10) << __func__ << " " << path << dendl;
./os/FuseStore.cc:788:  ldout(fs->store->cct, 10) << __func__ << " " << path << dendl;
./os/FuseStore.cc:796:  ldout(fs->store->cct, 10) << __func__ << " " << path << dendl;
./os/FuseStore.cc:868:  ldout(fs->store->cct, 10) << __func__ << " " << path << dendl;
./os/FuseStore.cc:872:    ldout(fs->store->cct, 10) << __func__ << " closing last " << o->path << dendl;
./os/FuseStore.cc:884:  ldout(fs->store->cct, 10) << __func__ << " " << path << " offset " << offset
./os/FuseStore.cc:905:  ldout(fs->store->cct, 10) << __func__ << " " << path << " offset " << offset
./os/FuseStore.cc:937:  ldout(fs->store->cct, 10) << __func__ << " " << path << dendl;
./os/FuseStore.cc:993:  ldout(fs->store->cct, 10) << __func__ << " " << path << dendl;
./os/FuseStore.cc:1067:  ldout(fs->store->cct, 10) << __func__ << " " << path << " size " << size << dendl;
./os/FuseStore.cc:1109:  ldout(fs->store->cct, 10) << __func__ << " " << path << dendl;
./os/FuseStore.cc:1121:  ldout(fs->store->cct, 10) << __func__ << " " << path << ": " 
./os/bluestore/StupidAllocator.cc:29:  ldout(cct, 30) << __func__ << " len 0x" << std::hex << orig_len
./os/bluestore/StupidAllocator.cc:37:  ldout(cct, 30) << __func__ << " 0x" << std::hex << off << "~" << len
./os/bluestore/StupidAllocator.cc:44:    ldout(cct, 30) << __func__ << " promoting 0x" << std::hex << off << "~" << len
./os/bluestore/StupidAllocator.cc:54:  ldout(cct, 10) << __func__ << " need 0x" << std::hex << need
./os/bluestore/StupidAllocator.cc:66:  ldout(cct, 10) << __func__ << " unused 0x" << std::hex << unused
./os/bluestore/StupidAllocator.cc:92:  ldout(cct, 10) << __func__ << " want_size 0x" << std::hex << want_size
./os/bluestore/StupidAllocator.cc:167:      ldout(cct, 10) << __func__ << " shortening allocation of 0x" << std::hex
./os/bluestore/StupidAllocator.cc:174:  ldout(cct, 30) << __func__ << " got 0x" << std::hex << *offset << "~" << *length
./os/bluestore/StupidAllocator.cc:182:      ldout(cct, 30) << __func__ << " demoting 0x" << std::hex << off << "~" << len
./os/bluestore/StupidAllocator.cc:191:      ldout(cct, 30) << __func__ << " demoting 0x" << std::hex << off << "~" << len
./os/bluestore/StupidAllocator.cc:263:    ldout(cct, 10) << __func__ << " 0x" << std::hex << offset << "~" << length
./os/bluestore/StupidAllocator.cc:289:  ldout(cct, 30) << __func__ << " " << intervals << "/" << max_intervals 
./os/bluestore/StupidAllocator.cc:305:    ldout(cct, 0) << __func__ << " free bin " << bin << ": "
./os/bluestore/StupidAllocator.cc:310:      ldout(cct, 0) << __func__ << "  0x" << std::hex << p.get_start() << "~"
./os/bluestore/StupidAllocator.cc:319:  ldout(cct, 10) << __func__ << " 0x" << std::hex << offset << "~" << length
./os/bluestore/StupidAllocator.cc:328:  ldout(cct, 10) << __func__ << " 0x" << std::hex << offset << "~" << length
./os/bluestore/StupidAllocator.cc:336:      ldout(cct, 20) << __func__ << " bin " << i << " rm 0x" << std::hex << overlap
./os/bluestore/StupidAllocator.cc:348:              ldout(cct, 30) << __func__ << " demoting1 0x" << std::hex << off << "~" << len
./os/bluestore/StupidAllocator.cc:369:  ldout(cct, 1) << __func__ << dendl;
./os/bluestore/BlueStore.cc:1280:  ldout(cache->cct, 20) << __func__ << dendl;
./os/bluestore/BlueStore.cc:1289:  ldout(cache->cct, 20) << __func__ << std::hex << " 0x" << offset << "~" << length
./os/bluestore/BlueStore.cc:1444:      ldout(cache->cct, 20) << __func__ << " discard " << *b << dendl;
./os/bluestore/BlueStore.cc:1452:      ldout(cache->cct, 20) << __func__ << " added " << *b << dendl;
./os/bluestore/BlueStore.cc:1471:      ldout(cache->cct, 30) << __func__ << " cut " << *p->second << dendl;
./os/bluestore/BlueStore.cc:1489:    ldout(cache->cct, 30) << __func__ << " move " << *p->second << dendl;
./os/bluestore/BlueStore.cc:1519:    ldout(cache->cct, 30) << __func__ << " " << oid << " " << o
./os/bluestore/BlueStore.cc:1524:  ldout(cache->cct, 30) << __func__ << " " << oid << " " << o << dendl;
./os/bluestore/BlueStore.cc:1532:  ldout(cache->cct, 30) << __func__ << dendl;
./os/bluestore/BlueStore.cc:1540:      ldout(cache->cct, 30) << __func__ << " " << oid << " miss" << dendl;
./os/bluestore/BlueStore.cc:1542:      ldout(cache->cct, 30) << __func__ << " " << oid << " hit " << p->second
./os/bluestore/BlueStore.cc:1561:  ldout(cache->cct, 10) << __func__ << dendl;
./os/bluestore/BlueStore.cc:1581:  ldout(cache->cct, 30) << __func__ << " " << old_oid << " -> " << new_oid
./os/bluestore/BlueStore.cc:1590:    ldout(cache->cct, 30) << __func__ << "  removing target " << pn->second
./os/bluestore/BlueStore.cc:1612:  ldout(cache->cct, 20) << __func__ << dendl;
./os/bluestore/BlueStore.cc:1625:    ldout(cct, LogLevelV) << i.first << " : " << i.second << dendl;
./os/bluestore/BlueStore.cc:1670:    ldout(coll->store->cct, 20) << __func__ << " " << this
./os/bluestore/BlueStore.cc:1677:	ldout(coll->store->cct, 20)
./os/bluestore/BlueStore.cc:1712:    ldout(cct, LogLevelV) << i.first << " : " << *i.second << dendl;
./os/bluestore/BlueStore.cc:1762:	ldout(coll->store->cct, 20) << __func__ << " 0x" << std::hex << pos
./os/bluestore/BlueStore.cc:3075:    ldout(c->store->cct, 20) << __func__ << " cnt:" << flushing_count << dendl;
./os/bluestore/BlueStore.cc:3081:  ldout(c->store->cct, 20) << __func__ << " done" << dendl;
./os/bluestore/BlueStore.cc:3257:    ldout(store->cct, 10) << __func__ << " sbid 0x" << std::hex << sbid
./os/bluestore/BlueStore.cc:3262:    ldout(store->cct, 10) << __func__ << " sbid 0x" << std::hex << sbid
./os/bluestore/BlueStore.cc:3288:    ldout(store->cct, 10) << __func__ << " sbid 0x" << std::hex << sbid
./os/bluestore/BlueStore.cc:3295:  ldout(store->cct, 10) << __func__ << " " << *b << dendl;
./os/bluestore/BlueStore.cc:3313:  ldout(store->cct, 20) << __func__ << " now " << *b << dendl;
./os/bluestore/BlueStore.cc:3318:  ldout(store->cct, 10) << __func__ << " " << *sb << dendl;
./os/bluestore/BlueStore.cc:3326:  ldout(store->cct, 20) << __func__ << " now " << *sb << dendl;
./os/bluestore/BlueStore.cc:3352:  ldout(store->cct, 20) << __func__ << " oid " << oid << " key "
./os/bluestore/BlueStore.cc:3357:  ldout(store->cct, 20) << " r " << r << " v.len " << v.length() << dendl;
./os/bluestore/BlueStore.cc:3396:  ldout(store->cct, 10) << __func__ << " to " << dest << dendl;
./os/bluestore/BlueStore.cc:3415:      ldout(store->cct, 20) << __func__ << " moving " << o << " " << o->oid
./os/bluestore/BlueStore.cc:3438:	  ldout(store->cct, 20) << __func__ << "  already moved " << *sb
./os/bluestore/BlueStore.cc:3442:	ldout(store->cct, 20) << __func__ << "  moving " << *sb << dendl;
./os/bluestore/BlueStore.cc:3444:	  ldout(store->cct, 20) << __func__
./os/bluestore/BlueStore.cc:3453:	      ldout(store->cct, 20) << __func__ << "   moving " << *i.second
./os/bluestore/BlueStore.cc:3539:    ldout(c->store->cct,20) << __func__ << " after " << after << " key "
./os/bluestore/BlueStore.cc:3554:    ldout(c->store->cct,20) << __func__ << " to " << to << " key "
./os/bluestore/BlueStore.cc:3569:    ldout(c->store->cct,20) << __func__ << " is at "
./auth/AuthMethodList.cc:32:    ldout(cct, 5) << "adding auth protocol: " << *iter << dendl;
./auth/RotatingKeyRing.cc:33:  ldout(cct, 10) << "dump_rotating:" << dendl;
./auth/RotatingKeyRing.cc:37:    ldout(cct, 10) << " id " << iter->first << " " << iter->second << dendl;
./auth/RotatingKeyRing.cc:52:    ldout(cct, 0) << "do not have service " << ceph_entity_type_name(service_id_)
./auth/RotatingKeyRing.cc:60:    ldout(cct, 0) << "could not find secret_id=" << secret_id << dendl;
./auth/KeyRing.cc:238:  ldout(cct, 2) << "KeyRing::load: loaded key file " << filename << dendl;
./auth/KeyRing.cc:269:    ldout(cct, 10) << " importing " << p->first << dendl;
./auth/KeyRing.cc:270:    ldout(cct, 30) << "    " << p->second << dendl;
./auth/cephx/CephxServiceHandler.cc:37:  ldout(cct, 10) << "start_session server_challenge " << hex << server_challenge << dec << dendl;
./auth/cephx/CephxServiceHandler.cc:56:      ldout(cct, 10) << "handle_request get_auth_session_key for " << entity_name << dendl;
./auth/cephx/CephxServiceHandler.cc:63:        ldout(cct, 0) << "couldn't find entity name: " << entity_name << dendl;
./auth/cephx/CephxServiceHandler.cc:78:	ldout(cct, 0) << " cephx_calc_client_server_challenge error: " << error << dendl;
./auth/cephx/CephxServiceHandler.cc:83:      ldout(cct, 20) << " checking key: req.key=" << hex << req.key
./auth/cephx/CephxServiceHandler.cc:86:        ldout(cct, 0) << " unexpected key: req.key=" << hex << req.key
./auth/cephx/CephxServiceHandler.cc:106:        ldout(cct, 10) << "decoded old_ticket with global_id=" << global_id << dendl;
./auth/cephx/CephxServiceHandler.cc:123:        ldout(cct, 0) << " could not get service secret for auth subsystem" << dendl;
./auth/cephx/CephxServiceHandler.cc:138:        ldout(cct, 0) << " could not get mon caps for " << entity_name << dendl;
./auth/cephx/CephxServiceHandler.cc:143:          ldout(cct,0) << "mon caps null for " << entity_name << dendl;
./auth/cephx/CephxServiceHandler.cc:152:      ldout(cct, 10) << "handle_request get_principal_session_key" << dendl;
./auth/cephx/CephxServiceHandler.cc:163:      ldout(cct, 10) << " ticket_req.keys = " << ticket_req.keys << dendl;
./auth/cephx/CephxServiceHandler.cc:172:	  ldout(cct, 10) << " adding key for service "
./auth/cephx/CephxServiceHandler.cc:179:	    ldout(cct, 10) << "   missing key for service "
./auth/cephx/CephxServiceHandler.cc:190:	ldout(cct, 10) << __func__ << " did not find any service keys" << dendl;
./auth/cephx/CephxServiceHandler.cc:201:      ldout(cct, 10) << "handle_request getting rotating secret for " << entity_name << dendl;
./auth/cephx/CephxServiceHandler.cc:211:    ldout(cct, 10) << "handle_request unknown op " << cephx_header.request_type << dendl;
./auth/cephx/CephxAuthorizeHandler.cc:16:    ldout(cct, 1) << "verify authorizer, authorizer_data.length()=0" << dendl;
./auth/cephx/CephxSessionHandler.cc:60:  ldout(cct, 10) << __func__ << " seq " << m->get_seq()
./auth/cephx/CephxSessionHandler.cc:84:  ldout(cct, 20) << "Putting signature in client message(seq # " << m->get_seq()
./auth/cephx/CephxSessionHandler.cc:108:      ldout(cct, 0) << "SIGN: MSG " << m->get_seq() << " Sender did not set CEPH_MSG_FOOTER_SIGNED." << dendl;
./auth/cephx/CephxSessionHandler.cc:110:    ldout(cct, 0) << "SIGN: MSG " << m->get_seq() << " Message signature does not match contents." << dendl;
./auth/cephx/CephxSessionHandler.cc:111:    ldout(cct, 0) << "SIGN: MSG " << m->get_seq() << "Signature on message:" << dendl;
./auth/cephx/CephxSessionHandler.cc:112:    ldout(cct, 0) << "SIGN: MSG " << m->get_seq() << "    sig: " << m->get_footer().sig << dendl;
./auth/cephx/CephxSessionHandler.cc:113:    ldout(cct, 0) << "SIGN: MSG " << m->get_seq() << "Locally calculated signature:" << dendl;
./auth/cephx/CephxSessionHandler.cc:114:    ldout(cct, 0) << "SIGN: MSG " << m->get_seq() << "    sig_check:" << sig << dendl;
./auth/cephx/CephxSessionHandler.cc:122:    ldout(cct, 0) << "Signature failed." << dendl;
./auth/cephx/CephxClientHandler.cc:33:  ldout(cct, 10) << "build_request" << dendl;
./auth/cephx/CephxClientHandler.cc:46:      ldout(cct, 20) << "no secret found for entity: " << cct->_conf->name << dendl;
./auth/cephx/CephxClientHandler.cc:52:      ldout(cct, 20) << "secret for entity " << cct->_conf->name << " is invalid" << dendl;
./auth/cephx/CephxClientHandler.cc:62:      ldout(cct, 20) << "cephx_calc_client_server_challenge error: " << error << dendl;
./auth/cephx/CephxClientHandler.cc:69:      ldout(cct, 20) << "old ticket len=" << req.old_ticket.blob.length() << dendl;
./auth/cephx/CephxClientHandler.cc:74:    ldout(cct, 10) << "get auth session key: client_challenge "
./auth/cephx/CephxClientHandler.cc:81:    ldout(cct, 10) << "get service keys: want=" << want << " need=" << need << " have=" << have << dendl;
./auth/cephx/CephxClientHandler.cc:112:  ldout(cct, 10) << "handle_response ret = " << ret << dendl;
./auth/cephx/CephxClientHandler.cc:122:    ldout(cct, 10) << " got initial server challenge "
./auth/cephx/CephxClientHandler.cc:136:      ldout(cct, 10) << " get_auth_session_key" << dendl;
./auth/cephx/CephxClientHandler.cc:140:	ldout(cct, 0) << "key not found for " << cct->_conf->name << dendl;
./auth/cephx/CephxClientHandler.cc:145:	ldout(cct, 0) << "could not verify service_ticket reply" << dendl;
./auth/cephx/CephxClientHandler.cc:148:      ldout(cct, 10) << " want=" << want << " need=" << need << " have=" << have << dendl;
./auth/cephx/CephxClientHandler.cc:160:      ldout(cct, 10) << " get_principal_session_key session_key " << ticket_handler.session_key << dendl;
./auth/cephx/CephxClientHandler.cc:163:        ldout(cct, 0) << "could not verify service_ticket reply" << dendl;
./auth/cephx/CephxClientHandler.cc:175:      ldout(cct, 10) << " get_rotating_key" << dendl;
./auth/cephx/CephxClientHandler.cc:181:          ldout(cct, 0) << "key not found for " << cct->_conf->name << dendl;
./auth/cephx/CephxClientHandler.cc:186:	  ldout(cct, 0) << "could not set rotating key: decode_decrypt failed. error:"
./auth/cephx/CephxClientHandler.cc:197:   ldout(cct, 0) << " unknown request_type " << header.request_type << dendl;
./auth/cephx/CephxClientHandler.cc:208:  ldout(cct, 10) << "build_authorizer for service " << ceph_entity_type_name(service_id) << dendl;
./auth/cephx/CephxClientHandler.cc:215:  ldout(cct, 10) << "build_rotating_request" << dendl;
./auth/cephx/CephxClientHandler.cc:225:  ldout(cct, 10) << "validate_tickets: want=" << want << " need=" << need
./auth/cephx/CephxClientHandler.cc:228:  ldout(cct, 10) << "want=" << want << " need=" << need << " have=" << have
./auth/cephx/CephxClientHandler.cc:245:  ldout(cct, 20) << "need_tickets: want=" << want
./auth/cephx/CephxKeyServer.cc:30:    ldout(cct, 10) << "get_service_secret service " << ceph_entity_type_name(service_id) << " not found " << dendl;
./auth/cephx/CephxKeyServer.cc:47:  ldout(cct, 30) << "get_service_secret service " << ceph_entity_type_name(service_id)
./auth/cephx/CephxKeyServer.cc:77:    ldout(cct, 10) << "get_service_secret service " << ceph_entity_type_name(service_id)
./auth/cephx/CephxKeyServer.cc:79:    ldout(cct, 30) << " I have:" << dendl;
./auth/cephx/CephxKeyServer.cc:84:      ldout(cct, 30) << " id " << iter->first << " " << iter->second << dendl;
./auth/cephx/CephxKeyServer.cc:115:  ldout(cct, 10) << "get_caps: name=" << name.to_str() << dendl;
./auth/cephx/CephxKeyServer.cc:118:    ldout(cct, 10) << "get_secret: num of caps=" << iter->second.caps.size() << dendl;
./auth/cephx/CephxKeyServer.cc:152:  ldout(cct, 10) << "_check_rotating_secrets" << dendl;
./auth/cephx/CephxKeyServer.cc:162:    ldout(cct, 10) << __func__ << " added " << added << dendl;
./auth/cephx/CephxKeyServer.cc:174:  ldout(cct, 30) << "_dump_rotating_secrets" << dendl;
./auth/cephx/CephxKeyServer.cc:182:      ldout(cct, 30) << "service " << ceph_entity_type_name(iter->first)
./auth/cephx/CephxKeyServer.cc:207:    ldout(cct, 10) << "_rotate_secret adding " << ceph_entity_type_name(service_id) << dendl;
./auth/cephx/CephxKeyServer.cc:208:    ldout(cct, 30) << "_rotate_secret adding " << ceph_entity_type_name(service_id)
./auth/cephx/CephxProtocol.cc:58:  ldout(cct, 10) << "build_service_ticket service " << ceph_entity_type_name(info.service_id)
./auth/cephx/CephxProtocol.cc:68:    ldout(cct, -1) << "cephx_build_service_ticket_blob failed with error "
./auth/cephx/CephxProtocol.cc:95:  ldout(cct, 10) << "build_service_ticket_reply encoding " << num
./auth/cephx/CephxProtocol.cc:112:      ldout(cct, -1) << "error encoding encrypted: " << error << dendl;
./auth/cephx/CephxProtocol.cc:123:    ldout(cct, 30) << "service_ticket_blob is ";
./auth/cephx/CephxProtocol.cc:130:	ldout(cct, -1) << "error encoding encrypted ticket: " << error << dendl;
./auth/cephx/CephxProtocol.cc:153:    ldout(cct, 0) << "verify_service_ticket_reply: failed decode_decrypt, error is: " << error << dendl;
./auth/cephx/CephxProtocol.cc:162:    ldout(cct, 10) << " got encrypted ticket" << dendl;
./auth/cephx/CephxProtocol.cc:165:      ldout(cct, 10) << "verify_service_ticket_reply: decode_decrypt failed "
./auth/cephx/CephxProtocol.cc:174:  ldout(cct, 10) << " ticket.secret_id=" <<  ticket.secret_id << dendl;
./auth/cephx/CephxProtocol.cc:176:  ldout(cct, 10) << "verify_service_ticket_reply service " << ceph_entity_type_name(service_id)
./auth/cephx/CephxProtocol.cc:186:    ldout(cct, 10) << "ticket expires=" << expires << " renew_after=" << renew_after << dendl;
./auth/cephx/CephxProtocol.cc:233:    ldout(cct, 10) << "set_have_need_key no handler for service "
./auth/cephx/CephxProtocol.cc:238:  //ldout(cct, 10) << "set_have_need_key service " << ceph_entity_type_name(service_id)
./auth/cephx/CephxProtocol.cc:271:  ldout(cct, 10) << "verify_service_ticket_reply got " << num << " keys" << dendl;
./auth/cephx/CephxProtocol.cc:276:    ldout(cct, 10) << "got key for service_id " << ceph_entity_type_name(type) << dendl;
./auth/cephx/CephxProtocol.cc:313:    ldout(cct, 0) << "failed to encrypt authorizer: " << error << dendl;
./auth/cephx/CephxProtocol.cc:329:    ldout(cct, 0) << "no TicketHandler for service "
./auth/cephx/CephxProtocol.cc:347:  ldout(cct, 10) << "validate_tickets want " << mask << " have " << have
./auth/cephx/CephxProtocol.cc:363:      ldout(cct, 0) << "ceph_decode_ticket could not get general service secret for service_id="
./auth/cephx/CephxProtocol.cc:369:      ldout(cct, 0) << "ceph_decode_ticket could not get service secret for service_id=" 
./auth/cephx/CephxProtocol.cc:378:    ldout(cct, 0) << "ceph_decode_ticket could not decrypt ticket info. error:" 
./auth/cephx/CephxProtocol.cc:412:  ldout(cct, 10) << "verify_authorizer decrypted service "
./auth/cephx/CephxProtocol.cc:420:      ldout(cct, 0) << "verify_authorizer could not get general service secret for service "
./auth/cephx/CephxProtocol.cc:426:      ldout(cct, 0) << "verify_authorizer could not get service secret for service "
./auth/cephx/CephxProtocol.cc:439:    ldout(cct, 0) << "verify_authorizer could not decrypt ticket info: error: "
./auth/cephx/CephxProtocol.cc:445:    ldout(cct, 0) << "verify_authorizer global_id mismatch: declared id=" << global_id
./auth/cephx/CephxProtocol.cc:450:  ldout(cct, 10) << "verify_authorizer global_id=" << global_id << dendl;
./auth/cephx/CephxProtocol.cc:455:    ldout(cct, 0) << "verify_authorizercould not decrypt authorize request with error: "
./auth/cephx/CephxProtocol.cc:468:    ldout(cct, 10) << "verify_authorizer: encode_encrypt error: " << error << dendl;
./auth/cephx/CephxProtocol.cc:472:  ldout(cct, 10) << "verify_authorizer ok nonce " << hex << auth_msg.nonce << dec
./auth/cephx/CephxProtocol.cc:483:      ldout(cct, 0) << "verify_reply couldn't decrypt with error: " << error << dendl;
./auth/cephx/CephxProtocol.cc:489:    ldout(cct, 0) << "verify_authorizer_reply bad nonce got " << reply.nonce_plus_one << " expected " << expect
./auth/none/AuthNoneAuthorizeHandler.cc:33:    ldout(cct, 0) << "AuthNoneAuthorizeHandle::verify_authorizer() failed to decode" << dendl;
./auth/AuthSessionHandler.cc:29:  ldout(cct,10) << "In get_auth_session_handler for protocol " << protocol << dendl;
./mon/PGMap.cc:3276:      ldout(cct, 10) << __func__ << " pool " << p.first << " gone, removing pgs"
./mon/PGMap.cc:3304:      ldout(cct,10) << __func__ << " pool " << poolid << " pg_num " << pg_num
./mon/PGMap.cc:3309:	  ldout(cct,20) << __func__ << " adding " << pgid << dendl;
./mon/MonCap.cc:388:    ldout(cct, 20) << "is_capable service=" << service << " command=" << command
./mon/MonCap.cc:398:      ldout(cct, 20) << " allow so far " << allow << ", doing grant " << *p << dendl;
./mon/MonCap.cc:402:	ldout(cct, 20) << " allow all" << dendl;
./mon/MonCap.cc:413:	ldout(cct, 20) << " match" << dendl;
./mon/MonClient.cc:75:  ldout(cct, 10) << __func__ << dendl;
./mon/MonClient.cc:81:  ldout(cct, 10) << __func__ << dendl;
./mon/MonClient.cc:91:  ldout(cct, 10) << __func__ << " done" << dendl;
./mon/MonClient.cc:97:  ldout(cct, 10) << __func__ << dendl;
./mon/MonClient.cc:134:      ldout(cct,10) << __func__ << " pre-mimic monitor, no config to fetch"
./mon/MonClient.cc:142:	ldout(cct,20) << __func__ << " waiting for config" << dendl;
./mon/MonClient.cc:146:	ldout(cct,10) << __func__ << " success" << dendl;
./mon/MonClient.cc:206:  ldout(cct, 10) << __func__ << dendl;
./mon/MonClient.cc:216:    ldout(cct, 10) << __func__ << " specified mon id is empty!" << dendl;
./mon/MonClient.cc:219:    ldout(cct, 10) << __func__ << " no such monitor 'mon." << new_mon_id << "'"
./mon/MonClient.cc:231:  ldout(cct, 10) << __func__ << " ping mon." << new_mon_id
./mon/MonClient.cc:238:    ldout(cct,10) << __func__ << " got ping reply" << dendl;
./mon/MonClient.cc:278:      ldout(cct, 10) << "discarding stray monitor message " << *m << dendl;
./mon/MonClient.cc:284:    ldout(cct, 10) << "discarding stray monitor message " << *m << dendl;
./mon/MonClient.cc:348:  ldout(cct, 10) << __func__ << " " << *m << dendl;
./mon/MonClient.cc:355:  ldout(cct, 10) << " got monmap " << monmap.epoch
./mon/MonClient.cc:358:  ldout(cct, 10) << "dump:\n";
./mon/MonClient.cc:365:    ldout(cct, 10) << "mon." << cur_mon << " went away" << dendl;
./mon/MonClient.cc:376:  ldout(cct,10) << __func__ << " " << *m << dendl;
./mon/MonClient.cc:387:  ldout(cct, 10) << __func__ << dendl;
./mon/MonClient.cc:406:  ldout(cct, 10) << "auth_supported " << auth_supported->get_supported_set() << " method " << method << dendl;
./mon/MonClient.cc:442:  ldout(cct, 10) << __func__ << dendl;
./mon/MonClient.cc:446:    ldout(cct, 20) << __func__ << " canceling and discarding version request "
./mon/MonClient.cc:456:    ldout(cct, 20) << __func__ << " discarding pending message " << *waiting_for_session.front() << dendl;
./mon/MonClient.cc:483:    ldout(cct, 5) << "already authenticated" << dendl;
./mon/MonClient.cc:494:    ldout(cct, 10) << "authenticate will time out at " << until << dendl;
./mon/MonClient.cc:500:	ldout(cct, 0) << "authenticate timed out after " << timeout << dendl;
./mon/MonClient.cc:509:    ldout(cct, 5) << __func__ << " success, global_id "
./mon/MonClient.cc:612:    ldout(cct, 10) << "_send_mon_message to mon."
./mon/MonClient.cc:624:  ldout(cct, 10) << __func__ << " rank " << rank << dendl;
./mon/MonClient.cc:670:  ldout(cct, 10) << "picked mon." << monmap.get_name(rank)
./mon/MonClient.cc:712:      ldout(cct, 10) << __func__ << " hunted mon " << con->get_peer_addr() << dendl;
./mon/MonClient.cc:714:      ldout(cct, 10) << __func__ << " stray mon " << con->get_peer_addr() << dendl;
./mon/MonClient.cc:719:      ldout(cct, 10) << __func__ << " current mon " << con->get_peer_addr() << dendl;
./mon/MonClient.cc:723:      ldout(cct, 10) << "ms_handle_reset stray mon " << con->get_peer_addr() << dendl;
./mon/MonClient.cc:761:    ldout(cct, 1) << "found mon."
./mon/MonClient.cc:765:    ldout(cct, 1) << "no mon sessions established" << dendl;
./mon/MonClient.cc:774:  ldout(cct, 10) << __func__ << dendl;
./mon/MonClient.cc:783:    ldout(cct, 1) << "continuing hunt" << dendl;
./mon/MonClient.cc:790:      ldout(cct, 10) << "renew subs? (now: " << now
./mon/MonClient.cc:805:	ldout(cct, 1) << "no keepalive since " << lk << " (" << interval
./mon/MonClient.cc:823:  ldout(cct, 20) << __func__ << " reopen_interval_multipler now "
./mon/MonClient.cc:845:    ldout(cct, 10) << __func__ << " - empty" << dendl;
./mon/MonClient.cc:849:  ldout(cct, 10) << __func__ << dendl;
./mon/MonClient.cc:874:    ldout(cct, 10) << __func__ << " sent " << sub_renew_sent << " renew after " << sub_renew_after << dendl;
./mon/MonClient.cc:877:    ldout(cct, 10) << __func__ << " sent " << sub_renew_sent << ", ignoring" << dendl;
./mon/MonClient.cc:888:      ldout(cct, 10) << __func__ << " getting new tickets!" << dendl;
./mon/MonClient.cc:906:    ldout(cct, 20) << "_check_auth_rotating not needed by " << entity_name << dendl;
./mon/MonClient.cc:911:    ldout(cct, 10) << "_check_auth_rotating waiting for auth session" << dendl;
./mon/MonClient.cc:921:    ldout(cct, 10) << "_check_auth_rotating have uptodate secrets (they expire after " << cutoff << ")" << dendl;
./mon/MonClient.cc:926:  ldout(cct, 10) << "_check_auth_rotating renewing rotating keys (they expired before " << cutoff << ")" << dendl;
./mon/MonClient.cc:935:    ldout(cct, 10) << __func__ << " called too often (last: "
./mon/MonClient.cc:969:      ldout(cct, 0) << __func__ << " timed out after " << timeout << dendl;
./mon/MonClient.cc:972:    ldout(cct, 10) << __func__ << " waiting (until " << until << ")" << dendl;
./mon/MonClient.cc:976:  ldout(cct, 10) << __func__ << " done" << dendl;
./mon/MonClient.cc:991:    ldout(cct, 10) << __func__ << " " << r->tid << " " << r->cmd
./mon/MonClient.cc:996:      ldout(cct, 10) << " target " << r->target_rank << " >= max mon " << monmap.size() << dendl;
./mon/MonClient.cc:1006:    ldout(cct, 10) << __func__ << " " << r->tid << " " << r->cmd
./mon/MonClient.cc:1011:      ldout(cct, 10) << " target " << r->target_name << " not present in monmap" << dendl;
./mon/MonClient.cc:1019:  ldout(cct, 10) << __func__ << " " << r->tid << " " << r->cmd << dendl;
./mon/MonClient.cc:1045:    ldout(cct, 10) << __func__ << " has tid 0, assuming it is " << r->tid << dendl;
./mon/MonClient.cc:1049:      ldout(cct, 10) << __func__ << " " << ack->get_tid() << " not found" << dendl;
./mon/MonClient.cc:1056:  ldout(cct, 10) << __func__ << " " << r->tid << " " << r->cmd << dendl;
./mon/MonClient.cc:1069:    ldout(cct, 10) << __func__ << " tid " << tid << " dne" << dendl;
./mon/MonClient.cc:1073:  ldout(cct, 10) << __func__ << " tid " << tid << dendl;
./mon/MonClient.cc:1082:  ldout(cct, 10) << __func__ << " " << r->tid << " = " << ret << " " << rs << dendl;
./mon/MonClient.cc:1164:  ldout(cct, 10) << "get_version " << map << " req " << req << dendl;
./mon/MonClient.cc:1178:    ldout(cct, 0) << __func__ << " version request with handle " << m->handle
./mon/MonClient.cc:1182:    ldout(cct, 10) << __func__ << " finishing " << req << " version " << m->version << dendl;
./mon/MonClient.cc:1199:    ldout(cct, 0) << __func__ << " for " << ceph_entity_type_name(service_id)
./mon/MonClient.cc:1281:    ldout(cct, 10) << "no handler for protocol " << m->protocol << dendl;
./mon/MonClient.cc:1283:      ldout(cct, 10) << "none of our auth protocols are supported by the server"
./mon/MonClient.cc:1295:    ldout(cct, 1) << __func__
./mon/MonClient.cc:1310:    ldout(cct, 1) << "peer sent an invalid global_id" << dendl;
./mon/MonClient.cc:1317:    ldout(cct, 10) << "my global_id is " << m->global_id << dendl;
./test/librados_test_stub/TestWatchNotify.cc:56:  ldout(cct, 20) << "enter" << dendl;
./test/librados_test_stub/TestWatchNotify.cc:149:  ldout(cct, 20) << "notify_id=" << notify_id << ", handle=" << handle
./test/librados_test_stub/TestWatchNotify.cc:185:  ldout(cct, 20) << "oid=" << o << ", gid=" << gid << ": handle=" << *handle
./test/librados_test_stub/TestWatchNotify.cc:196:  ldout(cct, 20) << "handle=" << handle << dendl;
./test/librados_test_stub/TestWatchNotify.cc:264:    ldout(cct, 1) << "oid=" << oid << ": not found" << dendl;
./test/librados_test_stub/TestWatchNotify.cc:270:  ldout(cct, 20) << "oid=" << oid << ": notify_id=" << notify_id << dendl;
./test/librados_test_stub/TestWatchNotify.cc:320:    ldout(cct, 1) << "oid=" << oid << ": not found" << dendl;
./test/librados_test_stub/TestWatchNotify.cc:326:    ldout(cct, 1) << "oid=" << oid << ", notify_id=" << notify_id
./test/librados_test_stub/TestWatchNotify.cc:331:  ldout(cct, 20) << "oid=" << oid << ", notify_id=" << notify_id
./test/librados_test_stub/TestWatchNotify.cc:347:  ldout(cct, 20) << "oid=" << oid << ", notify_id=" << notify_id << dendl;
./test/librados_test_stub/TestWatchNotify.cc:355:    ldout(cct, 1) << "oid=" << oid << ", notify_id=" << notify_id
./test/librados_test_stub/TestWatchNotify.cc:362:    ldout(cct, 10) << "oid=" << oid << ", notify_id=" << notify_id
./test/librados_test_stub/TestWatchNotify.cc:367:  ldout(cct, 20) << "oid=" << oid << ", notify_id=" << notify_id
./test/osdc/FakeWriteback.cc:40:      ldout(m_cct, 20) << "finished read " << m_off << "~" << r << dendl;
./test/librgw_file.cc:157:    ldout(g_ceph_context, 0) << __func__ << " readdir on bucket " << get<0>(fid)
./test/librgw_file_gp.cc:208:    ldout(g_ceph_context, 0) << __func__ << " readdir on bucket "
./msg/async/net_handler.cc:110:      ldout(cct, 0) << "couldn't set TCP_NODELAY: " << cpp_strerror(r) << dendl;
./msg/async/net_handler.cc:117:      ldout(cct, 0) << "couldn't set SO_RCVBUF to " << size << ": " << cpp_strerror(r) << dendl;
./msg/async/net_handler.cc:127:    ldout(cct,0) << "couldn't set SO_NOSIGPIPE: " << cpp_strerror(r) << dendl;
./msg/async/net_handler.cc:156:    ldout(cct,0) << "couldn't set TOS to " << iptos
./msg/async/net_handler.cc:167:    ldout(cct, 0) << __func__ << " couldn't set SO_PRIORITY to " << prio
./msg/async/net_handler.cc:199:        ldout(cct, 2) << __func__ << " client bind error " << ", " << cpp_strerror(ret) << dendl;
./msg/async/net_handler.cc:212:    ldout(cct, 10) << __func__ << " connect: " << cpp_strerror(ret) << dendl;
./msg/async/net_handler.cc:227:    ldout(cct, 10) << __func__ << " reconnect: " << strerror(r) << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:44:  ldout(cct, 20) << __func__ << " destruct." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:108:  ldout(cct, 20) << __func__ << " Choosing gid_index " << (int)qpa.ah_attr.grh.sgid_index << ", sl " << (int)qpa.ah_attr.sl << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:123:  ldout(cct, 20) << __func__ << " transition to RTR state successfully." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:158:  ldout(cct, 20) << __func__ << " transition to RTS state successfully." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:159:  ldout(cct, 20) << __func__ << " QueuePair: " << qp << " with qp:" << qp->get_qp() << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:163:    ldout(cct, 20) << __func__ << " handle fake send, wake it up. QP: " << my_msg.qpn << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:172:  ldout(cct, 20) << __func__ << " nonblock:" << opts.nonblock << ", nodelay:"
./msg/async/rdma/RDMAConnectedSocketImpl.cc:189:  ldout(cct, 20) << __func__ << " tcp_fd: " << tcp_fd << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:201:  ldout(cct, 20) << __func__ << " QP: " << my_msg.qpn << " tcp_fd: " << tcp_fd << " notify_fd: " << notify_fd << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:206:      ldout(cct, 1) << __func__ << " recv handshake msg failed." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:213:    ldout(cct, 1) << __func__ << " warnning: logic failed: read len: " << r << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:220:    ldout(cct, 20) << __func__ << " peer msg :  < " << peer_msg.qpn << ", " << peer_msg.psn
./msg/async/rdma/RDMAConnectedSocketImpl.cc:229:      ldout(cct, 1) << __func__ << " send client ack failed." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:236:        ldout(cct, 10) << __func__ << " server is already active." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:243:        ldout(cct, 1) << __func__ << " server ack failed." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:250:      ldout(cct, 10) << __func__ << " handshake of rdma is done. server connected: " << connected << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:262:  ldout(cct, 20) << __func__ << " notify_fd : " << i << " in " << my_msg.qpn << " r = " << r << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:265:    ldout(cct, 1) << __func__ << " when ib not active. len: " << len << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:270:    ldout(cct, 1) << __func__ << " when ib not connected. len: " << len <<dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:293:  ldout(cct, 20) << __func__ << " poll queue got " << cqe.size() << " responses. QP: " << my_msg.qpn << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:298:    ldout(cct, 25) << __func__ << " chunk length: " << response->byte_len << " bytes." << chunk << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:305:        ldout(cct, 20) << __func__ << " got remote close msg..." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:311:        ldout(cct, 25) << __func__ << " buffers add a chunk: " << response->byte_len << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:315:        ldout(cct, 25) << __func__ << " buffers add a chunk: " << chunk->get_offset() << ":" << chunk->get_bound() << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:325:    ldout(cct, 20) << __func__ << " we do not need last handshake, QP: " << my_msg.qpn << " peer QP: " << peer_msg.qpn << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:347:    ldout(cct, 25) << __func__ << " this iter read: " << tmp << " bytes." << " offset: " << (*c)->get_offset() << " ,bound: " << (*c)->get_bound()  << ". Chunk:" << *c  << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:350:      ldout(cct, 25) << __func__ << " one chunk over." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:360:  ldout(cct, 25) << __func__ << " got " << read  << " bytes, buffers size: " << buffers.size() << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:390:  ldout(cct, 20) << __func__ << " pool completion queue got " << cqe.size() << " responses."<< dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:425:      ldout(cct, 20) << __func__ << " fake send to upper, QP: " << my_msg.qpn << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:429:  ldout(cct, 20) << __func__ << " QP: " << my_msg.qpn << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:442:  ldout(cct, 20) << __func__ << " we need " << bytes << " bytes. iov size: "
./msg/async/rdma/RDMAConnectedSocketImpl.cc:454:      ldout(cct, 1) << __func__ << " no enough buffers in worker " << worker << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:520:  ldout(cct, 20) << __func__ << " left bytes: " << pending_bl.length() << " in buffers "
./msg/async/rdma/RDMAConnectedSocketImpl.cc:527:  ldout(cct, 20) << __func__ << " finished sending " << bytes << " bytes." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:533:  ldout(cct, 20) << __func__ << " QP: " << my_msg.qpn << " " << tx_buffers[0] << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:549:    ldout(cct, 25) << __func__ << " sending buffer: " << *current_buffer << " length: " << isge[current_sge].length  << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:559:      ldout(cct, 20) << __func__ << " send_inline." << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:574:    ldout(cct, 1) << __func__ << " failed to send data"
./msg/async/rdma/RDMAConnectedSocketImpl.cc:582:  ldout(cct, 20) << __func__ << " qp state is " << Infiniband::qp_state_string(qp->get_state()) << dendl;
./msg/async/rdma/RDMAConnectedSocketImpl.cc:595:    ldout(cct, 1) << __func__ << " failed to send message="
./msg/async/rdma/RDMAConnectedSocketImpl.cc:642:  ldout(cct, 1) << __func__ << " tcp fd " << tcp_fd << dendl;
./msg/async/rdma/Infiniband.cc:40:  ldout(cct,1) << __func__ << " using experimental verbs for gid" << dendl;
./msg/async/rdma/Infiniband.cc:50:  ldout(cct, 1) << __func__ << " looking for local GID " << (cct->_conf->ms_async_rdma_local_gid)
./msg/async/rdma/Infiniband.cc:65:    ldout(cct, 1) << __func__ << " malformed or no GID supplied, using GID index 0" << dendl;
./msg/async/rdma/Infiniband.cc:86:      ldout(cct, 1) << __func__ << " found at index " << gid_idx << dendl;
./msg/async/rdma/Infiniband.cc:137:      ldout(cct, 1) << __func__ << " found active port " << i+1 << dendl;
./msg/async/rdma/Infiniband.cc:140:      ldout(cct, 10) << __func__ << " port " << i+1 << " is not what we want. state: " << port->get_port_attr()->state << ")"<< dendl;
./msg/async/rdma/Infiniband.cc:181:  ldout(cct, 20) << __func__ << " started." << dendl;
./msg/async/rdma/Infiniband.cc:204:  ldout(cct, 20) << __func__ << " successfully create queue pair: "
./msg/async/rdma/Infiniband.cc:239:  ldout(cct, 20) << __func__ << " successfully change queue pair to INIT:"
./msg/async/rdma/Infiniband.cc:368:  ldout(cct, 20) << __func__ << " started." << dendl;
./msg/async/rdma/Infiniband.cc:404:    ldout(cct, 20) << __func__ << " ack aq events." << dendl;
./msg/async/rdma/Infiniband.cc:440:  ldout(cct, 20) << __func__ << " successfully create cq=" << cq << dendl;
./msg/async/rdma/Infiniband.cc:446:  ldout(cct, 20) << __func__ << " started." << dendl;
./msg/async/rdma/Infiniband.cc:846:   ldout(cct, 20) << __func__ << " ms_async_rdma_enable_hugepage value is: " << cct->_conf->ms_async_rdma_enable_hugepage <<  dendl;
./msg/async/rdma/Infiniband.cc:849:     ldout(cct, 0) << __func__ << " RDMAV_HUGEPAGES_SAFE is set as: " << getenv("RDMAV_HUGEPAGES_SAFE") <<  dendl;
./msg/async/rdma/Infiniband.cc:873:  ldout(cct, 20) << __func__ << " constructing Infiniband..." << dendl;
./msg/async/rdma/Infiniband.cc:896:    ldout(cct, 1) << __func__ << " receive queue length is " << rx_queue_len << " receive buffers" << dendl;
./msg/async/rdma/Infiniband.cc:898:    ldout(cct, 0) << __func__ << " requested receive queue length " <<
./msg/async/rdma/Infiniband.cc:915:    ldout(cct, 1) << __func__ << " assigning: " << tx_queue_len << " send buffers"  << dendl;
./msg/async/rdma/Infiniband.cc:917:    ldout(cct, 0) << __func__ << " using the max allowed send buffers: " << tx_queue_len << dendl;
./msg/async/rdma/Infiniband.cc:920:  ldout(cct, 1) << __func__ << " device allow " << device->device_attr->max_cqe
./msg/async/rdma/Infiniband.cc:1059:      ldout(cct, 0) << __func__ << " injecting socket failure" << dendl;
./msg/async/rdma/Infiniband.cc:1068:    ldout(cct, 10) << __func__ << " got disconnect message " << dendl;
./msg/async/rdma/Infiniband.cc:1070:    ldout(cct, 1) << __func__ << " got bad length (" << r << ") " << dendl;
./msg/async/rdma/Infiniband.cc:1075:    ldout(cct, 5) << __func__ << " recevd: " << im.lid << ", " << im.qpn << ", " << im.psn << ", " << im.peer_qpn << ", " << gid  << dendl;
./msg/async/rdma/Infiniband.cc:1090:  ldout(cct, 10) << __func__ << " sending: " << im.lid << ", " << im.qpn << ", " << im.psn
./msg/async/rdma/Infiniband.cc:1096:      ldout(cct, 0) << __func__ << " injecting socket failure" << dendl;
./msg/async/rdma/Infiniband.cc:1139:    ldout(cct, 20) << __func__ << " destroy qp=" << qp << dendl;
./msg/async/rdma/RDMAServerSocketImpl.cc:54:    ldout(cct, 10) << __func__ << " unable to bind to " << sa.get_sockaddr()
./msg/async/rdma/RDMAServerSocketImpl.cc:66:  ldout(cct, 20) << __func__ << " bind to " << sa.get_sockaddr() << " on port " << sa.get_port()  << dendl;
./msg/async/rdma/RDMAServerSocketImpl.cc:77:  ldout(cct, 15) << __func__ << dendl;
./msg/async/rdma/RDMAServerSocketImpl.cc:109:  ldout(cct, 20) << __func__ << " accepted a new QP, tcp_fd: " << sd << dendl;
./msg/async/rdma/RDMAStack.cc:34:  ldout(cct, 20) << __func__ << " destructing rdma dispatcher" << dendl;
./msg/async/rdma/RDMAStack.cc:124:  ldout(cct, 30) << __func__ << dendl;
./msg/async/rdma/RDMAStack.cc:139:      ldout(cct, 10) << __func__ << " event associated qp=" << async_event.element.qp
./msg/async/rdma/RDMAStack.cc:144:        ldout(cct, 1) << __func__ << " missing qp_num=" << qpn << " discard event" << dendl;
./msg/async/rdma/RDMAStack.cc:146:        ldout(cct, 1) << __func__ << " it's not forwardly stopped by us, reenable=" << conn << dendl;
./msg/async/rdma/RDMAStack.cc:151:      ldout(cct, 1) << __func__ << " ibv_get_async_event: dev=" << get_stack()->get_infiniband().get_device()->ctxt
./msg/async/rdma/RDMAStack.cc:166:    ldout(cct, 20) << __func__ << " post_backlog is " << post_backlog << dendl;
./msg/async/rdma/RDMAStack.cc:178:  ldout(cct, 20) << __func__ << " going to poll tx cq: " << tx_cq << " rx cq: " << rx_cq << dendl;
./msg/async/rdma/RDMAStack.cc:187:      ldout(cct, 20) << __func__ << " tx completion queue got " << tx_ret
./msg/async/rdma/RDMAStack.cc:194:      ldout(cct, 20) << __func__ << " rx completion queue got " << rx_ret
./msg/async/rdma/RDMAStack.cc:206:        ldout(cct, 25) << __func__ << " got chunk=" << chunk << " bytes:" << response->byte_len << " opcode:" << response->opcode << dendl;
./msg/async/rdma/RDMAStack.cc:213:            ldout(cct, 1) << __func__ << " csi with qpn " << response->qp_num << " may be dead. chunk " << chunk << " will be back ? " << r << dendl;
./msg/async/rdma/RDMAStack.cc:223:          ldout(cct, 1) << __func__ << " work request returned error for buffer(" << chunk
./msg/async/rdma/RDMAStack.cc:252:            ldout(cct, 20) << __func__ << " bypass qp=" << i << " tx_wr=" << i->get_tx_wr() << dendl;
./msg/async/rdma/RDMAStack.cc:255:            ldout(cct, 10) << __func__ << " finally delete qp=" << i << dendl;
./msg/async/rdma/RDMAStack.cc:296:          ldout(cct, 20) << __func__ << " got tx cq event." << dendl;
./msg/async/rdma/RDMAStack.cc:298:          ldout(cct, 20) << __func__ << " got rx cq event." << dendl;
./msg/async/rdma/RDMAStack.cc:384:    ldout(cct, 25) << __func__ << " QP: " << response->qp_num
./msg/async/rdma/RDMAStack.cc:395:        ldout(cct, 1) << __func__ << " connection between server and client not working. Disconnect this now" << dendl;
./msg/async/rdma/RDMAStack.cc:398:        ldout(cct, 1) << __func__ << " Work Request Flushed Error: this connection's qp="
./msg/async/rdma/RDMAStack.cc:403:        ldout(cct, 1) << __func__ << " send work request returned error for buffer("
./msg/async/rdma/RDMAStack.cc:412:        ldout(cct, 25) << __func__ << " qp state is : " << conn->get_qp_state() << dendl;//wangzhi
./msg/async/rdma/RDMAStack.cc:415:        ldout(cct, 1) << __func__ << " missing qp_num=" << response->qp_num << " discard event" << dendl;
./msg/async/rdma/RDMAStack.cc:424:      ldout(cct, 1) << __func__ << " sending of the disconnect msg completed" << dendl;
./msg/async/rdma/RDMAStack.cc:426:      ldout(cct, 1) << __func__ << " not tx buffer, chunk " << chunk << dendl;
./msg/async/rdma/RDMAStack.cc:450:  ldout(cct, 30) << __func__ << " release " << chunks.size()
./msg/async/rdma/RDMAStack.cc:516:    ldout(cct, 1) << __func__ << " try connecting failed." << dendl;
./msg/async/rdma/RDMAStack.cc:531:  ldout(cct, 30) << __func__ << " need " << bytes << " bytes, reserve " << got << " registered  bytes, inflight " << dispatcher->inflight << dendl;
./msg/async/rdma/RDMAStack.cc:550:  ldout(cct, 20) << __func__ << " pending conns " << pending_sent_conns.size() << dendl;
./msg/async/rdma/RDMAStack.cc:555:    ldout(cct, 20) << __func__ << " sent pending bl socket=" << o << " r=" << r << dendl;
./msg/async/rdma/RDMAStack.cc:573:  ldout(cct, 20) << __func__ << " constructing RDMAStack..." << dendl;
./msg/async/rdma/RDMAStack.cc:580:  ldout(cct, 20) << " creating RDMAStack:" << this << " with dispatcher:" << &dispatcher << dendl;
./msg/async/EventSelect.cc:29:  ldout(cct, 0) << "Select isn't suitable for production env, just avoid "
./msg/async/EventSelect.cc:39:  ldout(cct, 10) << __func__ << " add event to fd=" << fd << " mask=" << add_mask
./msg/async/EventSelect.cc:55:  ldout(cct, 10) << __func__ << " del event fd=" << fd << " cur mask=" << cur_mask
./msg/async/AsyncMessenger.cc:68:  ldout(msgr->cct, 10) << __func__ << dendl;
./msg/async/AsyncMessenger.cc:133:      ldout(msgr->cct, 10) << __func__ << " bound on random port " << listen_addr << dendl;
./msg/async/AsyncMessenger.cc:145:  ldout(msgr->cct, 10) << __func__ << " bound to " << listen_addr << dendl;
./msg/async/AsyncMessenger.cc:152:  ldout(msgr->cct, 1) << __func__ << dendl;
./msg/async/AsyncMessenger.cc:163:  ldout(msgr->cct, 10) << __func__ << " listen_fd=" << listen_socket.fd() << dendl;
./msg/async/AsyncMessenger.cc:178:      ldout(msgr->cct, 10) << __func__ << " accepted incoming on sd " << cli_socket.fd() << dendl;
./msg/async/AsyncMessenger.cc:192:        ldout(msgr->cct, 0) << __func__ << " it was closed because of rst arrived sd = " << listen_socket.fd()
./msg/async/AsyncMessenger.cc:206:  ldout(msgr->cct,10) << __func__ << dendl;
./msg/async/AsyncMessenger.cc:293:  ldout(cct,10) << __func__ << " " << get_myaddr() << dendl;
./msg/async/AsyncMessenger.cc:312:  ldout(cct,10) << __func__ << " " << get_myaddr() << dendl;
./msg/async/AsyncMessenger.cc:335:    ldout(cct,10) << __func__ << " already started" << dendl;
./msg/async/AsyncMessenger.cc:340:  ldout(cct,10) << __func__ << " bind " << bind_addr << dendl;
./msg/async/AsyncMessenger.cc:343:    ldout(cct, 10) << __func__ << " Network Stack is not ready for bind yet - postponed" << dendl;
./msg/async/AsyncMessenger.cc:379:  ldout(cct,1) << __func__ << " rebind avoid " << avoid_ports << dendl;
./msg/async/AsyncMessenger.cc:388:  ldout(cct, 10) << __func__ << " new nonce " << nonce
./msg/async/AsyncMessenger.cc:396:  ldout(cct, 10) << __func__ << " will try " << bind_addr
./msg/async/AsyncMessenger.cc:424:    ldout(cct, 10) << __func__ << " already started" << dendl;
./msg/async/AsyncMessenger.cc:427:  ldout(cct, 10) << __func__ << " " << bind_addr << dendl;
./msg/async/AsyncMessenger.cc:449:  ldout(cct,1) << __func__ << " bind my_inst.addr is " << get_myaddr() << dendl;
./msg/async/AsyncMessenger.cc:456:  ldout(cct,1) << __func__ << " start" << dendl;
./msg/async/AsyncMessenger.cc:488:    ldout(cct, 10) << __func__ << ": waiting for dispatch queue" << dendl;
./msg/async/AsyncMessenger.cc:491:    ldout(cct, 10) << __func__ << ": dispatch queue is stopped" << dendl;
./msg/async/AsyncMessenger.cc:498:  ldout(cct, 10) << __func__ << ": done." << dendl;
./msg/async/AsyncMessenger.cc:499:  ldout(cct, 1) << __func__ << " complete." << dendl;
./msg/async/AsyncMessenger.cc:517:  ldout(cct, 10) << __func__ << " " << addr
./msg/async/AsyncMessenger.cc:541:    ldout(cct, 10) << __func__ << " " << dest << " existing " << conn << dendl;
./msg/async/AsyncMessenger.cc:544:    ldout(cct, 10) << __func__ << " " << dest << " new " << conn << dendl;
./msg/async/AsyncMessenger.cc:565:  ldout(cct, 1) << __func__ << "--> " << dest.name << " "
./msg/async/AsyncMessenger.cc:570:    ldout(cct,0) << __func__ <<  " message " << *m
./msg/async/AsyncMessenger.cc:586:    ldout(cct, 0) << __func__ << " submit_message " << *m << "\n";
./msg/async/AsyncMessenger.cc:612:    ldout(cct, 20) << __func__ << " " << *m << " remote, " << dest_addr
./msg/async/AsyncMessenger.cc:617:    ldout(cct,20) << __func__ << " " << *m << " remote, " << dest_addr << ", new connection." << dendl;
./msg/async/AsyncMessenger.cc:649:  ldout(cct,1) << __func__ << " " << dendl;
./msg/async/AsyncMessenger.cc:654:    ldout(cct, 5) << __func__ << " accepting_conn " << p.get() << dendl;
./msg/async/AsyncMessenger.cc:662:    ldout(cct, 5) << __func__ << " mark down " << it->first << " " << p << dendl;
./msg/async/AsyncMessenger.cc:673:      ldout(cct, 5) << __func__ << " delete " << p << dendl;
./msg/async/AsyncMessenger.cc:685:    ldout(cct, 1) << __func__ << " " << addr << " -- " << p << dendl;
./msg/async/AsyncMessenger.cc:688:    ldout(cct, 1) << __func__ << " " << addr << " -- connection dne" << dendl;
./msg/async/AsyncMessenger.cc:729:    ldout(cct, 1) << __func__ << " learned my addr " << my_inst.addr << dendl;
./msg/async/AsyncMessenger.cc:737:  ldout(cct, 1) << __func__ << " start" << dendl;
./msg/async/AsyncMessenger.cc:746:    ldout(cct, 5) << __func__ << " delete " << p << dendl;
./msg/async/EventEpoll.cc:48:  ldout(cct, 20) << __func__ << " add event fd=" << fd << " cur_mask=" << cur_mask
./msg/async/EventEpoll.cc:75:  ldout(cct, 20) << __func__ << " del event fd=" << fd << " cur_mask=" << cur_mask
./msg/async/PosixStack.cc:242:    ldout(cct, 10) << __func__ << " unable to bind to " << sa.get_sockaddr()
./msg/async/Event.cc:51:          ldout(cct, 1) << __func__ << " read notify pipe failed: " << cpp_strerror(errno) << dendl;
./msg/async/Event.cc:190:  ldout(cct, 2) << __func__ << " idx=" << idx << " owner=" << owner << dendl;
./msg/async/Event.cc:213:    ldout(cct, 20) << __func__ << " event count exceed " << nevent << ", expand to " << new_size << dendl;
./msg/async/Event.cc:224:  ldout(cct, 20) << __func__ << " create event started fd=" << fd << " mask=" << mask
./msg/async/Event.cc:247:  ldout(cct, 20) << __func__ << " create event end fd=" << fd << " mask=" << mask
./msg/async/Event.cc:256:    ldout(cct, 1) << __func__ << " delete event fd=" << fd << " is equal or greater than nevent=" << nevent
./msg/async/Event.cc:261:  ldout(cct, 30) << __func__ << " delete event started fd=" << fd << " mask=" << mask
./msg/async/Event.cc:280:  ldout(cct, 30) << __func__ << " delete event end fd=" << fd << " mask=" << mask
./msg/async/Event.cc:289:  ldout(cct, 30) << __func__ << " id=" << id << " trigger after " << microseconds << "us"<< dendl;
./msg/async/Event.cc:304:  ldout(cct, 30) << __func__ << " id=" << id << dendl;
./msg/async/Event.cc:310:    ldout(cct, 10) << __func__ << " id=" << id << " not found" << dendl;
./msg/async/Event.cc:324:  ldout(cct, 20) << __func__ << dendl;
./msg/async/Event.cc:330:      ldout(cct, 1) << __func__ << " write notify pipe failed: " << cpp_strerror(errno) << dendl;
./msg/async/Event.cc:340:  ldout(cct, 30) << __func__ << " cur time is " << now << dendl;
./msg/async/Event.cc:350:      ldout(cct, 30) << __func__ << " process time event: id=" << id << dendl;
./msg/async/Event.cc:381:      ldout(cct, 30) << __func__ << " shortest is " << shortest << " it->first is " << it->first << dendl;
./msg/async/Event.cc:396:  ldout(cct, 30) << __func__ << " wait second " << tv.tv_sec << " usec " << tv.tv_usec << dendl;
./msg/async/Event.cc:422:    ldout(cct, 30) << __func__ << " event_wq process is " << fired_events[j].fd << " mask is " << fired_events[j].mask << dendl;
./msg/async/Event.cc:437:      ldout(cct, 30) << __func__ << " do " << e << dendl;
./msg/async/Event.cc:463:  ldout(cct, 30) << __func__ << " " << e << " pending " << num << dendl;
./msg/async/Stack.cc:46:      ldout(cct, 10) << __func__ << " starting" << dendl;
./msg/async/Stack.cc:50:        ldout(cct, 30) << __func__ << " calling event process" << dendl;
./msg/async/Stack.cc:55:          ldout(cct, 20) << __func__ << " process events failed: "
./msg/async/Stack.cc:111:    ldout(cct, 0) << __func__ << " max thread limit is "
./msg/async/Stack.cc:148:  ldout(cct, 30) << __func__ << dendl;
./msg/async/Stack.cc:206:  ldout(cct, 30) << __func__ << " started." << dendl;
./msg/async/Stack.cc:216:  ldout(cct, 30) << __func__ << " end." << dendl;
./msg/async/EventKqueue.cc:30:    ldout(cct,0) << __func__ << " invalid kqfd = " << kqfd 
./msg/async/EventKqueue.cc:41:  ldout(cct,30) << __func__ << " on kqfd = " << kqfd << dendl;
./msg/async/EventKqueue.cc:46:    ldout(cct,30) << __func__ << " restore kqfd = " << kqfd 
./msg/async/EventKqueue.cc:54:        ldout(cct,0) << __func__ << " unable to add event: "
./msg/async/EventKqueue.cc:69:    ldout(cct,20) << funcname << " We changed thread from " << mythread
./msg/async/EventKqueue.cc:77:    ldout(cct,0) << funcname << " Warning: Recreating old kqfd. "
./msg/async/EventKqueue.cc:83:    ldout(cct,30) << funcname << " kqueue: new kqfd = " << kqfd
./msg/async/EventKqueue.cc:138:  ldout(cct,30) << __func__ << " add event kqfd = " << kqfd << " fd = " << fd 
./msg/async/EventKqueue.cc:171:  ldout(cct,30) << __func__ << " delete event kqfd = " << kqfd 
./msg/async/EventKqueue.cc:199:  ldout(cct,30) << __func__ << " kqfd = " << kqfd << "newsize = " << newsize 
./msg/async/EventKqueue.cc:220:  ldout(cct,10) << __func__ << " kqfd = " << kqfd << dendl;
./msg/async/EventKqueue.cc:229:      ldout(cct,20) << __func__ << " "
./msg/async/EventKqueue.cc:235:      ldout(cct,30) << __func__ << " event_wait: " << " NULL" << dendl;
./msg/async/EventKqueue.cc:239:  ldout(cct,25) << __func__ << " kevent retval: " << retval << dendl;
./msg/async/EventKqueue.cc:245:    ldout(cct,5) << __func__ << " Hit timeout("
./msg/async/AsyncConnection.cc:164:	  ldout(msgr->cct, 1) << __func__ << " setting up a delay queue"
./msg/async/AsyncConnection.cc:186:      ldout(async_msgr->cct, 1) << __func__ << " reading from fd=" << cs.fd()
./msg/async/AsyncConnection.cc:191:    ldout(async_msgr->cct, 1) << __func__ << " peer close file descriptor "
./msg/async/AsyncConnection.cc:204:      ldout(async_msgr->cct, 0) << __func__ << " injecting socket failure" << dendl;
./msg/async/AsyncConnection.cc:212:    ldout(async_msgr->cct, 1) << __func__ << " send error: " << cpp_strerror(r) << dendl;
./msg/async/AsyncConnection.cc:216:  ldout(async_msgr->cct, 10) << __func__ << " sent bytes " << r
./msg/async/AsyncConnection.cc:245:  ldout(async_msgr->cct, 25) << __func__ << " len is " << len << " state_offset is "
./msg/async/AsyncConnection.cc:250:      ldout(async_msgr->cct, 0) << __func__ << " injecting socket failure" << dendl;
./msg/async/AsyncConnection.cc:262:    ldout(async_msgr->cct, 25) << __func__ << " got " << to_read << " in buffer "
./msg/async/AsyncConnection.cc:277:      ldout(async_msgr->cct, 25) << __func__ << " read_bulk left is " << left << " got " << r << dendl;
./msg/async/AsyncConnection.cc:279:        ldout(async_msgr->cct, 1) << __func__ << " read failed" << dendl;
./msg/async/AsyncConnection.cc:291:      ldout(async_msgr->cct, 25) << __func__ << " read_bulk recv_end is " << recv_end
./msg/async/AsyncConnection.cc:294:        ldout(async_msgr->cct, 1) << __func__ << " read failed" << dendl;
./msg/async/AsyncConnection.cc:310:  ldout(async_msgr->cct, 25) << __func__ << " need len " << len << " remaining "
./msg/async/AsyncConnection.cc:317:    ldout(async_msgr->cct, 10) << __func__ << " sleep for " << 
./msg/async/AsyncConnection.cc:337:    ldout(async_msgr->cct, 20) << __func__ << " prev state is " << get_state_name(prev_state) << dendl;
./msg/async/AsyncConnection.cc:345:            ldout(async_msgr->cct, 1) << __func__ << " read tag failed" << dendl;
./msg/async/AsyncConnection.cc:352:            ldout(async_msgr->cct, 20) << __func__ << " got KEEPALIVE" << dendl;
./msg/async/AsyncConnection.cc:365:            ldout(async_msgr->cct, 0) << __func__ << " bad tag " << (int)tag << dendl;
./msg/async/AsyncConnection.cc:377:            ldout(async_msgr->cct, 1) << __func__ << " read keeplive timespec failed" << dendl;
./msg/async/AsyncConnection.cc:383:          ldout(async_msgr->cct, 30) << __func__ << " got KEEPALIVE2 tag ..." << dendl;
./msg/async/AsyncConnection.cc:389:          ldout(async_msgr->cct, 20) << __func__ << " got KEEPALIVE2 " << kp_t << dendl;
./msg/async/AsyncConnection.cc:401:            ldout(async_msgr->cct, 1) << __func__ << " read keeplive timespec failed" << dendl;
./msg/async/AsyncConnection.cc:409:          ldout(async_msgr->cct, 20) << __func__ << " got KEEPALIVE_ACK" << dendl;
./msg/async/AsyncConnection.cc:419:            ldout(async_msgr->cct, 1) << __func__ << " read ack seq failed" << dendl;
./msg/async/AsyncConnection.cc:426:          ldout(async_msgr->cct, 20) << __func__ << " got ACK" << dendl;
./msg/async/AsyncConnection.cc:438:          ldout(async_msgr->cct, 20) << __func__ << " begin MSG" << dendl;
./msg/async/AsyncConnection.cc:444:            ldout(async_msgr->cct, 1) << __func__ << " read message header failed" << dendl;
./msg/async/AsyncConnection.cc:450:          ldout(async_msgr->cct, 20) << __func__ << " got MSG header" << dendl;
./msg/async/AsyncConnection.cc:454:	  ldout(async_msgr->cct, 20) << __func__ << " got envelope type=" << header.type
./msg/async/AsyncConnection.cc:465:	      ldout(async_msgr->cct,0) << __func__ << " got bad header crc "
./msg/async/AsyncConnection.cc:484:            ldout(async_msgr->cct, 10) << __func__ << " wants " << 1 << " message from policy throttler "
./msg/async/AsyncConnection.cc:488:              ldout(async_msgr->cct, 10) << __func__ << " wants 1 message from policy throttle "
./msg/async/AsyncConnection.cc:508:              ldout(async_msgr->cct, 10) << __func__ << " wants " << cur_msg_size << " bytes from policy throttler "
./msg/async/AsyncConnection.cc:512:                ldout(async_msgr->cct, 10) << __func__ << " wants " << cur_msg_size << " bytes from policy throttler "
./msg/async/AsyncConnection.cc:532:              ldout(async_msgr->cct, 10) << __func__ << " wants " << cur_msg_size << " bytes from dispatch throttle "
./msg/async/AsyncConnection.cc:558:              ldout(async_msgr->cct, 1) << __func__ << " read message front failed" << dendl;
./msg/async/AsyncConnection.cc:564:            ldout(async_msgr->cct, 20) << __func__ << " got front " << front.length() << dendl;
./msg/async/AsyncConnection.cc:579:              ldout(async_msgr->cct, 1) << __func__ << " read message middle failed" << dendl;
./msg/async/AsyncConnection.cc:584:            ldout(async_msgr->cct, 20) << __func__ << " got middle " << middle.length() << dendl;
./msg/async/AsyncConnection.cc:599:              ldout(async_msgr->cct,10) << __func__ << " seleting rx buffer v " << p->second.second
./msg/async/AsyncConnection.cc:608:              ldout(async_msgr->cct,20) << __func__ << " allocating new rx buffer at offset " << data_off << dendl;
./msg/async/AsyncConnection.cc:625:              ldout(async_msgr->cct, 1) << __func__ << " read data error " << dendl;
./msg/async/AsyncConnection.cc:655:            ldout(async_msgr->cct, 1) << __func__ << " read footer data error " << dendl;
./msg/async/AsyncConnection.cc:672:          ldout(async_msgr->cct, 10) << __func__ << " aborted = " << aborted << dendl;
./msg/async/AsyncConnection.cc:674:            ldout(async_msgr->cct, 0) << __func__ << " got " << front.length() << " + " << middle.length() << " + " << data.length()
./msg/async/AsyncConnection.cc:679:          ldout(async_msgr->cct, 20) << __func__ << " got " << front.length() << " + " << middle.length()
./msg/async/AsyncConnection.cc:684:            ldout(async_msgr->cct, 1) << __func__ << " decode message failed " << dendl;
./msg/async/AsyncConnection.cc:693:            ldout(async_msgr->cct, 10) << __func__ << " no session security set" << dendl;
./msg/async/AsyncConnection.cc:696:              ldout(async_msgr->cct, 0) << __func__ << " Signature check failed" << dendl;
./msg/async/AsyncConnection.cc:719:            ldout(async_msgr->cct,0) << __func__ << " got old message "
./msg/async/AsyncConnection.cc:728:            ldout(async_msgr->cct, 0) << __func__ << " missed message?  skipped from seq "
./msg/async/AsyncConnection.cc:750:	  ldout(async_msgr->cct, 5) << " rx " << message->get_source() << " seq "
./msg/async/AsyncConnection.cc:770:              ldout(async_msgr->cct, 1) << "queue_received will delay after " << (ceph_clock_now() + delay_period)
./msg/async/AsyncConnection.cc:790:          ldout(async_msgr->cct, 20) << __func__ << " got CLOSE" << dendl;
./msg/async/AsyncConnection.cc:797:          ldout(async_msgr->cct, 20) << __func__ << " enter STANDY" << dendl;
./msg/async/AsyncConnection.cc:804:          ldout(async_msgr->cct, 20) << __func__ << " enter none state" << dendl;
./msg/async/AsyncConnection.cc:810:          ldout(async_msgr->cct, 20) << __func__ << " socket closed" << dendl;
./msg/async/AsyncConnection.cc:816:          ldout(async_msgr->cct, 1) << __func__ << " enter wait state, failing" << dendl;
./msg/async/AsyncConnection.cc:890:          ldout(async_msgr->cct, 1) << __func__ << " reconnect failed " << dendl;
./msg/async/AsyncConnection.cc:892:            ldout(async_msgr->cct, 2) << __func__ << " connection refused!" << dendl;
./msg/async/AsyncConnection.cc:897:          ldout(async_msgr->cct, 10) << __func__ << " nonblock connect inprogress" << dendl;
./msg/async/AsyncConnection.cc:904:        ldout(async_msgr->cct, 10) << __func__ << " connect successfully, ready to send banner" << dendl;
./msg/async/AsyncConnection.cc:911:          ldout(async_msgr->cct, 10) << __func__ << " connect write banner done: "
./msg/async/AsyncConnection.cc:916:          ldout(async_msgr->cct, 10) << __func__ << " connect wait for write banner: "
./msg/async/AsyncConnection.cc:933:          ldout(async_msgr->cct, 1) << __func__ << " read banner and identify addresses failed" << dendl;
./msg/async/AsyncConnection.cc:940:          ldout(async_msgr->cct, 0) << __func__ << " connect protocol error (bad banner) on peer "
./msg/async/AsyncConnection.cc:955:        ldout(async_msgr->cct, 20) << __func__ <<  " connect read peer addr "
./msg/async/AsyncConnection.cc:960:            ldout(async_msgr->cct, 0) << __func__ <<  " connect claims to be " << paddr
./msg/async/AsyncConnection.cc:964:            ldout(async_msgr->cct, 10) << __func__ << " connect claims to be "
./msg/async/AsyncConnection.cc:970:        ldout(async_msgr->cct, 20) << __func__ << " connect peer addr for me is " << peer_addr_for_me << dendl;
./msg/async/AsyncConnection.cc:976:            ldout(msgr->cct, 10) << __func__ << " sleep for "
./msg/async/AsyncConnection.cc:986:          ldout(async_msgr->cct, 1) << __func__ << " state changed while learned_addr, mark_down or "
./msg/async/AsyncConnection.cc:995:          ldout(async_msgr->cct, 10) << __func__ << " connect sent my addr "
./msg/async/AsyncConnection.cc:1000:          ldout(async_msgr->cct, 10) << __func__ << " connect send my addr done: "
./msg/async/AsyncConnection.cc:1003:          ldout(async_msgr->cct, 2) << __func__ << " connect couldn't write my addr, "
./msg/async/AsyncConnection.cc:1027:          ldout(async_msgr->cct, 10) << __func__ <<  " connect_msg.authorizer_len="
./msg/async/AsyncConnection.cc:1037:        ldout(async_msgr->cct, 10) << __func__ << " connect sending gseq=" << global_seq << " cseq="
./msg/async/AsyncConnection.cc:1043:          ldout(async_msgr->cct,20) << __func__ << " connect wrote (self +) cseq, waiting for reply" << dendl;
./msg/async/AsyncConnection.cc:1047:          ldout(async_msgr->cct, 10) << __func__ << " continue send reply " << dendl;
./msg/async/AsyncConnection.cc:1049:          ldout(async_msgr->cct, 2) << __func__ << " connect couldn't send reply "
./msg/async/AsyncConnection.cc:1061:          ldout(async_msgr->cct, 1) << __func__ << " read connect reply failed" << dendl;
./msg/async/AsyncConnection.cc:1069:        ldout(async_msgr->cct, 20) << __func__ << " connect got reply tag " << (int)connect_reply.tag
./msg/async/AsyncConnection.cc:1083:          ldout(async_msgr->cct, 10) << __func__ << " reply.authorizer_len=" << connect_reply.authorizer_len << dendl;
./msg/async/AsyncConnection.cc:1087:            ldout(async_msgr->cct, 1) << __func__ << " read connect reply authorizer failed" << dendl;
./msg/async/AsyncConnection.cc:1096:            ldout(async_msgr->cct, 0) << __func__ << " failed verifying authorize reply" << dendl;
./msg/async/AsyncConnection.cc:1115:          ldout(async_msgr->cct, 1) << __func__ << " read connect ack seq failed" << dendl;
./msg/async/AsyncConnection.cc:1122:        ldout(async_msgr->cct, 2) << __func__ << " got newly_acked_seq " << newly_acked_seq
./msg/async/AsyncConnection.cc:1128:        //  ldout(async_msgr->cct, 2) << __func__ << " discarding previously sent " << m->get_seq()
./msg/async/AsyncConnection.cc:1141:          ldout(async_msgr->cct, 10) << __func__ << " send in_seq done " << dendl;
./msg/async/AsyncConnection.cc:1145:          ldout(async_msgr->cct, 10) << __func__ << " continue send in_seq " << dendl;
./msg/async/AsyncConnection.cc:1163:        ldout(async_msgr->cct, 10) << __func__ << " connect success " << connect_seq
./msg/async/AsyncConnection.cc:1211:        ldout(async_msgr->cct, 1) << __func__ << " sd=" << cs.fd() << " " << socket_addr << dendl;
./msg/async/AsyncConnection.cc:1216:          ldout(async_msgr->cct, 10) << __func__ << " write banner and addr done: "
./msg/async/AsyncConnection.cc:1221:          ldout(async_msgr->cct, 10) << __func__ << " wait for write banner and addr: "
./msg/async/AsyncConnection.cc:1236:          ldout(async_msgr->cct, 1) << __func__ << " read peer banner and addr failed" << dendl;
./msg/async/AsyncConnection.cc:1243:          ldout(async_msgr->cct, 1) << __func__ << " accept peer sent bad banner '" << state_buffer
./msg/async/AsyncConnection.cc:1257:        ldout(async_msgr->cct, 10) << __func__ << " accept peer addr is " << peer_addr << dendl;
./msg/async/AsyncConnection.cc:1263:          ldout(async_msgr->cct, 0) << __func__ << " accept peer addr is really " << peer_addr
./msg/async/AsyncConnection.cc:1275:          ldout(async_msgr->cct, 1) << __func__ << " read connect msg failed" << dendl;
./msg/async/AsyncConnection.cc:1296:            ldout(async_msgr->cct, 1) << __func__ << " read connect authorizer failed" << dendl;
./msg/async/AsyncConnection.cc:1303:        ldout(async_msgr->cct, 20) << __func__ << " accept got peer connect_seq "
./msg/async/AsyncConnection.cc:1308:        ldout(async_msgr->cct, 10) << __func__ << " accept of host_type " << connect_msg.host_type
./msg/async/AsyncConnection.cc:1327:          ldout(async_msgr->cct, 1) << __func__ << " read ack seq failed" << dendl;
./msg/async/AsyncConnection.cc:1334:        ldout(async_msgr->cct, 2) << __func__ << " accept get newly_acked_seq " << newly_acked_seq << dendl;
./msg/async/AsyncConnection.cc:1342:        ldout(async_msgr->cct, 20) << __func__ << " accept done" << dendl;
./msg/async/AsyncConnection.cc:1372:  ldout(async_msgr->cct, 10) << "accept fault after register" << dendl;
./msg/async/AsyncConnection.cc:1383:    ldout(async_msgr->cct, 0) << __func__ << " connect protocol feature mismatch, my "
./msg/async/AsyncConnection.cc:1392:    ldout(async_msgr->cct, 0) << __func__ << " connect protocol version mismatch, my "
./msg/async/AsyncConnection.cc:1399:    ldout(async_msgr->cct,0) << __func__ << " connect got BADAUTHORIZER" << dendl;
./msg/async/AsyncConnection.cc:1408:    ldout(async_msgr->cct, 0) << __func__ << " connect got RESETSESSION" << dendl;
./msg/async/AsyncConnection.cc:1416:    ldout(async_msgr->cct, 5) << __func__ << " connect got RETRY_GLOBAL "
./msg/async/AsyncConnection.cc:1423:    ldout(async_msgr->cct, 5) << __func__ << " connect got RETRY_SESSION "
./msg/async/AsyncConnection.cc:1430:    ldout(async_msgr->cct, 1) << __func__ << " connect got WAIT (connection race)" << dendl;
./msg/async/AsyncConnection.cc:1436:    ldout(async_msgr->cct, 1) << __func__ << " missing required features " << std::hex
./msg/async/AsyncConnection.cc:1442:    ldout(async_msgr->cct, 10) << __func__ << " got CEPH_MSGR_TAG_SEQ, reading acked_seq and writing in_seq" << dendl;
./msg/async/AsyncConnection.cc:1446:    ldout(async_msgr->cct, 10) << __func__ << " got CEPH_MSGR_TAG_READY " << dendl;
./msg/async/AsyncConnection.cc:1467:  ldout(async_msgr->cct, 10) << __func__ << " accept my proto " << reply.protocol_version
./msg/async/AsyncConnection.cc:1478:        ldout(async_msgr->cct, 10) << __func__ << " using cephx, requiring MSG_AUTH feature bit for cluster" << dendl;
./msg/async/AsyncConnection.cc:1484:        ldout(async_msgr->cct, 10) << __func__ << " using cephx, requiring MSG_AUTH feature bit for service" << dendl;
./msg/async/AsyncConnection.cc:1491:    ldout(async_msgr->cct, 1) << __func__ << " peer missing required features "
./msg/async/AsyncConnection.cc:1502:    ldout(async_msgr->cct,0) << __func__ << ": got bad authorizer" << dendl;
./msg/async/AsyncConnection.cc:1508:  ldout(async_msgr->cct, 10) << __func__ << " accept setting up session_security." << dendl;
./msg/async/AsyncConnection.cc:1517:    ldout(async_msgr->cct, 1) << __func__ << " state changed while accept, it must be mark_down" << dendl;
./msg/async/AsyncConnection.cc:1530:      ldout(async_msgr->cct, 1) << __func__ << " existing already closed." << dendl;
./msg/async/AsyncConnection.cc:1537:      ldout(async_msgr->cct, 1) << __func__ << " existing racing replace happened while replacing."
./msg/async/AsyncConnection.cc:1548:      ldout(async_msgr->cct, 10) << __func__ << " accept existing " << existing
./msg/async/AsyncConnection.cc:1555:      ldout(async_msgr->cct, 10) << __func__ << " accept existing " << existing
./msg/async/AsyncConnection.cc:1561:      ldout(async_msgr->cct, 0) << __func__ << " accept replacing existing (lossy) channel (new one lossy="
./msg/async/AsyncConnection.cc:1567:    ldout(async_msgr->cct, 1) << __func__ << " accept connect_seq " << connect.connect_seq
./msg/async/AsyncConnection.cc:1572:      ldout(async_msgr->cct,0) << __func__ << " accept peer reset, then tried to connect to us, replacing" << dendl;
./msg/async/AsyncConnection.cc:1582:      ldout(async_msgr->cct, 10) << __func__ << " accept existing " << existing << ".cseq "
./msg/async/AsyncConnection.cc:1597:        ldout(async_msgr->cct, 10) << __func__ << " accept connection race, existing " << existing
./msg/async/AsyncConnection.cc:1613:        ldout(async_msgr->cct, 10) << __func__ << " accept connection race, existing " << existing
./msg/async/AsyncConnection.cc:1619:        ldout(async_msgr->cct,10) << __func__ << " accept connection race, existing "
./msg/async/AsyncConnection.cc:1632:      ldout(async_msgr->cct, 0) << __func__ << " accept we reset (peer sent cseq "
./msg/async/AsyncConnection.cc:1640:    ldout(async_msgr->cct, 10) << __func__ << " accept peer sent cseq " << connect.connect_seq
./msg/async/AsyncConnection.cc:1646:    ldout(async_msgr->cct, 0) << __func__ << " accept we reset (peer sent cseq "
./msg/async/AsyncConnection.cc:1651:    ldout(async_msgr->cct, 10) << __func__ << " accept new session" << dendl;
./msg/async/AsyncConnection.cc:1658:  ldout(async_msgr->cct, 10) << __func__ << " accept replacing " << existing << dendl;
./msg/async/AsyncConnection.cc:1663:    ldout(async_msgr->cct, 1) << __func__ << " replacing on lossy channel, failing existing" << dendl;
./msg/async/AsyncConnection.cc:1692:    ldout(async_msgr->cct, 1) << __func__ << " stop myself to swap existing" << dendl;
./msg/async/AsyncConnection.cc:1769:  ldout(async_msgr->cct, 10) << __func__ << " accept success, connect_seq = "
./msg/async/AsyncConnection.cc:1796:  ldout(async_msgr->cct, 10) << __func__ << " accept features " << get_features() << dendl;
./msg/async/AsyncConnection.cc:1822:    ldout(async_msgr->cct, 1) << __func__ << " existing race replacing process for addr=" << peer_addr
./msg/async/AsyncConnection.cc:1827:    ldout(async_msgr->cct, 1) << __func__ << " state changed while accept_conn, it must be mark_down" << dendl;
./msg/async/AsyncConnection.cc:1843:    ldout(async_msgr->cct, 2) << __func__ << " accept write reply msg done" << dendl;
./msg/async/AsyncConnection.cc:1852:  ldout(async_msgr->cct, 10) << __func__ << " accept fault after register" << dendl;
./msg/async/AsyncConnection.cc:1856:  ldout(async_msgr->cct, 10) << __func__ << " failed to accept." << dendl;
./msg/async/AsyncConnection.cc:1862:  ldout(async_msgr->cct, 10) << __func__ << " csq=" << connect_seq << dendl;
./msg/async/AsyncConnection.cc:1872:  ldout(async_msgr->cct, 10) << __func__ << " sd=" << socket.fd() << dendl;
./msg/async/AsyncConnection.cc:1906:    ldout(async_msgr->cct, 20) << __func__ << " " << *m << " local" << dendl;
./msg/async/AsyncConnection.cc:1911:      ldout(async_msgr->cct, 10) << __func__ << " loopback connection closed."
./msg/async/AsyncConnection.cc:1938:    ldout(async_msgr->cct, 5) << __func__ << " clear encoded buffer previous "
./msg/async/AsyncConnection.cc:1942:    ldout(async_msgr->cct, 10) << __func__ << " connection closed."
./msg/async/AsyncConnection.cc:1948:    ldout(async_msgr->cct, 15) << __func__ << " inline write is denied, reschedule m=" << m << dendl;
./msg/async/AsyncConnection.cc:1965:    ldout(async_msgr->cct, 10) << __func__ << " " << *m << " for resend "
./msg/async/AsyncConnection.cc:1973:  ldout(async_msgr->cct, 10) << __func__ << " " << seq << dendl;
./msg/async/AsyncConnection.cc:1984:    ldout(async_msgr->cct, 10) << __func__ << " " << *(p.second) << " for resend seq " << p.second->get_seq()
./msg/async/AsyncConnection.cc:2000:  ldout(async_msgr->cct, 10) << __func__ << " started" << dendl;
./msg/async/AsyncConnection.cc:2003:    ldout(async_msgr->cct, 20) << __func__ << " discard " << *p << dendl;
./msg/async/AsyncConnection.cc:2009:      ldout(async_msgr->cct, 20) << __func__ << " discard " << r->second << dendl;
./msg/async/AsyncConnection.cc:2031:    ldout(async_msgr->cct, 10) << __func__ << " connection is already closed" << dendl;
./msg/async/AsyncConnection.cc:2036:    ldout(async_msgr->cct, 1) << __func__ << " on lossy channel, failing" << dendl;
./msg/async/AsyncConnection.cc:2059:    ldout(async_msgr->cct, 10) << __func__ << " with nothing to send and in the half "
./msg/async/AsyncConnection.cc:2069:    ldout(async_msgr->cct, 10) << __func__ << " with nothing to send, going to standby" << dendl;
./msg/async/AsyncConnection.cc:2080:      ldout(async_msgr->cct, 0) << __func__ << " server, going to standby" << dendl;
./msg/async/AsyncConnection.cc:2083:      ldout(async_msgr->cct, 0) << __func__ << " initiating reconnect" << dendl;
./msg/async/AsyncConnection.cc:2101:    ldout(async_msgr->cct, 10) << __func__ << " waiting " << backoff << dendl;
./msg/async/AsyncConnection.cc:2110:  ldout(async_msgr->cct,10) << __func__ << " started" << dendl;
./msg/async/AsyncConnection.cc:2140:  ldout(async_msgr->cct, 2) << __func__ << dendl;
./msg/async/AsyncConnection.cc:2159:  ldout(async_msgr->cct, 20) << __func__ << " m" << " " << *m << dendl;
./msg/async/AsyncConnection.cc:2163:    ldout(async_msgr->cct, 20) << __func__ << " encoding features "
./msg/async/AsyncConnection.cc:2166:    ldout(async_msgr->cct, 20) << __func__ << " half-reencoding features "
./msg/async/AsyncConnection.cc:2196:    ldout(async_msgr->cct, 20) << __func__ << " no session security" << dendl;
./msg/async/AsyncConnection.cc:2199:      ldout(async_msgr->cct, 20) << __func__ << " failed to sign m="
./msg/async/AsyncConnection.cc:2202:      ldout(async_msgr->cct, 20) << __func__ << " signed m=" << m
./msg/async/AsyncConnection.cc:2210:  ldout(async_msgr->cct, 20) << __func__ << " sending message type=" << header.type
./msg/async/AsyncConnection.cc:2242:  ldout(async_msgr->cct, 20) << __func__ << " sending " << m->get_seq()
./msg/async/AsyncConnection.cc:2247:    ldout(async_msgr->cct, 1) << __func__ << " error sending " << m << ", "
./msg/async/AsyncConnection.cc:2251:    ldout(async_msgr->cct, 10) << __func__ << " sending " << m << (rc ? " continuely." :" done.") << dendl;
./msg/async/AsyncConnection.cc:2275:    ldout(async_msgr->cct, 10) << __func__ << " releasing " << 1
./msg/async/AsyncConnection.cc:2284:      ldout(async_msgr->cct, 10) << __func__ << " releasing " << cur_msg_size
./msg/async/AsyncConnection.cc:2293:    ldout(async_msgr->cct, 10) << __func__ << " releasing " << cur_msg_size
./msg/async/AsyncConnection.cc:2303:  ldout(async_msgr->cct, 15) << __func__ << " got ack seq " << seq << dendl;
./msg/async/AsyncConnection.cc:2313:    ldout(async_msgr->cct, 10) << __func__ << " got ack seq "
./msg/async/AsyncConnection.cc:2365:  ldout(async_msgr->cct, 10) << __func__ << dendl;
./msg/async/AsyncConnection.cc:2375:  ldout(async_msgr->cct, 1) << __func__ << dendl;
./msg/async/AsyncConnection.cc:2382:  ldout(async_msgr->cct, 10) << __func__ << dendl;
./msg/async/AsyncConnection.cc:2402:  ldout(async_msgr->cct, 10) << __func__ << dendl;
./msg/async/AsyncConnection.cc:2438:	ldout(async_msgr->cct, 1) << __func__ << " send msg failed" << dendl;
./msg/async/AsyncConnection.cc:2453:	ldout(async_msgr->cct, 10) << __func__ << " try send msg ack, acked " << left << " messages" << dendl;
./msg/async/AsyncConnection.cc:2464:      ldout(async_msgr->cct, 1) << __func__ << " send msg failed" << dendl;
./msg/async/AsyncConnection.cc:2472:      ldout(async_msgr->cct, 10) << __func__ << " policy.server is false" << dendl;
./msg/async/AsyncConnection.cc:2477:        ldout(async_msgr->cct, 1) << __func__ << " send outcoming bl failed" << dendl;
./msg/async/AsyncConnection.cc:2507:  ldout(async_msgr->cct, 20) << __func__ << " last_id=" << last_tick_id
./msg/async/AsyncConnection.cc:2513:    ldout(async_msgr->cct, 1) << __func__ << " idle(" << idle_period << ") more than "
./msg/async/dpdk/IP.cc:144:  ldout(cct, 10) << __func__ << " get " << std::hex << int(h.ip_proto)
./msg/async/dpdk/IP.cc:164:    ldout(cct, 20) << __func__ << " learn mac " << from << " with " << h.src_ip << dendl;
./msg/async/dpdk/IP.cc:290:    ldout(cct, 20) << " ipv4::send " << " id=" << iph->id << " " << _host_address << " -> " << to
./msg/async/dpdk/IP.cc:335:        ldout(cct, 20) << " ipv4::get_packet len " << l4p->p.len() << dendl;
./msg/async/dpdk/EventDPDK.cc:36:	ldout(cct, 20) << __func__ << " add event fd=" << fd << " cur_mask=" << cur_mask
./msg/async/dpdk/EventDPDK.cc:51:	ldout(cct, 20) << __func__ << " del event fd=" << fd << " cur_mask=" << cur_mask
./msg/async/dpdk/DPDKStack.cc:87:    ldout(cct, 1) << __func__ << " using " << cores << " cores " << dendl;
./msg/async/dpdk/DPDKStack.cc:206:  ldout(cct, 10) << __func__ << " addr " << sa << dendl;
./msg/async/dpdk/DPDKStack.cc:235:  ldout(cct, 10) << __func__ << " addr " << addr << dendl;
./msg/async/dpdk/DPDK.cc:165:    ldout(cct, 1) << __func__ << " Device is an Intel's 40G NIC. Enabling 8 fragments hack!" << dendl;
./msg/async/dpdk/DPDK.cc:170:    ldout(cct, 1) << __func__ << " Device is a VMWare Virtual NIC. Enabling 16 fragments hack!" << dendl;
./msg/async/dpdk/DPDK.cc:226:  ldout(cct, 5) << __func__ << " Port " << int(_port_idx) << ": max_rx_queues "
./msg/async/dpdk/DPDK.cc:232:  ldout(cct, 5) << __func__ << " Port " << int(_port_idx) << ": using "
./msg/async/dpdk/DPDK.cc:271:      ldout(cct, 5) << __func__ << " Port " << int(_port_idx)
./msg/async/dpdk/DPDK.cc:293:    ldout(cct, 1) << __func__ << " LRO is on" << dendl;
./msg/async/dpdk/DPDK.cc:298:    ldout(cct, 1) << __func__ << " LRO is off" << dendl;
./msg/async/dpdk/DPDK.cc:312:    ldout(cct, 1) << __func__ << " RX checksum offload supported" << dendl;
./msg/async/dpdk/DPDK.cc:318:    ldout(cct, 1) << __func__ << " TX ip checksum offload supported" << dendl;
./msg/async/dpdk/DPDK.cc:324:    ldout(cct, 1) << __func__ << " TSO is supported" << dendl;
./msg/async/dpdk/DPDK.cc:336:    ldout(cct, 1) << __func__ << " TX TCP checksum offload supported" << dendl;
./msg/async/dpdk/DPDK.cc:342:  ldout(cct, 1) << __func__ << " Port " << int(_port_idx) << " init ... " << dendl;
./msg/async/dpdk/DPDK.cc:356:  ldout(cct, 1) << __func__ << " done." << dendl;
./msg/async/dpdk/DPDK.cc:368:    ldout(cct, 1) << __func__ << " port " << int(_port_idx)
./msg/async/dpdk/DPDK.cc:387:    ldout(cct, 1) << __func__ << " port " << int(_port_idx)
./msg/async/dpdk/DPDK.cc:398:  ldout(cct, 1) << __func__ << " port " << int(_port_idx) << ":  HW FC " << _enable_fc << dendl;
./msg/async/dpdk/DPDK.cc:402:  ldout(cct, 1) << __func__ << " port " << int(_port_idx) << ": changing HW FC settings is not supported" << dendl;
./msg/async/dpdk/DPDK.cc:417:      ldout(cct, 5) << __func__ << " Port " << _port_idx << ": HASH FILTER configuration is supported" << dendl;
./msg/async/dpdk/DPDK.cc:441:  ldout(cct, 5) << __func__ << " created DPDK device" << dendl;
./msg/async/dpdk/DPDK.cc:492:    ldout(cct, 1) << __func__ << " Creating Rx mbuf pool '" << name.c_str()
./msg/async/dpdk/DPDK.cc:544:  ldout(cct, 20) << __func__ << dendl;
./msg/async/dpdk/DPDK.cc:554:        ldout(cct, 5) << __func__ << " done port "
./msg/async/dpdk/DPDK.cc:562:        ldout(cct, 20) << __func__ << " not ready, continue to wait." << dendl;
./msg/async/dpdk/DPDK.cc:632:  ldout(cct, 20) << __func__ << " started." << dendl;
./msg/async/dpdk/DPDK.cc:637:    ldout(cct, 0) << __func__ << " failed to get port statistics: " << cpp_strerror(rc) << dendl;
./msg/async/dpdk/DPDK.cc:669:            // ldout(cct, 0) << __func__ << " len: " << p->len() << " frags: " << p->nr_frags() << dendl;
./msg/async/dpdk/DPDK.cc:756:    ldout(cct, 10) << __func__ << " free segs " << _num_rx_free_segs
./msg/async/dpdk/DPDK.cc:771:        ldout(cct, 1) << __func__ << " get new mbuf failed " << dendl;
./msg/async/dpdk/DPDK.cc:816:    // ldout(cct, 0) << __func__ << " len " << p->len() << " " << dendl;
./msg/async/dpdk/DPDK.cc:874:      ldout(cct, 0) << __func__ << " rx count=" << rx_count << " avg rx=" << Cycles::to_nanoseconds(rx_cycles)/rx_count << "ns "
./msg/async/dpdk/DPDK.cc:892:    ldout(cct, 0) << __func__ << " Creating Tx mbuf pool '" << name.c_str()
./msg/async/dpdk/DPDK.cc:1051:      ldout(cct, 1) << __func__ << " no available mbuf for " << p.frag(0).size << dendl;
./msg/async/dpdk/DPDK.cc:1055:    ldout(cct, 1) << __func__ << " no available mbuf for " << p.frag(0).size << dendl;
./msg/async/dpdk/DPDK.cc:1064:      ldout(cct, 1) << __func__ << " no available mbuf for " << p.frag(i).size << dendl;
./msg/async/dpdk/DPDK.cc:1262:    ldout(cct, 10) << __func__ << " ports number: " << int(rte_eth_dev_count()) << dendl;
./msg/async/dpdk/UserspaceEvent.cc:39:  ldout(cct, 20) << __func__ << " fd=" << fd << dendl;
./msg/async/dpdk/UserspaceEvent.cc:45:  ldout(cct, 20) << __func__ << " fd=" << fd << " mask=" << mask << dendl;
./msg/async/dpdk/UserspaceEvent.cc:53:  ldout(cct, 20) << __func__ << " activing=" << int(impl->activating_mask)
./msg/async/dpdk/UserspaceEvent.cc:68:  ldout(cct, 20) << __func__ << " activing=" << int(impl->activating_mask)
./msg/async/dpdk/UserspaceEvent.cc:76:  ldout(cct, 20) << __func__ << " fd=" << fd << dendl;
./msg/async/dpdk/UserspaceEvent.cc:116:    ldout(cct, 20) << __func__ << " fd=" << fd << " mask=" << masks[count] << dendl;
./msg/async/dpdk/net.cc:67:        ldout(cct, 10) << "=== tx === proto " << std::hex << uint16_t(l3pv.proto_num)
./msg/async/dpdk/net.cc:134:      ldout(cct, 10) << __func__ << " === rx === proto " << std::hex << ::ntoh(eh->eth_proto)
./msg/async/dpdk/net.cc:138:      ldout(cct, 10) << __func__ << " === rx === proto " << std::hex << ::ntoh(eh->eth_proto)
./msg/async/dpdk/net.cc:157:        ldout(cct, 1) << __func__ << " forward to " << fw << dendl;
./msg/async/dpdk/TCP.cc:180:  ldout(cct, 20) << __func__ << " tcp header rst=" << bool(rth->f_rst) << " fin=" << bool(rth->f_fin)
./msg/async/dpdk/TCP.cc:254:  ldout(_tcp.cct, 10) << __func__ << " listen: LISTEN -> SYN_RECEIVED" << dendl;
./msg/async/dpdk/TCP.cc:269:  ldout(_tcp.cct, 20) << __func__ << " tcp header seq " << seg_seq.raw << " ack " << seg_ack.raw
./msg/async/dpdk/TCP.cc:316:      ldout(_tcp.cct, 20) << __func__ << " syn: SYN_SENT -> ESTABLISHED" << dendl;
./msg/async/dpdk/TCP.cc:323:      ldout(_tcp.cct, 20) << __func__ << " syn: SYN_SENT -> SYN_RECEIVED" << dendl;
./msg/async/dpdk/TCP.cc:342:  ldout(_tcp.cct, 20) << __func__ << " tcp header seq " << seg_seq.raw << " ack " << seg_ack.raw
./msg/async/dpdk/TCP.cc:358:    ldout(_tcp.cct, 10) << __func__ << " dup segment len " << dup << dendl;
./msg/async/dpdk/TCP.cc:366:    ldout(_tcp.cct, 10) << __func__ << " out of order, expect " << _rcv.next.raw
./msg/async/dpdk/TCP.cc:437:        ldout(_tcp.cct, 20) << __func__ << " SYN_RECEIVED -> ESTABLISHED" << dendl;
./msg/async/dpdk/TCP.cc:440:          ldout(_tcp.cct, 20) << __func__ << " successfully accepting socket" << dendl;
./msg/async/dpdk/TCP.cc:442:          ldout(_tcp.cct, 5) << __func__ << " not exist listener or full queue, reset" << dendl;
./msg/async/dpdk/TCP.cc:451:      ldout(_tcp.cct, 20) << __func__ << " window update seg_seq=" << seg_seq
./msg/async/dpdk/TCP.cc:496:            ldout(_tcp.cct, 20) << __func__ << " ack: full_ack" << dendl;
./msg/async/dpdk/TCP.cc:503:            ldout(_tcp.cct, 20) << __func__ << " ack: partial_ack" << dendl;
./msg/async/dpdk/TCP.cc:584:        ldout(_tcp.cct, 20) << __func__ << " ack: FIN_WAIT_1 -> FIN_WAIT_2" << dendl;
./msg/async/dpdk/TCP.cc:599:        ldout(_tcp.cct, 20) << __func__ << " ack: CLOSING -> TIME_WAIT" << dendl;
./msg/async/dpdk/TCP.cc:609:        ldout(_tcp.cct, 20) << __func__ << " ack: LAST_ACK -> CLOSED" << dendl;
./msg/async/dpdk/TCP.cc:651:      ldout(_tcp.cct, 20) << __func__ << " merged=" << merged << " do_output=" << do_output << dendl;
./msg/async/dpdk/TCP.cc:680:        ldout(_tcp.cct, 20) << __func__ << " fin: SYN_RECEIVED or ESTABLISHED -> CLOSE_WAIT" << dendl;
./msg/async/dpdk/TCP.cc:690:        ldout(_tcp.cct, 20) << __func__ << " fin: FIN_WAIT_1 -> CLOSING" << dendl;
./msg/async/dpdk/TCP.cc:694:        ldout(_tcp.cct, 20) << __func__ << " fin: FIN_WAIT_2 -> TIME_WAIT" << dendl;
./msg/async/dpdk/TCP.cc:709:  ldout(_tcp.cct, 20) << __func__ << dendl;
./msg/async/dpdk/TCP.cc:736:  ldout(_tcp.cct, 20) << __func__ << " unsent_len=" << _snd.unsent_len << dendl;
./msg/async/dpdk/TCP.cc:738:    ldout(_tcp.cct, 20) << __func__ << " CLOSE_WAIT -> LAST_ACK" << dendl;
./msg/async/dpdk/TCP.cc:741:    ldout(_tcp.cct, 20) << __func__ << " ESTABLISHED -> FIN_WAIT_1" << dendl;
./msg/async/dpdk/TCP.cc:769:      ldout(_tcp.cct, 5) << __func__ << " syn retransmit exceed max "
./msg/async/dpdk/TCP.cc:782:      ldout(_tcp.cct, 5) << __func__ << " fin retransmit exceed max "
./msg/async/dpdk/TCP.cc:811:  ldout(_tcp.cct, 20) << __func__ << " unack data size " << _snd.data.size()
./msg/async/dpdk/TCP.cc:817:    ldout(_tcp.cct, 5) << __func__ << " seg retransmit exceed max "
./msg/async/dpdk/TCP.cc:830:  ldout(_tcp.cct, 20) << __func__ << " persist timer fired" << dendl;
./msg/simple/Accepter.cc:83:  ldout(msgr->cct,10) <<  __func__ << dendl;
./msg/simple/Accepter.cc:99:  ldout(msgr->cct,10) <<  __func__ << " socket sd: " << listen_sd << dendl;
./msg/simple/Accepter.cc:176:        ldout(msgr->cct,10) << __func__ << " bound on random port " 
./msg/simple/Accepter.cc:222:  ldout(msgr->cct,10) <<  __func__ << " bound to " << listen_addr << dendl;
./msg/simple/Accepter.cc:257:  ldout(msgr->cct,1) <<  __func__ << " my_inst.addr is " << msgr->get_myaddr()
./msg/simple/Accepter.cc:264:  ldout(msgr->cct,1) << __func__ << " avoid " << avoid_ports << dendl;
./msg/simple/Accepter.cc:274:  ldout(msgr->cct,10) << __func__ << " new nonce " << nonce << " and inst " 
./msg/simple/Accepter.cc:277:  ldout(msgr->cct,10) << " will try " << addr << " and avoid ports " << new_avoid << dendl;
./msg/simple/Accepter.cc:286:  ldout(msgr->cct,1) << __func__ << dendl;
./msg/simple/Accepter.cc:296:  ldout(msgr->cct,1) << __func__ << " start" << dendl;
./msg/simple/Accepter.cc:308:    ldout(msgr->cct,20) << __func__ << " calling poll for sd:" << listen_sd << dendl;
./msg/simple/Accepter.cc:314:      ldout(msgr->cct,1) << __func__ << " poll got error"  
./msg/simple/Accepter.cc:318:    ldout(msgr->cct,10) << __func__ << " poll returned oke: " << r << dendl;
./msg/simple/Accepter.cc:319:    ldout(msgr->cct,20) << __func__ <<  " pfd.revents[0]=" << pfd[0].revents << dendl;
./msg/simple/Accepter.cc:320:    ldout(msgr->cct,20) << __func__ <<  " pfd.revents[1]=" << pfd[1].revents << dendl;
./msg/simple/Accepter.cc:323:      ldout(msgr->cct,1) << __func__ << " poll got errors in revents "  
./msg/simple/Accepter.cc:333:          ldout(msgr->cct,1) << __func__ << " Cannot read selfpipe: "
./msg/simple/Accepter.cc:347:	ldout(msgr->cct,1) << __func__ << " set_close_on_exec() failed "
./msg/simple/Accepter.cc:351:      ldout(msgr->cct,10) << __func__ << " incoming on sd " << sd << dendl;
./msg/simple/Accepter.cc:355:      ldout(msgr->cct,0) << __func__ << " no incoming connection?  sd = " << sd
./msg/simple/Accepter.cc:362:  ldout(msgr->cct,20) << __func__ << " closing" << dendl;
./msg/simple/Accepter.cc:370:  ldout(msgr->cct,10) << __func__ << " stopping" << dendl;
./msg/simple/Accepter.cc:377:  ldout(msgr->cct,10) << __func__ << " accept listening on: " << listen_sd << dendl;
./msg/simple/Accepter.cc:386:    ldout(msgr->cct,1) << __func__ << " close failed: "
./msg/simple/Accepter.cc:389:    ldout(msgr->cct,15) << __func__ << " signaled poll" << dendl;
./msg/simple/Accepter.cc:397:    ldout(msgr->cct,5) << __func__ << " wait for thread to join." << dendl;
./msg/simple/Accepter.cc:403:      ldout(msgr->cct,1) << __func__ << " close listen_sd failed: "
./msg/simple/Accepter.cc:410:      ldout(msgr->cct,1) << __func__ << " close shutdown_rd_fd failed: "
./msg/simple/SimpleMessenger.cc:73:  ldout(cct,10) << "ready " << get_myaddr() << dendl;
./msg/simple/SimpleMessenger.cc:85:  ldout(cct,10) << "shutdown " << get_myaddr() << dendl;
./msg/simple/SimpleMessenger.cc:107:  ldout(cct,1) <<"--> " << dest.name << " "
./msg/simple/SimpleMessenger.cc:114:    ldout(cct,0) << "send_message message " << *m
./msg/simple/SimpleMessenger.cc:135:  ldout(cct,1) << "--> " << con->get_peer_addr()
./msg/simple/SimpleMessenger.cc:209:  ldout(cct,10) << "reaper_entry start" << dendl;
./msg/simple/SimpleMessenger.cc:218:  ldout(cct,10) << "reaper_entry done" << dendl;
./msg/simple/SimpleMessenger.cc:226:  ldout(cct,10) << "reaper" << dendl;
./msg/simple/SimpleMessenger.cc:232:    ldout(cct,10) << "reaper reaping pipe " << p << " " <<
./msg/simple/SimpleMessenger.cc:257:    ldout(cct,10) << "reaper reaped pipe " << p << " " << p->get_peer_addr() << dendl;
./msg/simple/SimpleMessenger.cc:259:    ldout(cct,10) << "reaper deleted pipe " << p << dendl;
./msg/simple/SimpleMessenger.cc:261:  ldout(cct,10) << "reaper done" << dendl;
./msg/simple/SimpleMessenger.cc:266:  ldout(cct,10) << "queue_reap " << pipe << dendl;
./msg/simple/SimpleMessenger.cc:291:    ldout(cct,10) << "rank.bind already started" << dendl;
./msg/simple/SimpleMessenger.cc:295:  ldout(cct,10) << "rank.bind " << bind_addr << dendl;
./msg/simple/SimpleMessenger.cc:308:  ldout(cct,1) << "rebind avoid " << avoid_ports << dendl;
./msg/simple/SimpleMessenger.cc:326:    ldout(cct,10) << "rank.bind already started" << dendl;
./msg/simple/SimpleMessenger.cc:329:  ldout(cct,10) << "rank.bind " << bind_addr << dendl;
./msg/simple/SimpleMessenger.cc:339:  ldout(cct,1) << "messenger.start" << dendl;
./msg/simple/SimpleMessenger.cc:385:  ldout(cct,10) << "connect_rank to " << addr << ", creating pipe and registering" << dendl;
./msg/simple/SimpleMessenger.cc:433:      ldout(cct, 10) << "get_connection " << dest << " existing " << pipe << dendl;
./msg/simple/SimpleMessenger.cc:436:      ldout(cct, 10) << "get_connection " << dest << " new " << pipe << dendl;
./msg/simple/SimpleMessenger.cc:457:    ldout(cct, 0) << "submit_message " << *m << "\n";
./msg/simple/SimpleMessenger.cc:472:      ldout(cct,0) << "submit_message " << *m << " remote, " << dest_addr
./msg/simple/SimpleMessenger.cc:481:	ldout(cct,20) << "submit_message " << *m << " remote, " << dest_addr << ", have pipe." << dendl;
./msg/simple/SimpleMessenger.cc:491:	ldout(cct,20) << "submit_message " << *m << " remote, " << dest_addr
./msg/simple/SimpleMessenger.cc:507:    ldout(cct,20) << "submit_message " << *m << " local" << dendl;
./msg/simple/SimpleMessenger.cc:516:    ldout(cct,20) << "submit_message " << *m << " remote, " << dest_addr << ", lossy server for target type "
./msg/simple/SimpleMessenger.cc:520:    ldout(cct,20) << "submit_message " << *m << " remote, " << dest_addr << ", new pipe." << dendl;
./msg/simple/SimpleMessenger.cc:539:    ldout(cct,20) << "send_keepalive con " << con << ", have pipe." << dendl;
./msg/simple/SimpleMessenger.cc:546:    ldout(cct,0) << "send_keepalive con " << con << ", no pipe." << dendl;
./msg/simple/SimpleMessenger.cc:568:    ldout(cct,20) << "wait: stopping accepter thread" << dendl;
./msg/simple/SimpleMessenger.cc:571:    ldout(cct,20) << "wait: stopped accepter thread" << dendl;
./msg/simple/SimpleMessenger.cc:576:    ldout(cct,10) << "wait: waiting for dispatch queue" << dendl;
./msg/simple/SimpleMessenger.cc:579:    ldout(cct,10) << "wait: dispatch queue is stopped" << dendl;
./msg/simple/SimpleMessenger.cc:583:    ldout(cct,20) << "wait: stopping reaper thread" << dendl;
./msg/simple/SimpleMessenger.cc:590:    ldout(cct,20) << "wait: stopped reaper thread" << dendl;
./msg/simple/SimpleMessenger.cc:596:    ldout(cct,10) << "wait: closing pipes" << dendl;
./msg/simple/SimpleMessenger.cc:611:    ldout(cct,10) << "wait: waiting for pipes " << pipes << " to close" << dendl;
./msg/simple/SimpleMessenger.cc:619:  ldout(cct,10) << "wait: done." << dendl;
./msg/simple/SimpleMessenger.cc:620:  ldout(cct,1) << "shutdown complete." << dendl;
./msg/simple/SimpleMessenger.cc:627:  ldout(cct,1) << "mark_down_all" << dendl;
./msg/simple/SimpleMessenger.cc:631:    ldout(cct,5) << "mark_down_all accepting_pipe " << p << dendl;
./msg/simple/SimpleMessenger.cc:644:    ldout(cct,5) << "mark_down_all " << it->first << " " << p << dendl;
./msg/simple/SimpleMessenger.cc:662:    ldout(cct,1) << "mark_down " << addr << " -- " << p << dendl;
./msg/simple/SimpleMessenger.cc:676:    ldout(cct,1) << "mark_down " << addr << " -- pipe dne" << dendl;
./msg/simple/SimpleMessenger.cc:688:    ldout(cct,1) << "mark_down " << con << " -- " << p << dendl;
./msg/simple/SimpleMessenger.cc:701:    ldout(cct,1) << "mark_down " << con << " -- pipe dne" << dendl;
./msg/simple/SimpleMessenger.cc:711:    ldout(cct,1) << "mark_disposable " << con << " -- " << p << dendl;
./msg/simple/SimpleMessenger.cc:718:    ldout(cct,1) << "mark_disposable " << con << " -- pipe dne" << dendl;
./msg/simple/SimpleMessenger.cc:742:    ldout(cct,1) << "learned my addr " << my_inst.addr << dendl;
./msg/simple/Pipe.cc:318:  ldout(msgr->cct,10) << "accept" << dendl;
./msg/simple/Pipe.cc:361:    ldout(msgr->cct,10) << "accept couldn't write banner" << dendl;
./msg/simple/Pipe.cc:375:    ldout(msgr->cct,0) << "accept failed to getpeername " << cpp_strerror(errno) << dendl;
./msg/simple/Pipe.cc:383:    ldout(msgr->cct,10) << "accept couldn't write my+peer addr" << dendl;
./msg/simple/Pipe.cc:387:  ldout(msgr->cct,1) << "accept sd=" << sd << " " << socket_addr << dendl;
./msg/simple/Pipe.cc:391:    ldout(msgr->cct,10) << "accept couldn't read banner" << dendl;
./msg/simple/Pipe.cc:396:    ldout(msgr->cct,1) << "accept peer sent bad banner '" << banner << "' (should be '" << CEPH_BANNER << "')" << dendl;
./msg/simple/Pipe.cc:404:    ldout(msgr->cct,10) << "accept couldn't read peer_addr" << dendl;
./msg/simple/Pipe.cc:411:    ldout(msgr->cct,2) << __func__ <<  " decode peer_addr failed: " << e.what()
./msg/simple/Pipe.cc:416:  ldout(msgr->cct,10) << "accept peer addr is " << peer_addr << dendl;
./msg/simple/Pipe.cc:422:    ldout(msgr->cct,0) << "accept peer addr is really " << peer_addr
./msg/simple/Pipe.cc:429:      ldout(msgr->cct,10) << "accept couldn't read connect" << dendl;
./msg/simple/Pipe.cc:437:        ldout(msgr->cct,10) << "accept couldn't read connect authorizer" << dendl;
./msg/simple/Pipe.cc:444:    ldout(msgr->cct,20) << "accept got peer connect_seq " << connect.connect_seq
./msg/simple/Pipe.cc:459:    ldout(msgr->cct,10) << "accept of host_type " << connect.host_type
./msg/simple/Pipe.cc:471:    ldout(msgr->cct,10) << "accept my proto " << reply.protocol_version
./msg/simple/Pipe.cc:484:	  ldout(msgr->cct,10) << "using cephx, requiring MSG_AUTH feature bit for cluster" << dendl;
./msg/simple/Pipe.cc:490:	  ldout(msgr->cct,10) << "using cephx, requiring MSG_AUTH feature bit for service" << dendl;
./msg/simple/Pipe.cc:498:      ldout(msgr->cct,1) << "peer missing required features " << std::hex << feat_missing << std::dec << dendl;
./msg/simple/Pipe.cc:510:      ldout(msgr->cct,0) << "accept: got bad authorizer" << dendl;
./msg/simple/Pipe.cc:521:    ldout(msgr->cct,10) << "accept:  setting up session_security." << dendl;
./msg/simple/Pipe.cc:560:	ldout(msgr->cct,10) << "accept existing " << existing << ".gseq " << existing->peer_global_seq
./msg/simple/Pipe.cc:568:	ldout(msgr->cct,10) << "accept existing " << existing << ".gseq " << existing->peer_global_seq
./msg/simple/Pipe.cc:573:	ldout(msgr->cct,0) << "accept replacing existing (lossy) channel (new one lossy="
./msg/simple/Pipe.cc:579:      ldout(msgr->cct,0) << "accept connect_seq " << connect.connect_seq
./msg/simple/Pipe.cc:584:	ldout(msgr->cct,0) << "accept peer reset, then tried to connect to us, replacing" << dendl;
./msg/simple/Pipe.cc:594:	ldout(msgr->cct,10) << "accept existing " << existing << ".cseq " << existing->connect_seq
./msg/simple/Pipe.cc:606:	  ldout(msgr->cct,10) << "accept connection race, existing " << existing
./msg/simple/Pipe.cc:617:	  ldout(msgr->cct,10) << "accept connection race, existing " << existing << ".cseq " << existing->connect_seq
./msg/simple/Pipe.cc:631:	  ldout(msgr->cct,10) << "accept connection race, existing " << existing << ".cseq " << existing->connect_seq
./msg/simple/Pipe.cc:654:	ldout(msgr->cct,0) << "accept we reset (peer sent cseq " << connect.connect_seq 
./msg/simple/Pipe.cc:664:      ldout(msgr->cct,10) << "accept peer sent cseq " << connect.connect_seq
./msg/simple/Pipe.cc:670:      ldout(msgr->cct,0) << "accept we reset (peer sent cseq " << connect.connect_seq << "), sending RESETSESSION" << dendl;
./msg/simple/Pipe.cc:676:      ldout(msgr->cct,10) << "accept new session" << dendl;
./msg/simple/Pipe.cc:714:  ldout(msgr->cct,10) << "accept replacing " << existing << dendl;
./msg/simple/Pipe.cc:756:    ldout(msgr->cct,10) << "accept re-queuing on out_seq " << out_seq << " in_seq " << in_seq << dendl;
./msg/simple/Pipe.cc:772:  ldout(msgr->cct,10) << "accept success, connect_seq = " << connect_seq << ", sending READY" << dendl;
./msg/simple/Pipe.cc:785:  ldout(msgr->cct,10) << "accept features " << connection_state->get_features() << dendl;
./msg/simple/Pipe.cc:820:      ldout(msgr->cct,2) << "accept write error on in_seq" << dendl;
./msg/simple/Pipe.cc:824:      ldout(msgr->cct,2) << "accept read error on newly_acked_seq" << dendl;
./msg/simple/Pipe.cc:832:    ldout(msgr->cct,10) << "accept starting writer, state " << get_state_name() << dendl;
./msg/simple/Pipe.cc:835:  ldout(msgr->cct,20) << "accept done" << dendl;
./msg/simple/Pipe.cc:842:  ldout(msgr->cct, 10) << "accept fault after register" << dendl;
./msg/simple/Pipe.cc:845:    ldout(msgr->cct, 10) << " sleep for " << msgr->cct->_conf->ms_inject_internal_delays << dendl;
./msg/simple/Pipe.cc:855:    ldout(msgr->cct, 10) << "  queued = " << (int)queued << dendl;
./msg/simple/Pipe.cc:876:    ldout(msgr->cct, 10) << " sleep for " << msgr->cct->_conf->ms_inject_internal_delays << dendl;
./msg/simple/Pipe.cc:896:      ldout(msgr->cct,0) << "couldn't set TCP_NODELAY: "
./msg/simple/Pipe.cc:905:      ldout(msgr->cct,0) << "couldn't set SO_RCVBUF to " << size
./msg/simple/Pipe.cc:916:    ldout(msgr->cct,0) << "couldn't set SO_NOSIGPIPE: "
./msg/simple/Pipe.cc:948:      ldout(msgr->cct,0) << "couldn't set TOS to " << iptos
./msg/simple/Pipe.cc:958:      ldout(msgr->cct,0) << "couldn't set SO_PRIORITY to " << prio
./msg/simple/Pipe.cc:969:  ldout(msgr->cct,10) << "connect " << connect_seq << dendl;
./msg/simple/Pipe.cc:1014:        ldout(msgr->cct,2) << "client bind error " << ", " << cpp_strerror(errno) << dendl;
./msg/simple/Pipe.cc:1021:  ldout(msgr->cct,10) << "connecting to " << peer_addr << dendl;
./msg/simple/Pipe.cc:1025:    ldout(msgr->cct,2) << "connect error " << peer_addr
./msg/simple/Pipe.cc:1028:      ldout(msgr->cct, 2) << "connection refused!" << dendl;
./msg/simple/Pipe.cc:1038:    ldout(msgr->cct,2) << "connect couldn't read banner, " << cpp_strerror(rc) << dendl;
./msg/simple/Pipe.cc:1042:    ldout(msgr->cct,0) << "connect protocol error (bad banner) on peer " << peer_addr << dendl;
./msg/simple/Pipe.cc:1054:    ldout(msgr->cct,2) << "connect couldn't write my banner, " << cpp_strerror(rc) << dendl;
./msg/simple/Pipe.cc:1070:    ldout(msgr->cct,2) << "connect couldn't read peer addrs, " << cpp_strerror(rc) << dendl;
./msg/simple/Pipe.cc:1079:    ldout(msgr->cct,2) << "connect couldn't decode peer addrs: " << e.what()
./msg/simple/Pipe.cc:1085:  ldout(msgr->cct,20) << "connect read peer addr " << paddr << " on socket " << sd << dendl;
./msg/simple/Pipe.cc:1090:      ldout(msgr->cct,0) << "connect claims to be " 
./msg/simple/Pipe.cc:1093:      ldout(msgr->cct,10) << "connect claims to be "
./msg/simple/Pipe.cc:1099:  ldout(msgr->cct,20) << "connect peer addr for me is " << peer_addr_for_me << dendl;
./msg/simple/Pipe.cc:1113:    ldout(msgr->cct,2) << "connect couldn't write my addr, " << cpp_strerror(rc) << dendl;
./msg/simple/Pipe.cc:1116:  ldout(msgr->cct,10) << "connect sent my addr " << msgr->my_inst.addr << dendl;
./msg/simple/Pipe.cc:1133:      ldout(msgr->cct,10) << "connect.authorizer_len=" << connect.authorizer_len
./msg/simple/Pipe.cc:1151:    ldout(msgr->cct,10) << "connect sending gseq=" << gseq << " cseq=" << cseq
./msg/simple/Pipe.cc:1155:      ldout(msgr->cct,2) << "connect couldn't write gseq, cseq, " << cpp_strerror(rc) << dendl;
./msg/simple/Pipe.cc:1159:    ldout(msgr->cct,20) << "connect wrote (self +) cseq, waiting for reply" << dendl;
./msg/simple/Pipe.cc:1163:      ldout(msgr->cct,2) << "connect read reply " << cpp_strerror(rc) << dendl;
./msg/simple/Pipe.cc:1167:    ldout(msgr->cct,20) << "connect got reply tag " << (int)reply.tag
./msg/simple/Pipe.cc:1178:      ldout(msgr->cct,10) << "reply.authorizer_len=" << reply.authorizer_len << dendl;
./msg/simple/Pipe.cc:1182:        ldout(msgr->cct,10) << "connect couldn't read connect authorizer_reply" << cpp_strerror(rc) << dendl;
./msg/simple/Pipe.cc:1191:        ldout(msgr->cct,0) << "failed verifying authorize reply" << dendl;
./msg/simple/Pipe.cc:1197:      ldout(msgr->cct, 10) << " sleep for " << msgr->cct->_conf->ms_inject_internal_delays << dendl;
./msg/simple/Pipe.cc:1205:      ldout(msgr->cct,0) << "connect got RESETSESSION but no longer connecting" << dendl;
./msg/simple/Pipe.cc:1210:      ldout(msgr->cct,0) << "connect protocol feature mismatch, my " << std::hex
./msg/simple/Pipe.cc:1218:      ldout(msgr->cct,0) << "connect protocol version mismatch, my " << connect.protocol_version
./msg/simple/Pipe.cc:1224:      ldout(msgr->cct,0) << "connect got BADAUTHORIZER" << dendl;
./msg/simple/Pipe.cc:1234:      ldout(msgr->cct,0) << "connect got RESETSESSION" << dendl;
./msg/simple/Pipe.cc:1242:      ldout(msgr->cct,10) << "connect got RETRY_GLOBAL " << reply.global_seq
./msg/simple/Pipe.cc:1249:      ldout(msgr->cct,10) << "connect got RETRY_SESSION " << connect_seq
./msg/simple/Pipe.cc:1257:      ldout(msgr->cct,3) << "connect got WAIT (connection race)" << dendl;
./msg/simple/Pipe.cc:1266:	ldout(msgr->cct,1) << "missing required features " << std::hex << feat_missing << std::dec << dendl;
./msg/simple/Pipe.cc:1271:        ldout(msgr->cct,10) << "got CEPH_MSGR_TAG_SEQ, reading acked_seq and writing in_seq" << dendl;
./msg/simple/Pipe.cc:1275:          ldout(msgr->cct,2) << "connect read error on newly_acked_seq" << cpp_strerror(rc) << dendl;
./msg/simple/Pipe.cc:1278:	ldout(msgr->cct,2) << " got newly_acked_seq " << newly_acked_seq
./msg/simple/Pipe.cc:1283:	  ldout(msgr->cct,2) << " discarding previously sent " << m->get_seq()
./msg/simple/Pipe.cc:1290:          ldout(msgr->cct,2) << "connect write error on in_seq" << dendl;
./msg/simple/Pipe.cc:1303:      ldout(msgr->cct,10) << "connect success " << connect_seq << ", lossy = " << policy.lossy
./msg/simple/Pipe.cc:1325:	ldout(msgr->cct,20) << "connect starting reader" << dendl;
./msg/simple/Pipe.cc:1334:    ldout(msgr->cct,0) << "connect got bad tag " << (int)tag << dendl;
./msg/simple/Pipe.cc:1340:    ldout(msgr->cct, 10) << " sleep for " << msgr->cct->_conf->ms_inject_internal_delays << dendl;
./msg/simple/Pipe.cc:1351:    ldout(msgr->cct,3) << "connect fault, but state = " << get_state_name()
./msg/simple/Pipe.cc:1361:  ldout(msgr->cct,10) << "register_pipe" << dendl;
./msg/simple/Pipe.cc:1373:    ldout(msgr->cct,10) << "unregister_pipe" << dendl;
./msg/simple/Pipe.cc:1376:    ldout(msgr->cct,10) << "unregister_pipe - not registered" << dendl;
./msg/simple/Pipe.cc:1383:  ldout(msgr->cct, 20) << "join" << dendl;
./msg/simple/Pipe.cc:1389:    ldout(msgr->cct, 20) << "joining delay_thread" << dendl;
./msg/simple/Pipe.cc:1404:    ldout(msgr->cct,10) << "requeue_sent " << *m << " for resend seq " << out_seq
./msg/simple/Pipe.cc:1413:  ldout(msgr->cct, 10) << "discard_requeued_up_to " << seq << dendl;
./msg/simple/Pipe.cc:1423:    ldout(msgr->cct,10) << "discard_requeued_up_to " << *m << " for resend seq " << out_seq
./msg/simple/Pipe.cc:1439:  ldout(msgr->cct,10) << "discard_queue" << dendl;
./msg/simple/Pipe.cc:1442:    ldout(msgr->cct,20) << "  discard " << *p << dendl;
./msg/simple/Pipe.cc:1448:      ldout(msgr->cct,20) << "  discard " << *r << dendl;
./msg/simple/Pipe.cc:1461:    ldout(msgr->cct,10) << "fault already connecting, reader shutting down" << dendl;
./msg/simple/Pipe.cc:1465:  ldout(msgr->cct,2) << "fault " << cpp_strerror(errno) << dendl;
./msg/simple/Pipe.cc:1469:    ldout(msgr->cct,10) << "fault already closed|closing" << dendl;
./msg/simple/Pipe.cc:1479:    ldout(msgr->cct,10) << "fault on lossy channel, failing" << dendl;
./msg/simple/Pipe.cc:1492:      ldout(msgr->cct, 10) << " sleep for " << msgr->cct->_conf->ms_inject_internal_delays << dendl;
./msg/simple/Pipe.cc:1520:    ldout(msgr->cct,0) << "fault with nothing to send, going to standby" << dendl;
./msg/simple/Pipe.cc:1527:      ldout(msgr->cct,0) << "fault, server, going to standby" << dendl;
./msg/simple/Pipe.cc:1530:      ldout(msgr->cct,0) << "fault, initiating reconnect" << dendl;
./msg/simple/Pipe.cc:1536:    ldout(msgr->cct,0) << "fault" << dendl;
./msg/simple/Pipe.cc:1539:    ldout(msgr->cct,10) << "fault waiting " << backoff << dendl;
./msg/simple/Pipe.cc:1544:    ldout(msgr->cct,10) << "fault done waiting or woke up" << dendl;
./msg/simple/Pipe.cc:1564:  ldout(msgr->cct,10) << "was_session_reset" << dendl;
./msg/simple/Pipe.cc:1580:  ldout(msgr->cct,10) << "stop" << dendl;
./msg/simple/Pipe.cc:1595:    ldout(msgr->cct, 10) << __func__ << " sleep for "
./msg/simple/Pipe.cc:1632:      ldout(msgr->cct,20) << "reader sleeping during reconnect|standby" << dendl;
./msg/simple/Pipe.cc:1643:    ldout(msgr->cct,20) << "reader reading tag..." << dendl;
./msg/simple/Pipe.cc:1646:      ldout(msgr->cct,2) << "reader couldn't read tag, " << cpp_strerror(errno) << dendl;
./msg/simple/Pipe.cc:1652:      ldout(msgr->cct,2) << "reader got KEEPALIVE" << dendl;
./msg/simple/Pipe.cc:1658:      ldout(msgr->cct,30) << "reader got KEEPALIVE2 tag ..." << dendl;
./msg/simple/Pipe.cc:1663:	ldout(msgr->cct,2) << "reader couldn't read KEEPALIVE2 stamp "
./msg/simple/Pipe.cc:1669:	ldout(msgr->cct,2) << "reader got KEEPALIVE2 " << keepalive_ack_stamp
./msg/simple/Pipe.cc:1677:      ldout(msgr->cct,2) << "reader got KEEPALIVE_ACK" << dendl;
./msg/simple/Pipe.cc:1682:	ldout(msgr->cct,2) << "reader couldn't read KEEPALIVE2 stamp " << cpp_strerror(errno) << dendl;
./msg/simple/Pipe.cc:1692:      ldout(msgr->cct,20) << "reader got ACK" << dendl;
./msg/simple/Pipe.cc:1697:	ldout(msgr->cct,2) << "reader couldn't read ack seq, " << cpp_strerror(errno) << dendl;
./msg/simple/Pipe.cc:1706:      ldout(msgr->cct,20) << "reader got MSG" << dendl;
./msg/simple/Pipe.cc:1733:	ldout(msgr->cct,0) << "reader got old message "
./msg/simple/Pipe.cc:1744:	ldout(msgr->cct,0) << "reader missed message?  skipped from seq "
./msg/simple/Pipe.cc:1757:      ldout(msgr->cct,10) << "reader got message "
./msg/simple/Pipe.cc:1789:      ldout(msgr->cct,20) << "reader got CLOSE" << dendl;
./msg/simple/Pipe.cc:1801:      ldout(msgr->cct,0) << "reader bad tag " << (int)tag << dendl;
./msg/simple/Pipe.cc:1812:  ldout(msgr->cct,10) << "reader done" << dendl;
./msg/simple/Pipe.cc:1822:    ldout(msgr->cct,10) << "writer: state = " << get_state_name()
./msg/simple/Pipe.cc:1838:      ldout(msgr->cct,20) << "writer writing CLOSE tag" << dendl;
./msg/simple/Pipe.cc:1868:	  ldout(msgr->cct,2) << "writer couldn't write keepalive[2], "
./msg/simple/Pipe.cc:1881:	  ldout(msgr->cct,2) << "writer couldn't write keepalive_ack, " << cpp_strerror(errno) << dendl;
./msg/simple/Pipe.cc:1895:	  ldout(msgr->cct,2) << "writer couldn't write ack, " << cpp_strerror(errno) << dendl;
./msg/simple/Pipe.cc:1918:	  ldout(msgr->cct,20) << "writer encoding " << m->get_seq() << " features " << features
./msg/simple/Pipe.cc:1921:	  ldout(msgr->cct,20) << "writer half-reencoding " << m->get_seq() << " features " << features
./msg/simple/Pipe.cc:1937:	  ldout(msgr->cct, 20) << "writer no session security" << dendl;
./msg/simple/Pipe.cc:1940:	    ldout(msgr->cct, 20) << "writer failed to sign seq # " << header.seq
./msg/simple/Pipe.cc:1943:	    ldout(msgr->cct, 20) << "writer signed seq # " << header.seq
./msg/simple/Pipe.cc:1956:        ldout(msgr->cct,20) << "writer sending " << m->get_seq() << " " << m << dendl;
./msg/simple/Pipe.cc:1961:          ldout(msgr->cct,1) << "writer error sending " << m << ", "
./msg/simple/Pipe.cc:1971:    ldout(msgr->cct,20) << "writer sleeping" << dendl;
./msg/simple/Pipe.cc:1975:  ldout(msgr->cct,20) << "writer finishing" << dendl;
./msg/simple/Pipe.cc:1980:  ldout(msgr->cct,10) << "writer done" << dendl;
./msg/simple/Pipe.cc:2022:  //ldout(msgr->cct,10) << "receiver.read_message from sd " << sd  << dendl;
./msg/simple/Pipe.cc:2034:  ldout(msgr->cct,20) << "reader got envelope type=" << header.type
./msg/simple/Pipe.cc:2043:    ldout(msgr->cct,0) << "reader got bad header crc " << header_crc << " != " << header.crc << dendl;
./msg/simple/Pipe.cc:2055:    ldout(msgr->cct,10) << "reader wants " << 1 << " message from policy throttler "
./msg/simple/Pipe.cc:2064:      ldout(msgr->cct,10) << "reader wants " << message_size << " bytes from policy throttler "
./msg/simple/Pipe.cc:2074:    ldout(msgr->cct,10) << "reader wants " << message_size << " from dispatch throttler "
./msg/simple/Pipe.cc:2089:    ldout(msgr->cct,20) << "reader got front " << front.length() << dendl;
./msg/simple/Pipe.cc:2099:    ldout(msgr->cct,20) << "reader got middle " << middle.length() << dendl;
./msg/simple/Pipe.cc:2124:	  ldout(msgr->cct,10) << "reader seleting rx buffer v " << p->second.second
./msg/simple/Pipe.cc:2137:	  ldout(msgr->cct,20) << "reader allocating new rx buffer at offset " << offset << dendl;
./msg/simple/Pipe.cc:2145:      ldout(msgr->cct,20) << "reader reading nonblocking into " << (void*)bp.c_str() << " len " << bp.length() << dendl;
./msg/simple/Pipe.cc:2147:      ldout(msgr->cct,30) << "reader read " << got << " of " << read << dendl;
./msg/simple/Pipe.cc:2176:  ldout(msgr->cct,10) << "aborted = " << aborted << dendl;
./msg/simple/Pipe.cc:2178:    ldout(msgr->cct,0) << "reader got " << front.length() << " + " << middle.length() << " + " << data.length()
./msg/simple/Pipe.cc:2184:  ldout(msgr->cct,20) << "reader got " << front.length() << " + " << middle.length() << " + " << data.length()
./msg/simple/Pipe.cc:2198:    ldout(msgr->cct, 10) << "No session security set" << dendl;
./msg/simple/Pipe.cc:2201:      ldout(msgr->cct, 0) << "Signature check failed" << dendl;
./msg/simple/Pipe.cc:2225:    ldout(msgr->cct,10) << "reader releasing " << 1 << " message to policy throttler "
./msg/simple/Pipe.cc:2232:      ldout(msgr->cct,10) << "reader releasing " << message_size << " bytes to policy throttler "
./msg/simple/Pipe.cc:2250:      ldout(msgr->cct,10) << "do_sendmsg hmm do_sendmsg got r==0!" << dendl;
./msg/simple/Pipe.cc:2253:      ldout(msgr->cct,1) << "do_sendmsg error " << cpp_strerror(r) << dendl;
./msg/simple/Pipe.cc:2257:      ldout(msgr->cct,10) << "do_sendmsg oh look, state == CLOSED, giving up" << dendl;
./msg/simple/Pipe.cc:2265:    ldout(msgr->cct,20) << "do_sendmsg short write did " << r << ", still have " << len << dendl;
./msg/simple/Pipe.cc:2269:	//ldout(msgr->cct,30) << "skipping " << msg->msg_iov[0].iov_len << ", " << (msg->msg_iovlen-1) << " v, " << r << " left" << dendl;
./msg/simple/Pipe.cc:2275:	//ldout(msgr->cct,30) << "adjusting " << msg->msg_iov[0].iov_len << ", " << msg->msg_iovlen << " v, " << r << " left" << dendl;
./msg/simple/Pipe.cc:2288:  ldout(msgr->cct,10) << "write_ack " << seq << dendl;
./msg/simple/Pipe.cc:2311:  ldout(msgr->cct,10) << "write_keepalive" << dendl;
./msg/simple/Pipe.cc:2330:  ldout(msgr->cct,10) << "write_keepalive2 " << (int)tag << " " << t << dendl;
./msg/simple/Pipe.cc:2381:      ldout(msgr->cct,0) << "donow = " << donow << " left " << left << " pb->length " << pb->length()
./msg/simple/Pipe.cc:2385:    ldout(msgr->cct,30) << " bl_pos " << bl_pos << " b_off " << b_off
./msg/simple/Pipe.cc:2466:	ldout(msgr->cct, 0) << "injecting socket failure" << dendl;
./msg/simple/Pipe.cc:2528:    ldout(msgr->cct, 10) << __func__ << " socket " << sd << " returned "
./msg/simple/Pipe.cc:2589:    ldout(msgr->cct, 10) << __func__ << " socket " << sd << " returned "
./msg/simple/Pipe.cc:2616:      ldout(msgr->cct, 0) << "injecting socket failure" << dendl;
./msg/Message.cc:297:	ldout(cct, 0) << "bad crc in front " << front_crc << " != exp " << footer.front_crc << dendl;
./msg/Message.cc:298:	ldout(cct, 20) << " ";
./msg/Message.cc:306:	ldout(cct, 0) << "bad crc in middle " << middle_crc << " != exp " << footer.middle_crc << dendl;
./msg/Message.cc:307:	ldout(cct, 20) << " ";
./msg/Message.cc:319:	  ldout(cct, 0) << "bad crc in data " << data_crc << " != exp " << footer.data_crc << dendl;
./msg/Message.cc:320:	  ldout(cct, 20) << " ";
./msg/Message.cc:834:      ldout(cct, 0) << "can't decode unknown message type " << type << " MSG_AUTH=" << CEPH_MSG_AUTH << dendl;
./msg/Message.cc:849:      ldout(cct, 0) << "will not decode message of type " << type
./msg/Message.cc:875:      ldout(cct, ceph::dout::need_dynamic(
./msg/DispatchQueue.cc:41:  ldout(cct,1) << "<== " << m->get_source_inst()
./msg/DispatchQueue.cc:60:  ldout(cct,20) << "done calling dispatch on " << m << dendl;
./msg/DispatchQueue.cc:88:  ldout(cct,20) << "queue " << m << " prio " << priority << dendl;
./msg/DispatchQueue.cc:139:    ldout(cct,10) << __func__ << " " << msize << " to dispatch throttler "
./msg/DispatchQueue.cc:171:	  ldout(cct, 1) << "DispatchQueue::entry  inject delay of " << t
./msg/DispatchQueue.cc:197:	  ldout(cct,10) << " stop flag set, discarding " << m << " " << *m << dendl;
./msg/DispatchQueue.cc:251:    ldout(cct,20) << __func__ << " " << p->first << dendl;
./msg/xio/XioPortal.cc:46:  ldout(msgr->cct,20) << "xio_bind: portal " << xio_uri
./msg/xio/XioPortal.cc:89:    ldout(msgr->cct,5) << "xp::bind: portal " << i << " bind OK: "
./msg/xio/XioConnection.cc:35:    ldout(cct,4) << tag <<
./msg/xio/XioConnection.cc:42:  ldout(cct,4) << tag <<
./msg/xio/XioConnection.cc:60:  ldout(cct,4) << tag <<
./msg/xio/XioConnection.cc:74:    ldout(cct,4) << tag << " header version " << header.version <<
./msg/xio/XioConnection.cc:114:    ldout(m->cct,4) << "XioMessenger throttle_msgs: " << max_msgs << dendl;
./msg/xio/XioConnection.cc:133:    ldout(m->cct,4) << "XioMessenger throttle_bytes: " << max_bytes << dendl;
./msg/xio/XioConnection.cc:146:  ldout(m->cct,4) << "throttle_msgs: " << xopt << " throttle_bytes: " << bytes_opt << dendl;
./msg/xio/XioConnection.cc:209:  ldout(msgr->cct,8) << __func__ << " sending command with tag " << (int)(*(char*)msg->out.header.iov_base)
./msg/xio/XioConnection.cc:275:	ldout(msgr->cct,0) << __func__ << " empty header: packet out of sequence?" << dendl;
./msg/xio/XioConnection.cc:283:    ldout(msgr->cct,10) << __func__ << " receive msg " << "tmsg " << tmsg
./msg/xio/XioConnection.cc:313:  ldout(msgr->cct,4) << __func__ << " " << "msg_seq.size()="  << msg_seq.size() <<
./msg/xio/XioConnection.cc:369:      ldout(msgr->cct,4) << "front (payload) dump:";
./msg/xio/XioConnection.cc:474:      ldout(msgr->cct,4) << "decode m is " << m->get_type() << dendl;
./msg/xio/XioConnection.cc:481:    ldout(msgr->cct,4) << "decode m failed" << dendl;
./msg/xio/XioConnection.cc:497:  ldout(msgr->cct,8) << __func__ << " receive msg with iov_len "
./msg/xio/XioConnection.cc:505:    ldout(msgr->cct, 20) << __func__ << " got data message" << dendl;
./msg/xio/XioConnection.cc:509:    ldout(msgr->cct, 20) << __func__ << " got KEEPALIVE" << dendl;
./msg/xio/XioConnection.cc:521:      ldout(msgr->cct, 20) << __func__ << " got KEEPALIVE2 with timestamp" << kp_t << dendl;
./msg/xio/XioConnection.cc:536:      ldout(msgr->cct, 20) << __func__ << " got KEEPALIVE2_ACK with timestamp" << kp_t << dendl;
./msg/xio/XioConnection.cc:565:  ldout(msgr->cct,11) << "on_msg_delivered xcon: " << xsend->xcon <<
./msg/xio/XioConnection.cc:570:    ldout(msgr->cct,11) << "on_msg_delivered xcon: " <<
./msg/xio/XioConnection.cc:583:      ldout(msgr->cct,2) << "on_msg_delivered xcon: " << xsend->xcon
./msg/xio/XioConnection.cc:595:  ldout(msgr->cct,2) << "xio_send_msg FAILED xcon: " << this <<
./msg/xio/XioConnection.cc:604:  ldout(msgr->cct,2) << "xio_release_msg FAILED xcon: " << this <<
./msg/xio/XioConnection.cc:689:	ldout(msgr->cct,0) << __func__ << ": Unknown Msg type " << xs->type << dendl;
./msg/xio/XioMessenger.cc:83:    ldout(context, lvl.second) << '[' << lvl.first << "] "
./msg/xio/XioMessenger.cc:97:  ldout(cct,4) << "session event: " << xio_session_event_str(event_data->event)
./msg/xio/XioMessenger.cc:110:  ldout(cct,4) << "new session " << session
./msg/xio/XioMessenger.cc:125:  ldout(cct,25) << "on_msg session " << session << " xcon " << xcon << dendl;
./msg/xio/XioMessenger.cc:146:  ldout(cct,25) << "msg delivered session: " << session
./msg/xio/XioMessenger.cc:164:  ldout(cct,4) << "msg error session: " << session
./msg/xio/XioMessenger.cc:180:  ldout(cct,25) << "on cancel: session: " << session << " msg: " << msg
./msg/xio/XioMessenger.cc:194:  ldout(cct,25) << "on cancel request: session: " << session << " msg: " << msg
./msg/xio/XioMessenger.cc:282:       ldout(cct,2) << "setting accelio max header size " << xopt << dendl;
./msg/xio/XioMessenger.cc:379:  ldout(cct,2) << "Create msgr: " << this << " instance: "
./msg/xio/XioMessenger.cc:436:    ldout(cct,2) << "learned my addr " << my_inst.addr << dendl;
./msg/xio/XioMessenger.cc:473:    ldout(cct,2) << "connection established " << event_data->conn
./msg/xio/XioMessenger.cc:483:    ldout(cct,2) << "client: connected from " << peer_addr_for_me << " to " << paddr << dendl;
./msg/xio/XioMessenger.cc:532:    ldout(cct,2) << "New connection session " << session
./msg/xio/XioMessenger.cc:534:    ldout(cct,2) << "Server: connected from " << s_inst.addr << " to " << peer_addr_for_me << dendl;
./msg/xio/XioMessenger.cc:542:    ldout(cct,2) << xio_session_event_str(event_data->event)
./msg/xio/XioMessenger.cc:551:    ldout(cct,2) << xio_session_event_str(event_data->event)
./msg/xio/XioMessenger.cc:561:    ldout(cct,2) << xio_session_event_str(event_data->event)
./msg/xio/XioMessenger.cc:717:  ldout(cct,4) << "XioMessenger " << this << " bind: xio_uri "
./msg/xio/XioMessenger.cc:734:  ldout(cct,4) << "XioMessenger " << this << " rebind attempt" << dendl;
./msg/xio/XioMessenger.cc:846:    ldout(cct,10) << "msg_off 0, ex_cnt " << ex_cnt << " -> " << ex_cnt-1 << dendl;
./msg/xio/XioMessenger.cc:857:  ldout(cct,4) << __func__ << " " << m << " new XioMsg " << xmsg
./msg/xio/XioMessenger.cc:869:      ldout(cct,4) << __func__ << " stop 43 " << m->get_type() << " " << *m << dendl;
./msg/xio/XioMessenger.cc:871:      ldout(cct,4) << __func__ << " payload dump:" << dendl;
./msg/xio/XioMessenger.cc:880:    ldout(cct,4) << "payload: " << payload.buffers().size() <<
./msg/xio/XioMessenger.cc:887:    ldout(cct,4) << __func__ << " buffer cnt > XIO_MSGR_IOVLEN (" <<
./msg/xio/XioMessenger.cc:904:  ldout(cct,10) << "ex_cnt " << ex_cnt << ", req_off " << req_off
./msg/xio/XioMessenger.cc:987:    ldout(cct,4) << "XioMessenger " << this << " get_connection: xio_uri "
./msg/xio/XioMessenger.cc:1033:    ldout(cct,2) << "New connection xcon: " << xcon <<
./client/barrier.cc:28:#define cldout(cl, v)  dout_impl((cl)->cct, dout_subsys, v) \
./client/barrier.cc:57:  cldout(cl, 1) << "C_Block_Sync for " << ino << dendl;
./client/barrier.cc:67:  cldout(cl, 1) << "C_Block_Sync::finish() for " << ino << " "
./client/Client.cc:218:  ldout(cct, 10) << __func__ << " " << ino << " -> " << vino << dendl;
./client/Client.cc:319:    ldout(cct, 1) << __func__ << " forcing close of fh " << it->first << " ino " << fh->inode->ino << dendl;
./client/Client.cc:326:    ldout(cct, 1) << __func__ << " forcing close of dir " << dirp << " ino " << dirp->inode->ino << dendl;
./client/Client.cc:375:  ldout(cct, 1) << "dump_inode: "
./client/Client.cc:393:    ldout(cct, 1) << "  dir " << in->dir << " size " << in->dir->dentries.size() << dendl;
./client/Client.cc:397:      ldout(cct, 1) << "   " << in->ino << " dn " << it->first << " " << it->second << " ref " << it->second->ref << dendl;
./client/Client.cc:413:  ldout(cct, 1) << __func__ << dendl;
./client/Client.cc:438:  ldout(cct, 1) << __func__ << dendl;
./client/Client.cc:538:  ldout(cct, 1) << __func__ << dendl;
./client/Client.cc:556:    ldout(cct, 10) << "shutdown stopping cache invalidator finisher" << dendl;
./client/Client.cc:562:    ldout(cct, 10) << "shutdown stopping dentry invalidator finisher" << dendl;
./client/Client.cc:568:    ldout(cct, 10) << "shutdown stopping interrupt finisher" << dendl;
./client/Client.cc:574:    ldout(cct, 10) << "shutdown stopping remount finisher" << dendl;
./client/Client.cc:603:  ldout(cct, 20) << "trim_cache size " << lru.lru_get_size() << " max " << max << dendl;
./client/Client.cc:623:    ldout(cct, 15) << "trim_cache trimmed root " << root << dendl;
./client/Client.cc:637:  ldout(cct, 20) << __func__ << " mds." << mds << dendl;
./client/Client.cc:657:  ldout(cct, 20) << __func__ << " mds." << mds
./client/Client.cc:666:  ldout(cct, 15) << "trim_dentry unlinking dn " << dn->name 
./client/Client.cc:689:  ldout(cct, 10) << __func__ << " " << *in << " " << ccap_string(issued)
./client/Client.cc:691:  ldout(cct, 25) << "truncate_seq: mds " << truncate_seq <<  " local "
./client/Client.cc:707:    ldout(cct, 10) << "size " << in->size << " -> " << size << dendl;
./client/Client.cc:711:      ldout(cct, 10) << "truncate_seq " << in->truncate_seq << " -> "
./client/Client.cc:732:      ldout(cct, 10) << "truncate_size " << in->truncate_size << " -> "
./client/Client.cc:737:      ldout(cct, 0) << "Hmmm, truncate_seq && truncate_size changed on non-file inode!" << dendl;
./client/Client.cc:747:    ldout(cct, 30) << "Yay have enough caps to look at our times" << dendl;
./client/Client.cc:751:      ldout(cct, 10) << "mds time_warp_seq " << time_warp_seq << " on inode " << *in
./client/Client.cc:768:    ldout(cct, 30) << "Don't have enough caps, just taking mds' time values" << dendl;
./client/Client.cc:777:    ldout(cct, 0) << "WARNING: " << *in << " mds time_warp_seq "
./client/Client.cc:810:    ldout(cct, 12) << __func__ << " had " << *in << " caps " << ccap_string(st->cap.caps) << dendl;
./client/Client.cc:839:    ldout(cct, 12) << __func__ << " adding " << *in << " caps " << ccap_string(st->cap.caps) << dendl;
./client/Client.cc:875:      ldout(cct, 20) << " dir hash is " << (int)in->dir_layout.dl_dir_hash << dendl;
./client/Client.cc:920:    ldout(cct, 10) << " marking (I_COMPLETE|I_DIR_ORDERED) on empty dir " << *in << dendl;
./client/Client.cc:923:      ldout(cct, 10) << " dir is open on empty dir " << in->ino << " with "
./client/Client.cc:951:  ldout(cct, 12) << __func__ << " '" << dname << "' vino " << in->vino()
./client/Client.cc:958:      ldout(cct, 12) << " had dentry " << dname
./client/Client.cc:962:      ldout(cct, 12) << " had dentry " << dname
./client/Client.cc:998:      ldout(cct, 10) << "got dentry lease on " << dn->name
./client/Client.cc:1016:  ldout(cct, 20) << "got dirfrag map for " << in->ino << " frag " << dst->frag << " to mds " << dst->auth << dendl;
./client/Client.cc:1035:      ldout(cct, 9) << "lost dist spec for " << in->ino 
./client/Client.cc:1038:      ldout(cct, 9) << "got dist spec for " << in->ino 
./client/Client.cc:1049:      ldout(cct, 10) << " clearing (I_COMPLETE|I_DIR_ORDERED) on " << *diri << dendl;
./client/Client.cc:1053:	ldout(cct, 10) << " clearing I_DIR_ORDERED on " << *diri << dendl;
./client/Client.cc:1113:      ldout(cct, 10) << "insert_trace got new frag " << fg << " -> " << dst.frag << dendl;
./client/Client.cc:1122:    ldout(cct, 10) << __func__ << " " << numdn << " readdir items, end=" << end
./client/Client.cc:1149:      ldout(cct, 15) << "" << i << ": '" << dname << "'" << dendl;
./client/Client.cc:1203:      ldout(cct, 15) << __func__ << "  " << hex << dn->offset << dec << ": '" << dname << "' -> " << in->ino << dendl;
./client/Client.cc:1227:  ldout(cct, 10) << "insert_trace from " << request->sent_stamp << " mds." << session->mds_num
./client/Client.cc:1234:    ldout(cct, 10) << "insert_trace -- already got unsafe; ignoring" << dendl;
./client/Client.cc:1240:    ldout(cct, 10) << "insert_trace -- no trace" << dendl;
./client/Client.cc:1253:	ldout(cct, 10) << " unlinking rename src dn " << od << " for traceless reply" << dendl;
./client/Client.cc:1259:	ldout(cct, 10) << " unlinking unlink/rmdir dn " << d << " for traceless reply" << dendl;
./client/Client.cc:1268:  ldout(cct, 10) << " features 0x" << hex << features << dec << dendl;
./client/Client.cc:1275:  ldout(cct, 10) << " hrm " 
./client/Client.cc:1342:    ldout(cct, 10) << " faking snap lookup weirdness" << dendl;
./client/Client.cc:1402:    ldout(cct, 10) << __func__ << " resend_mds specified as mds." << mds << dendl;
./client/Client.cc:1412:    ldout(cct, 20) << __func__ << " starting with req->inode " << *in << dendl;
./client/Client.cc:1415:      ldout(cct, 20) << __func__ << " inode dir hash is " << (int)in->dir_layout.dl_dir_hash
./client/Client.cc:1423:      ldout(cct, 20) << __func__ << " starting with req->dentry inode " << *in << dendl;
./client/Client.cc:1427:      ldout(cct, 20) << __func__ << " dentry dir hash is " << (int)in->dir_layout.dl_dir_hash
./client/Client.cc:1435:      ldout(cct, 10) << __func__ << " " << *in << " is snapped, using nonsnap parent" << dendl;
./client/Client.cc:1445:          ldout(cct, 10) << "got unlinked inode, can't look at parent" << dendl;
./client/Client.cc:1452:    ldout(cct, 20) << __func__ << " " << *in << " is_hash=" << is_hash
./client/Client.cc:1461:	ldout(cct, 10) << __func__ << " from dirfragtree hash" << dendl;
./client/Client.cc:1473:    ldout(cct, 10) << __func__ << " from caps on inode " << *in << dendl;
./client/Client.cc:1481:    ldout(cct, 10) << "did not get mds through better means, so chose random mds " << mds << dendl;
./client/Client.cc:1485:  ldout(cct, 20) << "mds is " << mds << dendl;
./client/Client.cc:1492:  ldout(cct, 10) << __func__ << " for mds." << mds << dendl;
./client/Client.cc:1500:      ldout(cct, 10) << "check_mds_sessions opening mds." << mds
./client/Client.cc:1548:    ldout(cct, 10) << "make_request created ino " << created_ino << dendl;
./client/Client.cc:1556:    ldout(cct, 20) << "make_request target is " << *ptarget->get() << dendl;
./client/Client.cc:1560:      ldout(cct, 20) << "make_request created, target is " << *ptarget->get() << dendl;
./client/Client.cc:1569:	  ldout(cct, 10) << "make_request got traceless reply, looking up #"
./client/Client.cc:1582:	ldout(cct, 10) << "make_request got traceless reply, forcing getattr on #"
./client/Client.cc:1591:	  ldout(cct, 5) << "create got ino " << created_ino << " but then failed on lookup; EINTR?" << dendl;
./client/Client.cc:1646:    ldout(cct, 20) << __func__ << " injecting fixed oldest_client_tid(1)" << dendl;
./client/Client.cc:1676:	  ldout(cct, 10) << " target mds." << mds << " has stopped, remove it from fragmap" << dendl;
./client/Client.cc:1679:	  ldout(cct, 10) << " target mds." << mds << " has stopped, trying a random mds" << dendl;
./client/Client.cc:1683:	ldout(cct, 10) << " target mds." << mds << " not active, waiting for new mdsmap" << dendl;
./client/Client.cc:1696:	ldout(cct, 10) << "waiting for session to mds." << mds << " to open" << dendl;
./client/Client.cc:1716:    ldout(cct, 20) << "awaiting reply|forward|kick on " << &caller_cond << dendl;
./client/Client.cc:1749:  ldout(cct, 20) << "sendrecv kickback on tid " << tid << " " << request->dispatch_cond << dendl;
./client/Client.cc:1761:  ldout(cct, 20) << "lat " << lat << dendl;
./client/Client.cc:1814:  ldout(cct, 20) << __func__ << " enter(in:" << *in << ", req:" << req
./client/Client.cc:1824:      ldout(cct, 25) << "Dropping caps. Initial " << ccap_string(cap.issued) << dendl;
./client/Client.cc:1828:      ldout(cct, 25) << "Now have: " << ccap_string(cap.issued) << dendl;
./client/Client.cc:1846:  ldout(cct, 25) << __func__ << " exit(in:" << *in << ") released:"
./client/Client.cc:1854:  ldout(cct, 20) << __func__ << " enter(dn:"
./client/Client.cc:1861:    ldout(cct, 25) << "preemptively releasing dn to mds" << dendl;
./client/Client.cc:1867:  ldout(cct, 25) << __func__ << " exit(dn:"
./client/Client.cc:1880:  ldout(cct, 20) << __func__ << " enter (req: "
./client/Client.cc:1905:  ldout(cct, 25) << __func__ << " exit (req: "
./client/Client.cc:1944:    ldout(cct, 20) << __func__ << " read hostname '" << u.nodename << "'" << dendl;
./client/Client.cc:1946:    ldout(cct, 1) << __func__ << " failed to read hostname (" << cpp_strerror(r) << ")" << dendl;
./client/Client.cc:1986:    ldout(cct, 1) << __func__ << " warning, overriding metadata field '" << k
./client/Client.cc:1995:  ldout(cct, 10) << __func__ << " mds." << mds << dendl;
./client/Client.cc:2007:      ldout(cct, 4) << __func__ << " mds." << mds << " skipping "
./client/Client.cc:2011:      ldout(cct, 4) << __func__ << " mds." << mds << " old inst "
./client/Client.cc:2025:  ldout(cct, 2) << __func__ << " mds." << s->mds_num << " seq " << s->seq << dendl;
./client/Client.cc:2032:  ldout(cct, 5) << __func__ << " mds." << s->mds_num << " seq " << s->seq << dendl;
./client/Client.cc:2045:  ldout(cct, 10) << __func__ << " " << *m << " from mds." << from << dendl;
./client/Client.cc:2049:    ldout(cct, 10) << " discarding session message from sessionless mds " << m->get_source_inst() << dendl;
./client/Client.cc:2125:  ldout(cct, 1) << __func__ << dendl;
./client/Client.cc:2140:  ldout(cct, 10) << __func__ << " rebuilding request " << request->get_tid()
./client/Client.cc:2166:    ldout(cct, 20) << __func__ << " set sent_stamp to " << request->sent_stamp << dendl;
./client/Client.cc:2180:  ldout(cct, 10) << __func__ << " " << *r << " to mds." << mds << dendl;
./client/Client.cc:2204:      else ldout(cct, 1) << "Warning -- unable to construct a filepath!"
./client/Client.cc:2207:    } else ldout(cct, 1) << "Warning -- unable to construct a filepath!"
./client/Client.cc:2235:    ldout(cct, 10) << __func__ << " no pending request on tid " << tid << dendl;
./client/Client.cc:2248:  ldout(cct, 10) << __func__ << " tid " << tid
./client/Client.cc:2294:  ldout(cct, 20) << __func__ << " got a reply. Safe:" << is_safe
./client/Client.cc:2299:    ldout(cct, 0) << "got a duplicate reply on tid " << tid << " from mds "
./client/Client.cc:2306:    ldout(cct, 20) << "got ESTALE on tid " << request->tid
./client/Client.cc:2317:      ldout(cct, 20) << "have to return ESTALE" << dendl;
./client/Client.cc:2351:    ldout(cct, 20) << __func__ << " signalling caller " << (void*)request->caller_cond << dendl;
./client/Client.cc:2356:      ldout(cct, 20) << __func__ << " awaiting kickback on tid " << tid << " " << &cond << dendl;
./client/Client.cc:2379:  ldout(cct, 1) << __func__ << ": FULL: cancelling outstanding operations "
./client/Client.cc:2404:      ldout(cct, 4) << __func__ << ": FULL: inode 0x" << std::hex << i->first << std::dec
./client/Client.cc:2503:    ldout(cct, 10) << "inactive, discarding " << *m << dendl;
./client/Client.cc:2561:    ldout(cct, 10) << "unmounting: trim pass, size was " << lru.lru_get_size() 
./client/Client.cc:2566:      ldout(cct, 10) << "unmounting: trim pass, cache shrank, poking unmount()" << dendl;
./client/Client.cc:2569:      ldout(cct, 10) << "unmounting: trim pass, size still " << lru.lru_get_size() 
./client/Client.cc:2600:    ldout(cct, 1) << __func__ << " epoch " << m->get_epoch()
./client/Client.cc:2607:  ldout(cct, 1) << __func__ << " epoch " << m->get_epoch() << dendl;
./client/Client.cc:2621:      ldout(cct, 1) << __func__ << ": cancelling command op " << i.first << dendl;
./client/Client.cc:2691:  ldout(cct, 10) << __func__ << " to mds." << mds << dendl;
./client/Client.cc:2718:      ldout(cct, 10) << " caps on " << p->first
./client/Client.cc:2724:      ldout(cct, 10) << "    path " << path << dendl;
./client/Client.cc:2748:	ldout(cct, 10) << " snaprealm " << *in->snaprealm << dendl;
./client/Client.cc:2765:  ldout(cct, 10) << __func__ << " for mds." << session->mds_num << dendl;
./client/Client.cc:2835:  ldout(cct, 10) << __func__ << " for mds." << session->mds_num << dendl;
./client/Client.cc:2870:  ldout(cct, 10) << " mds." << s->mds_num << " seq now " << s->seq << dendl;
./client/Client.cc:2878:  ldout(cct, 10) << __func__ << " " << *m << dendl;
./client/Client.cc:2896:    ldout(cct, 10) << " don't have vino " << vino << dendl;
./client/Client.cc:2903:      ldout(cct, 10) << " don't have dir|dentry " << m->get_ino() << "/" << m->dname <<dendl;
./client/Client.cc:2907:    ldout(cct, 10) << " revoked DN lease on " << dn << dendl;
./client/Client.cc:2921:  ldout(cct, 10) << __func__ << " on " << *in << dendl;
./client/Client.cc:2927:    ldout(cct, 10) << __func__ << " deleting " << *in << dendl;
./client/Client.cc:2948:  ldout(cct, 15) << __func__ << " dir " << dir << " on " << in << dendl;
./client/Client.cc:2973:    ldout(cct, 15) << "link dir " << dir->parent_inode << " '" << name << "' to inode " << in
./client/Client.cc:2977:    ldout(cct, 15) << "link dir " << dir->parent_inode << " '" << name << "' to inode " << in
./client/Client.cc:2993:    ldout(cct, 20) << "link  inode " << in << " parents now " << in->dentries << dendl;
./client/Client.cc:3002:  ldout(cct, 15) << "unlink dir " << dn->dir->parent_inode << " '" << dn->name << "' dn " << dn
./client/Client.cc:3008:    ldout(cct, 20) << "unlink  inode " << in << " parents now " << in->dentries << dendl;
./client/Client.cc:3014:    ldout(cct, 15) << "unlink  removing '" << dn->name << "' dn " << dn << dendl;
./client/Client.cc:3042:      client_t const whoami = client->whoami;  // For the benefit of ldout prefix
./client/Client.cc:3043:      ldout(client->cct, 1) << "I/O error from flush on inode " << inode
./client/Client.cc:3060:    ldout(cct, 5) << __func__ << " got first FILE_BUFFER ref on " << *in << dendl;
./client/Client.cc:3065:    ldout(cct, 5) << __func__ << " got first FILE_CACHE ref on " << *in << dendl;
./client/Client.cc:3081:	ldout(cct, 10) << __func__ << " finishing pending cap_snap on " << *in << dendl;
./client/Client.cc:3090:	ldout(cct, 5) << __func__ << " dropped last FILE_BUFFER ref on " << *in << dendl;
./client/Client.cc:3095:      ldout(cct, 5) << __func__ << " dropped last FILE_CACHE ref on " << *in << dendl;
./client/Client.cc:3114:      ldout(cct, 10) << "get_caps " << *in << " need " << ccap_string(need)
./client/Client.cc:3131:	ldout(cct, 10) << "wanted_max_size " << in->wanted_max_size << " -> " << endoff << dendl;
./client/Client.cc:3137:	ldout(cct, 10) << "waiting on max_size, endoff " << endoff << " max_size " << in->max_size << " on " << *in << dendl;
./client/Client.cc:3142:	  ldout(cct, 10) << "waiting on cap_snap write to complete" << dendl;
./client/Client.cc:3153:	  ldout(cct, 10) << "waiting for WRBUFFER to get dropped" << dendl;
./client/Client.cc:3161:	ldout(cct, 10) << "get_caps " << *in << " have " << ccap_string(have)
./client/Client.cc:3171:      ldout(cct, 10) << "waiting for caps " << *in << " need " << ccap_string(need) << " want " << ccap_string(want) << dendl;
./client/Client.cc:3211:  ldout(cct, 10) << __func__ << " on " << *in << dendl;
./client/Client.cc:3227:  ldout(cct, 10) << __func__ << " " << *in
./client/Client.cc:3245:    ldout(cct, 20) << __func__ << " injecting failure to release caps" << dendl;
./client/Client.cc:3255:    ldout(cct, 20) << __func__ << " issued " << ccap_string(cap->issued) << " vs " << ccap_string(would_have_issued) << dendl;
./client/Client.cc:3256:    ldout(cct, 20) << __func__ << " implemented " << ccap_string(cap->implemented) << " vs " << ccap_string(would_have_implemented) << dendl;
./client/Client.cc:3320:    ldout(cct, 15) << "auth cap, setting max_size = " << in->requested_max_size << dendl;
./client/Client.cc:3377:  ldout(cct, 10) << __func__ << " on " << *in
./client/Client.cc:3412:    ldout(cct, 10) << " cap mds." << mds
./client/Client.cc:3426:      ldout(cct, 10) << "size " << in->size << " approaching max_size " << in->max_size
./client/Client.cc:3433:      ldout(cct, 10) << "completed revocation of " << ccap_string(cap.implemented & ~cap.issued) << dendl;
./client/Client.cc:3450:      ldout(cct, 10) << "delaying cap release" << dendl;
./client/Client.cc:3460:      ldout(cct, 20) << " reflushing caps (check_caps) on " << *in
./client/Client.cc:3488:  ldout(cct, 10) << __func__ << " " << *in << " snapc " << old_snapc << " used " << ccap_string(used) << dendl;
./client/Client.cc:3492:    ldout(cct, 10) << __func__ << " already have pending cap_snap on " << *in << dendl;
./client/Client.cc:3516:      ldout(cct, 10) << __func__ << " WR used on " << *in << dendl;
./client/Client.cc:3522:    ldout(cct, 10) << __func__ << " not dirty|writing on " << *in << dendl;
./client/Client.cc:3528:  ldout(cct, 10) << __func__ << " " << *in << " capsnap " << (void *)&capsnap << " used " << ccap_string(used) << dendl;
./client/Client.cc:3549:    ldout(cct, 10) << __func__ << " " << *in << " cap_snap " << &capsnap << " used " << used
./client/Client.cc:3559:  ldout(cct, 10) << __func__ << " seq " << seq << " on " << *in << dendl;
./client/Client.cc:3566:  ldout(cct, 10) << "flush_snaps on " << *in << " all_again " << all_again << dendl;
./client/Client.cc:3582:    ldout(cct, 10) << "flush_snaps mds." << session->mds_num
./client/Client.cc:3709:  ldout(cct, 10) << __func__ << " " << ino << " " << off << "~" << len << dendl;
./client/Client.cc:3722:  ldout(cct, 10) << __func__ << " " << *in << dendl;
./client/Client.cc:3736:  ldout(cct, 10) << __func__ << " " << *in << " " << off << "~" << len << dendl;
./client/Client.cc:3750:  ldout(cct, 20) << "_release " << *in << dendl;
./client/Client.cc:3760:  ldout(cct, 10) << "_flush " << *in << dendl;
./client/Client.cc:3763:    ldout(cct, 10) << " nothing to flush" << dendl;
./client/Client.cc:3769:    ldout(cct, 1) << __func__ << ": FULL, purging for ENOSPC" << dendl;
./client/Client.cc:3784:    ldout(cct, 10) << " nothing to flush" << dendl;
./client/Client.cc:3810:  ldout(cct, 10) << "_flushed " << *in << dendl;
./client/Client.cc:3843:    ldout(cct, 15) << __func__ << " first one, opened snaprealm " << in->snaprealm << dendl;
./client/Client.cc:3885:	ldout(cct, 10) << __func__ << " changing auth cap: "
./client/Client.cc:3902:  ldout(cct, 10) << __func__ << " issued " << ccap_string(old_caps) << " -> " << ccap_string(cap.issued)
./client/Client.cc:3929:  ldout(cct, 10) << __func__ << " mds." << mds << " on " << *in << dendl;
./client/Client.cc:3942:      ldout(cct, 10) << " removing myself from flushing_cap list" << dendl;
./client/Client.cc:3952:    ldout(cct, 15) << __func__ << " last one, closing snaprealm " << in->snaprealm << dendl;
./client/Client.cc:3967:  ldout(cct, 10) << __func__ << " mds." << s->mds_num << dendl;
./client/Client.cc:4087:  ldout(cct, 10) << __func__ << " mds." << mds << " max " << max 
./client/Client.cc:4106:	ldout(cct, 20) << " removing unused, unneeded non-auth cap on " << *in << dendl;
./client/Client.cc:4112:      ldout(cct, 20) << " trying to trim dentries for " << *in << dendl;
./client/Client.cc:4127:          ldout(cct, 20) << " anchoring inode: " << in->ino << dendl;
./client/Client.cc:4131:          ldout(cct, 20) << "  not expirable: " << dn->name << dendl;
./client/Client.cc:4136:        ldout(cct, 20) << __func__ << " counting as trimmed: " << *in << dendl;
./client/Client.cc:4141:  ldout(cct, 20) << " clearing anchored inodes" << dendl;
./client/Client.cc:4170:    ldout(cct, 10) << __func__ << " " << ccap_string(flushing) << " " << *in << dendl;
./client/Client.cc:4173:    ldout(cct, 10) << __func__ << " (more) " << ccap_string(flushing) << " " << *in << dendl;
./client/Client.cc:4212:  ldout(cct, 10) << __func__ << dendl;
./client/Client.cc:4240:  ldout(cct, 10) << __func__ << " " << in << " mds." << session->mds_num << dendl;
./client/Client.cc:4267:    ldout(cct, 10) << __func__ << " on " << *in << " flushing "
./client/Client.cc:4277:  ldout(cct, 10) << __func__ << " want " << want  << " (last is " << last_flush_tid << ", "
./client/Client.cc:4285:      ldout(cct, 10) << " waiting on mds." << p.first << " tid " << oldest_tid
./client/Client.cc:4296:  ldout(cct, 10) << __func__ << " mds." << mds << dendl;
./client/Client.cc:4302:    ldout(cct, 20) << " reflushing caps on " << *in << " to mds." << mds << dendl;
./client/Client.cc:4326:    ldout(cct, 20) << " reflushing caps (early_kick) on " << *in
./client/Client.cc:4390:    ldout(cct, 10) << __func__ << " " << *realm << dendl;
./client/Client.cc:4405:  ldout(cct, 20) << __func__ << " " << r << " " << realm << " " << realm->nref << " -> " << (realm->nref + 1) << dendl;
./client/Client.cc:4413:    ldout(cct, 20) << __func__ << " " << r << " fail" << dendl;
./client/Client.cc:4417:  ldout(cct, 20) << __func__ << " " << r << " " << realm << " " << realm->nref << " -> " << (realm->nref + 1) << dendl;
./client/Client.cc:4424:  ldout(cct, 20) << __func__ << " " << realm->ino << " " << realm
./client/Client.cc:4439:    ldout(cct, 10) << __func__ << " " << *realm
./client/Client.cc:4463:  ldout(cct, 10) << __func__ << " len " << bl.length() << dendl;
./client/Client.cc:4476:      ldout(cct, 10) << __func__ << " " << *realm << " seq " << info.seq() << " > " << realm->seq
./client/Client.cc:4515:      ldout(cct, 15) << __func__ << " " << *realm << " self|parent updated" << dendl;
./client/Client.cc:4516:      ldout(cct, 15) << "  snapc " << realm->get_snap_context() << dendl;
./client/Client.cc:4518:      ldout(cct, 10) << __func__ << " " << *realm << " seq " << info.seq()
./client/Client.cc:4534:      ldout(cct, 10) << " flushing caps on " << *realm << dendl;
./client/Client.cc:4542:      ldout(cct, 10) << " no new snap on " << *realm << dendl;
./client/Client.cc:4555:  ldout(cct, 10) << __func__ << " " << *m << dendl;
./client/Client.cc:4577:    ldout(cct, 10) << " splitting off " << *realm << dendl;
./client/Client.cc:4587:	  ldout(cct, 10) << " NOT moving " << *in << " from _newer_ realm " 
./client/Client.cc:4591:	ldout(cct, 10) << " moving " << *in << " from " << *in->snaprealm << dendl;
./client/Client.cc:4604:      ldout(cct, 10) << "adjusting snaprealm " << *p << " parent" << dendl;
./client/Client.cc:4642:  ldout(cct, 10) << __func__ << " " << *m << " from mds." << mds << dendl;
./client/Client.cc:4687:      ldout(cct, 5) << __func__ << " don't have vino " << vino << " on IMPORT, immediately releasing" << dendl;
./client/Client.cc:4695:      ldout(cct, 5) << __func__ << " don't have vino " << vino << ", dropping" << dendl;
./client/Client.cc:4714:    ldout(cct, 5) << __func__ << " don't have " << *in << " cap on mds." << mds << dendl;
./client/Client.cc:4736:  ldout(cct, 5) << __func__ << " ino " << m->get_ino() << " mseq " << m->get_mseq()
./client/Client.cc:4776:  ldout(cct, 5) << __func__ << " ino " << m->get_ino() << " mseq " << m->get_mseq()
./client/Client.cc:4826:  ldout(cct, 10) << __func__ << " on ino " << *in
./client/Client.cc:4849:       ldout(cct, 0) << __func__ << " mds." << session->mds_num
./client/Client.cc:4868:  ldout(cct, 5) << __func__ << " mds." << session->mds_num
./client/Client.cc:4885:    ldout(cct, 10) << " tid " << m->get_client_tid() << " != any cap bit tids" << dendl;
./client/Client.cc:4888:      ldout(cct, 5) << "  flushing_caps " << ccap_string(in->flushing_caps)
./client/Client.cc:4892:	ldout(cct, 10) << " " << *in << " !flushing" << dendl;
./client/Client.cc:4915:      ldout(cct, 10) << " tid " << m->get_client_tid() << " != " << capsnap.flush_tid << dendl;
./client/Client.cc:4917:      ldout(cct, 5) << __func__ << " mds." << mds << " flushed snap follows " << follows
./client/Client.cc:4928:    ldout(cct, 5) << __func__ << " DUP(?) mds." << mds << " flushed snap follows " << follows
./client/Client.cc:4968:  ldout(cct, 10) << __func__ << " '" << name << "' ino " << ino
./client/Client.cc:5031:  ldout(cct, 5) << __func__ << " on in " << m->get_ino() 
./client/Client.cc:5079:    ldout(cct, 10) << "max_size " << in->max_size << " -> " << m->get_max_size() << dendl;
./client/Client.cc:5096:    ldout(cct, 10) << "  revocation of " << ccap_string(revoked) << dendl;
./client/Client.cc:5118:    ldout(cct, 10) << "  caps unchanged at " << ccap_string(old_caps) << dendl;
./client/Client.cc:5120:    ldout(cct, 10) << "  grant, new caps are " << ccap_string(new_caps & ~old_caps) << dendl;
./client/Client.cc:5183:  ldout(cct, 3) << __func__ << " " << in << " = " << r <<  dendl;
./client/Client.cc:5195:  ldout(cct, 20) << __func__ << " " << *in << "; " << perms << dendl;
./client/Client.cc:5245:  ldout(cct, 3) << __func__ << " " << in << " = " << r <<  dendl;
./client/Client.cc:5251:  ldout(cct, 20) << __func__ << " " << *in << "; " << perms << dendl;
./client/Client.cc:5282:  ldout(cct, 3) << __func__ << " " << in << " = " << r <<  dendl;
./client/Client.cc:5288:  ldout(cct, 20) << __func__ << " " << *dir << "; " << perms << dendl;
./client/Client.cc:5295:  ldout(cct, 3) << __func__ << " " << dir << " = " << r <<  dendl;
./client/Client.cc:5301:  ldout(cct, 20) << __func__ << " " << *dir << "; " << perms << dendl;
./client/Client.cc:5308:  ldout(cct, 3) << __func__ << " " << dir << " = " << r <<  dendl;
./client/Client.cc:5314:  ldout(cct, 20) << __func__ << " " << *dir << "; " << "; name " << name << "; " << perms << dendl;
./client/Client.cc:5333:  ldout(cct, 3) << __func__ << " " << dir << " = " << r <<  dendl;
./client/Client.cc:5339:  ldout(cct, 20) << __func__ << " " << *in << "; " << perms << dendl;
./client/Client.cc:5361:  ldout(cct, 3) << __func__ << " " << in << " = " << r <<  dendl;
./client/Client.cc:5403:    ldout(cct, 10) << __func__ << ": resolved '" << mds_spec << "' to role '"
./client/Client.cc:5416:      ldout(cct, 10) << __func__ << ": validated GID " << mds_gid << dendl;
./client/Client.cc:5445:      ldout(cct, 10) << __func__ << ": resolved ID '" << mds_spec
./client/Client.cc:5499:  ldout(cct, 10) << __func__ << " learned FSMap version " << fsmap_latest << dendl;
./client/Client.cc:5518:  ldout(cct, 10) << __func__ << " finished waiting for FSMap version "
./client/Client.cc:5599:    ldout(cct, 4) << __func__ << ": new command op to " << target_gid
./client/Client.cc:5615:  ldout(cct, 10) << __func__ << ": tid=" << m->get_tid() << dendl;
./client/Client.cc:5618:    ldout(cct, 1) << __func__ << ": unknown tid " << tid << ", dropping" << dendl;
./client/Client.cc:5649:    ldout(cct, 5) << "already mounted" << dendl;
./client/Client.cc:5675:  ldout(cct, 10) << "Subscribing to map '" << want << "'" << dendl;
./client/Client.cc:5687:        ldout(cct, 10) << "mds cluster unavailable: epoch=" << mdsmap->get_epoch() << dendl;
./client/Client.cc:5716:	ldout(cct, 1) << __func__ << " EACCES on parent of mount point; quotas may not work" << dendl;
./client/Client.cc:5737:      ldout(cct, 1) << "opened trace file '" << cct->_conf->client_trace << "'" << dendl;
./client/Client.cc:5739:      ldout(cct, 1) << "FAILED to open trace file '" << cct->_conf->client_trace << "'" << dendl;
./client/Client.cc:5744:  ldout(cct, 3) << "op: // client trace data structs" << dendl;
./client/Client.cc:5745:  ldout(cct, 3) << "op: struct stat st;" << dendl;
./client/Client.cc:5746:  ldout(cct, 3) << "op: struct utimbuf utim;" << dendl;
./client/Client.cc:5747:  ldout(cct, 3) << "op: int readlinkbuf_len = 1000;" << dendl;
./client/Client.cc:5748:  ldout(cct, 3) << "op: char readlinkbuf[readlinkbuf_len];" << dendl;
./client/Client.cc:5749:  ldout(cct, 3) << "op: map<string, inode_t*> dir_contents;" << dendl;
./client/Client.cc:5750:  ldout(cct, 3) << "op: map<int, int> open_files;" << dendl;
./client/Client.cc:5751:  ldout(cct, 3) << "op: int fd;" << dendl;
./client/Client.cc:5769:    ldout(cct, 2) << "waiting for " << mds_sessions.size() << " mds sessions to close" << dendl;
./client/Client.cc:5800:  ldout(cct, 2) << "unmounting" << dendl;
./client/Client.cc:5807:    ldout(cct, 10) << "waiting on " << mds_requests.size() << " requests" << dendl;
./client/Client.cc:5821:    ldout(cct, 0) << " destroyed lost open file " << fh << " on " << *fh->inode << dendl;
./client/Client.cc:5829:    ldout(cct, 0) << " destroyed lost open file " << fh << " on " << *(fh->inode) << dendl;
./client/Client.cc:5835:    ldout(cct, 0) << " destroyed lost open dir " << dirp << " on " << *dirp->inode << dendl;
./client/Client.cc:5842:    ldout(cct, 0) << " skipping clean shutdown, we are blacklisted" << dendl;
./client/Client.cc:5859:    ldout(cct, 0) << unsafe_sync_write << " unsafe_sync_writes, waiting"  << dendl;
./client/Client.cc:5873:	ldout(cct, 0) << "null inode_map entry ino " << p->first << dendl;
./client/Client.cc:5892:    ldout(cct, 2) << "cache still has " << lru.lru_get_size()
./client/Client.cc:5907:    ldout(cct, 1) << "closing trace file '" << cct->_conf->client_trace << "'" << dendl;
./client/Client.cc:5915:  ldout(cct, 2) << "unmounted." << dendl;
./client/Client.cc:5932:        ldout(cct, 20) << __func__ << " injecting failure to send cap release message" << dendl;
./client/Client.cc:5949:  ldout(cct, 21) << "tick" << dendl;
./client/Client.cc:5999:  ldout(cct, 10) << "renew_caps()" << dendl;
./client/Client.cc:6003:    ldout(cct, 15) << "renew_caps requesting from mds." << p.first << dendl;
./client/Client.cc:6011:  ldout(cct, 10) << "renew_caps mds." << session->mds_num << dendl;
./client/Client.cc:6035:  ldout(cct, 10) << __func__ << " on " << path << dendl;
./client/Client.cc:6038:  ldout(cct, 10) << __func__ << " res is " << r << dendl;
./client/Client.cc:6061:	ldout(cct, 3) << __func__ << " found target " << (*target)->ino << dendl;
./client/Client.cc:6096:    ldout(cct, 20) << __func__ << " have dn " << dname << " mds." << dn->lease_mds << " ttl " << dn->lease_ttl
./client/Client.cc:6114:	ldout(cct, 20) << " bad lease, cap_ttl " << s.cap_ttl << ", cap_gen " << s.cap_gen
./client/Client.cc:6123:	  ldout(cct, 10) << __func__ << " concluded ENOENT locally for "
./client/Client.cc:6129:      ldout(cct, 20) << " no cap on " << dn->inode->vino() << dendl;
./client/Client.cc:6135:      ldout(cct, 10) << __func__ << " concluded ENOENT locally for " << *dir << " dn '" << dname << "'" << dendl;
./client/Client.cc:6153:    ldout(cct, 10) << __func__ << " " << *dir << " " << dname << " = " << r << dendl;
./client/Client.cc:6155:    ldout(cct, 10) << __func__ << " " << *dir << " " << dname << " = " << **target << dendl;
./client/Client.cc:6163:  ldout(cct, 20) << __func__ << " " << *dir << " name " << name << dendl;
./client/Client.cc:6202:  ldout(cct, 10) << __func__ << " " << path << dendl;
./client/Client.cc:6210:    ldout(cct, 10) << " " << i << " " << *cur << " " << dname << dendl;
./client/Client.cc:6211:    ldout(cct, 20) << "  (path is " << path << ")" << dendl;
./client/Client.cc:6230:      ldout(cct, 20) << " symlink count " << symlinks << ", value is '" << next->symlink << "'" << dendl;
./client/Client.cc:6395:  ldout(cct, 10) << __func__ << ": " << relpath << dendl;
./client/Client.cc:6421:  ldout(cct, 10) << "Client::mkdirs " << relpath << dendl;
./client/Client.cc:6450:  ldout(cct, 20) << __func__ << " got through " << i << " directories on path " << relpath << dendl;
./client/Client.cc:6469:    ldout(cct, 20) << __func__ << ": successfully created directory "
./client/Client.cc:6599:  ldout(cct, 10) << __func__ << " mask " << ccap_string(mask) << " issued=" << yes << dendl;
./client/Client.cc:6611:  ldout(cct, 10) << __func__ << " result=" << res << dendl;
./client/Client.cc:6620:  ldout(cct, 10) << __func__ << " mask " << mask << " issued " <<
./client/Client.cc:6636:    ldout(cct, 10) << __func__ << " caller " << perms.uid() << ":" << perms.gid()
./client/Client.cc:6684:      ldout(cct,10) << "changing uid to " << stx->stx_uid << dendl;
./client/Client.cc:6694:      ldout(cct,10) << "changing gid to " << stx->stx_gid << dendl;
./client/Client.cc:6704:      ldout(cct,10) << "changing mode to " << stx->stx_mode << dendl;
./client/Client.cc:6718:      ldout(cct,10) << "changing btime to " << in->btime << dendl;
./client/Client.cc:6759:    ldout(cct,10) << "changing mode to " << stx->stx_mode << dendl;
./client/Client.cc:6764:    ldout(cct,10) << "changing uid to " << stx->stx_uid << dendl;
./client/Client.cc:6769:    ldout(cct,10) << "changing gid to " << stx->stx_gid << dendl;
./client/Client.cc:6788:      ldout(cct,10) << "changing size to " << stx->stx_size << dendl;
./client/Client.cc:6791:      ldout(cct,10) << "unable to set size to " << stx->stx_size << ". Too large!" << dendl;
./client/Client.cc:6802:  ldout(cct, 10) << "_setattr result=" << res << dendl;
./client/Client.cc:6947:  ldout(cct, 3) << __func__ << " enter (relpath " << relpath << " mask " << mask << ")" << dendl;
./client/Client.cc:6962:    ldout(cct, 3) << __func__ << " exit on error!" << dendl;
./client/Client.cc:6966:  ldout(cct, 3) << __func__ << " exit (relpath " << relpath << " mask " << mask << ")" << dendl;
./client/Client.cc:6996:  ldout(cct, 3) << __func__ << " enter (relpath " << relpath << " want " << want << ")" << dendl;
./client/Client.cc:7015:    ldout(cct, 3) << __func__ << " exit on error!" << dendl;
./client/Client.cc:7020:  ldout(cct, 3) << __func__ << " exit (relpath " << relpath << " mask " << stx->stx_mask << ")" << dendl;
./client/Client.cc:7027:  ldout(cct, 3) << __func__ << " enter (relpath " << relpath << " mask " << mask << ")" << dendl;
./client/Client.cc:7043:    ldout(cct, 3) << __func__ << " exit on error!" << dendl;
./client/Client.cc:7047:  ldout(cct, 3) << __func__ << " exit (relpath " << relpath << " mask " << mask << ")" << dendl;
./client/Client.cc:7053:  ldout(cct, 10) << __func__ << " on " << in->ino << " snap/dev" << in->snapid
./client/Client.cc:7115:  ldout(cct, 10) << __func__ << " on " << in->ino << " snap/dev" << in->snapid
./client/Client.cc:7442:  ldout(cct, 3) << __func__ << "(" << in->ino << ") = " << 0 << " (" << *dirpp << ")" << dendl;
./client/Client.cc:7453:  ldout(cct, 3) << __func__ << "(" << dir << ") = 0" << dendl;
./client/Client.cc:7460:  ldout(cct, 10) << __func__ << "(" << dirp << ")" << dendl;
./client/Client.cc:7462:    ldout(cct, 10) << __func__ << " detaching inode " << dirp->inode << dendl;
./client/Client.cc:7473:  ldout(cct, 3) << __func__ << "(" << dirp << ")" << dendl;
./client/Client.cc:7486:  ldout(cct, 3) << __func__ << "(" << dirp << ") = " << d->offset << dendl;
./client/Client.cc:7494:  ldout(cct, 3) << __func__ << "(" << dirp << ", " << offset << ")" << dendl;
./client/Client.cc:7543:  ldout(cct, 10) << __func__ << " '" << de->d_name << "' -> " << inodeno_t(de->d_ino)
./client/Client.cc:7553:    ldout(cct, 10) << __func__ << " advance from " << fg << " to END" << dendl;
./client/Client.cc:7560:  ldout(cct, 10) << __func__ << " advance from " << dirp->buffer_frag << " to " << fg << dendl;
./client/Client.cc:7584:    ldout(cct, 10) << __func__ << " frag " << cur << " maps to " << fg << dendl;
./client/Client.cc:7593:  ldout(cct, 10) << __func__ << " " << dirp << dendl;
./client/Client.cc:7609:  ldout(cct, 10) << __func__ << " " << dirp << " on " << dirp->inode->ino << " fg " << fg
./client/Client.cc:7636:    ldout(cct, 10) << __func__ << " got EAGAIN, retrying" << dendl;
./client/Client.cc:7642:    ldout(cct, 10) << __func__ << " " << dirp << " got frag " << dirp->buffer_frag
./client/Client.cc:7645:    ldout(cct, 10) << __func__ << " got error " << res << ", setting end flag" << dendl;
./client/Client.cc:7662:  ldout(cct, 10) << __func__ << " " << dirp << " on " << dirp->inode->ino
./client/Client.cc:7668:    ldout(cct, 10) << " dir is empty" << dendl;
./client/Client.cc:7685:      ldout(cct, 15) << " skipping null '" << dn->name << "'" << dendl;
./client/Client.cc:7690:      ldout(cct, 15) << " skipping mismatch shared gen '" << dn->name << "'" << dendl;
./client/Client.cc:7720:    ldout(cct, 15) << " de " << de.d_name << " off " << hex << dn->offset << dec
./client/Client.cc:7737:  ldout(cct, 10) << __func__ << " " << dirp << " on " << dirp->inode->ino << " at end" << dendl;
./client/Client.cc:7754:  ldout(cct, 10) << __func__ << " " << *dirp->inode << " offset " << hex << dirp->offset
./client/Client.cc:7769:    ldout(cct, 15) << " including ." << dendl;
./client/Client.cc:7798:    ldout(cct, 15) << " including .." << dendl;
./client/Client.cc:7832:  ldout(cct, 10) << "offset " << hex << dirp->offset << dec
./client/Client.cc:7860:    ldout(cct, 10) << "frag " << fg << " buffer size " << dirp->buffer.size()
./client/Client.cc:7891:      ldout(cct, 15) << " de " << de.d_name << " off " << hex << next_off - 1 << dec
./client/Client.cc:7902:      ldout(cct, 10) << " fetching next chunk of this frag" << dendl;
./client/Client.cc:7916:	ldout(cct, 10) << " marking (I_COMPLETE|I_DIR_ORDERED) on " << *diri << dendl;
./client/Client.cc:7923:	ldout(cct, 10) << " marking I_COMPLETE on " << *diri << dendl;
./client/Client.cc:8093:  ldout(cct, 3) << "getdir(" << relpath << ")" << dendl;
./client/Client.cc:8123:  ldout(cct, 3) << "open enter(" << relpath << ", " << ceph_flags_sys2wire(flags) << "," << mode << ")" << dendl;
./client/Client.cc:8200:  ldout(cct, 3) << "open exit(" << path << ", " << ceph_flags_sys2wire(flags) << ") = " << r << dendl;
./client/Client.cc:8214:  ldout(cct, 3) << __func__ << " enter(" << ino << ", #" << dirino << "/" << name << ")" << dendl;
./client/Client.cc:8232:  ldout(cct, 3) << __func__ << " exit(" << ino << ", #" << dirino << "/" << name << ") = " << r << dendl;
./client/Client.cc:8246:  ldout(cct, 3) << __func__ << " enter(" << ino << ")" << dendl;
./client/Client.cc:8263:  ldout(cct, 3) << __func__ << " exit(" << ino << ") = " << r << dendl;
./client/Client.cc:8280:  ldout(cct, 3) << __func__ << " enter(" << ino->ino << ")" << dendl;
./client/Client.cc:8288:    ldout(cct, 3) << __func__ << " dentry already present" << dendl;
./client/Client.cc:8294:    ldout(cct, 3) << "ino is root, no parent" << dendl;
./client/Client.cc:8309:      ldout(cct, 3) << __func__ << " found parent " << (*parent)->ino << dendl;
./client/Client.cc:8314:  ldout(cct, 3) << __func__ << " exit(" << ino->ino << ") = " << r << dendl;
./client/Client.cc:8331:  ldout(cct, 3) << __func__ << " enter(" << ino->ino << ")" << dendl;
./client/Client.cc:8342:  ldout(cct, 3) << __func__ << " exit(" << ino->ino << ") = " << r << dendl;
./client/Client.cc:8357:  ldout(cct, 10) << __func__ << " " << in->ino << " mode " << cmode << dendl;
./client/Client.cc:8361:    ldout(cct, 5) << "open success, fh is " << f << " combined IMMUTABLE SNAP caps " 
./client/Client.cc:8386:  //ldout(cct, 3) << "op: client->close(open_files[ " << fh << " ]);" << dendl;
./client/Client.cc:8387:  //ldout(cct, 3) << "op: open_files.erase( " << fh << " );" << dendl;
./client/Client.cc:8389:  ldout(cct, 5) << __func__ << " " << f << " mode " << f->mode << " on " << *in << dendl;
./client/Client.cc:8408:    ldout(cct, 1) << __func__ << " " << f << " on inode " << *in << " caught async_err = "
./client/Client.cc:8411:    ldout(cct, 10) << __func__ << " " << f << " on inode " << *in << " no async_err state" << dendl;
./client/Client.cc:8483:	ldout(cct, 1) << "Unable to get caps after open of inode " << *in <<
./client/Client.cc:8546:  ldout(cct, 3) << "close enter(" << fd << ")" << dendl;
./client/Client.cc:8560:  ldout(cct, 3) << "close exit(" << fd << ")" << dendl;
./client/Client.cc:8621:  ldout(cct, 3) << "_lseek(" << f << ", " << offset << ", " << whence << ") = " << f->pos << dendl;
./client/Client.cc:8628:  ldout(cct, 10) << __func__ << " " << f << dendl;
./client/Client.cc:8633:    ldout(cct, 10) << __func__ << " BLOCKING on " << f << dendl;
./client/Client.cc:8636:    ldout(cct, 10) << __func__ << " UNBLOCKING on " << f << dendl;
./client/Client.cc:8646:  ldout(cct, 10) << __func__ << " " << f << dendl;
./client/Client.cc:8721:  ldout(cct, 3) << "read(" << fd << ", " << (void*)buf << ", " << size << ", " << offset << ") = " << r << dendl;
./client/Client.cc:8887:  ldout(cct, 10) << __func__ << " " << *in << " " << off << "~" << len << dendl;
./client/Client.cc:8898:  ldout(cct, 10) << " min_bytes=" << f->readahead.get_min_readahead_size()
./client/Client.cc:8918:      ldout(cct, 20) << "readahead " << readahead_extent.first << "~" << readahead_extent.second
./client/Client.cc:8925:	ldout(cct, 20) << "readahead initiated, c " << onfinish2 << dendl;
./client/Client.cc:8928:	ldout(cct, 20) << "readahead was no-op, already cached" << dendl;
./client/Client.cc:8945:  ldout(cct, 10) << __func__ << " " << *in << " " << off << "~" << len << dendl;
./client/Client.cc:9011:  ldout(cct, 15) << __func__ << " unsafe_sync_write = " << unsafe_sync_write << dendl;
./client/Client.cc:9013:    ldout(cct, 10) << __func__ << " -- no more unsafe writes, unmount can proceed" << dendl;
./client/Client.cc:9039:  ldout(cct, 3) << "write(" << fd << ", \"...\", " << size << ", " << offset << ") = " << r << dendl;
./client/Client.cc:9073:        ldout(cct, 3) << "pwritev(" << fh << ", \"...\", " << totallen << ", " << offset << ") = " << w << dendl;
./client/Client.cc:9078:        ldout(cct, 3) << "preadv(" << fh << ", " <<  offset << ") = " << r << dendl;
./client/Client.cc:9122:  //ldout(cct, 7) << "write fh " << fh << " size " << size << " offset " << offset << dendl;
./client/Client.cc:9163:  ldout(cct, 10) << "cur file size is " << in->size << dendl;
./client/Client.cc:9211:  ldout(cct, 10) << " snaprealm " << *in->snaprealm << dendl;
./client/Client.cc:9306:    ldout(cct, 7) << "wrote to " << totalwritten+offset << ", extending file size" << dendl;
./client/Client.cc:9308:    ldout(cct, 7) << "wrote to " << totalwritten+offset << ", leaving file size at " << in->size << dendl;
./client/Client.cc:9341:    ldout(cct, 1) << __func__ << ": " << f << " on inode " << *in << " caught async_err = "
./client/Client.cc:9344:    ldout(cct, 10) << __func__ << ": " << f << " on inode " << *in << " no async_err state" << dendl;
./client/Client.cc:9401:    ldout(cct, 3) << "fsync(" << fd << ", " << syncdataonly
./client/Client.cc:9408:    ldout(cct, 3) << "fsync(" << fd << ", " << syncdataonly << ") = "
./client/Client.cc:9422:  ldout(cct, 3) << "_fsync on " << *in << " " << (syncdataonly ? "(dataonly)":"(data+metadata)") << dendl;
./client/Client.cc:9428:    ldout(cct, 15) << "using return-valued form of _fsync" << dendl;
./client/Client.cc:9435:  } else ldout(cct, 10) << "no metadata needs to commit" << dendl;
./client/Client.cc:9441:    ldout(cct, 15) << "waiting on unsafe requests, last tid " << req->get_tid() <<  dendl;
./client/Client.cc:9450:    ldout(cct, 15) << "waiting on data to flush" << dendl;
./client/Client.cc:9453:    ldout(cct, 15) << "got " << r << " from flush writeback" << dendl;
./client/Client.cc:9457:      ldout(cct, 10) << "ino " << in->ino << " has " << in->cap_refs[CEPH_CAP_FILE_BUFFER]
./client/Client.cc:9467:    ldout(cct, 10) << "ino " << in->ino << " has no uncommitted writes" << dendl;
./client/Client.cc:9469:    ldout(cct, 1) << "ino " << in->ino << " failed to commit to disk! "
./client/Client.cc:9478:  ldout(cct, 3) << "_fsync(" << f << ", " << (syncdataonly ? "dataonly)":"data+metadata)") << dendl;
./client/Client.cc:9498:  ldout(cct, 3) << "fstat(" << fd << ", " << stbuf << ") = " << r << dendl;
./client/Client.cc:9522:      ldout(cct, 3) << "fstatx exit on error!" << dendl;
./client/Client.cc:9528:  ldout(cct, 3) << "fstatx(" << fd << ", " << stx << ") = " << r << dendl;
./client/Client.cc:9551:  ldout(cct, 3) << "chdir(" << relpath << ")  cwd now " << cwd->ino << dendl;
./client/Client.cc:9560:  ldout(cct, 10) << __func__ << " " << *cwd << dendl;
./client/Client.cc:9576:      ldout(cct, 10) << __func__ << " looking up parent for " << *in << dendl;
./client/Client.cc:9628:    ldout(cct, 1) << "underlying call to statfs returned error: "
./client/Client.cc:9706:  ldout(cct, 10) << __func__ << " ino " << in->ino
./client/Client.cc:9872:  ldout(cct, 10) << __func__ << " ino " << in->ino << ", " << nr_fcntl_locks
./client/Client.cc:9882:  ldout(cct, 10) << __func__ << " " << fh << " ino " << in->ino << dendl;
./client/Client.cc:9954:  ldout(cct, 10) << "_getlk " << fh << " ino " << in->ino << dendl;
./client/Client.cc:9962:  ldout(cct, 10) << "_setlk " << fh << " ino " << in->ino << dendl;
./client/Client.cc:9964:  ldout(cct, 10) << "_setlk " << fh << " ino " << in->ino << " result=" << ret << dendl;
./client/Client.cc:9971:  ldout(cct, 10) << "_flock " << fh << " ino " << in->ino << dendl;
./client/Client.cc:9997:  ldout(cct, 10) << "_flock " << fh << " ino " << in->ino << " result=" << ret << dendl;
./client/Client.cc:10014:  ldout(cct, 10) << __func__ << " cb " << args->handle
./client/Client.cc:10048:    ldout(cct, 1) << "using dentry_invalidate_cb" << dendl;
./client/Client.cc:10051:    ldout(cct, 1) << "using remount_cb" << dendl;
./client/Client.cc:10068:  ldout(cct, 10) << __func__ << dendl;
./client/Client.cc:10088:    ldout(cct, 15) << __func__ << " waiting on data to flush" << dendl;
./client/Client.cc:10090:    ldout(cct, 15) << __func__ << " flush finished" << dendl;
./client/Client.cc:10117:  ldout(cct, 3) << "op: client->lazyio_propogate(" << fd
./client/Client.cc:10133:  ldout(cct, 3) << "op: client->lazyio_synchronize(" << fd
./client/Client.cc:10252:    ldout(cct, 10) << "open_snapdir created snapshot inode " << *in << dendl;
./client/Client.cc:10255:    ldout(cct, 10) << "open_snapdir had snapshot inode " << *in << dendl;
./client/Client.cc:10265:  ldout(cct, 3) << __func__ << " " << vparent << " " << name << dendl;
./client/Client.cc:10297:  ldout(cct, 3) << __func__ << " " << vparent << " " << name
./client/Client.cc:10310:  ldout(cct, 3) << "ll_lookup_inode " << ino  << dendl;
./client/Client.cc:10355:  ldout(cct, 3) << __func__ << " " << vparent << " " << name << dendl;
./client/Client.cc:10385:  ldout(cct, 3) << __func__ << " " << vparent << " " << name
./client/Client.cc:10405:  ldout(cct, 3) << __func__ << " " << name << dendl;
./client/Client.cc:10437:  ldout(cct, 20) << __func__ << " " << in << " " << in->ino << " -> " << in->ll_ref << dendl;
./client/Client.cc:10443:  ldout(cct, 20) << __func__ << " " << in << " " << in->ino << " " << num << " -> " << in->ll_ref << dendl;
./client/Client.cc:10465:  ldout(cct, 10) << __func__ << dendl;
./client/Client.cc:10482:  ldout(cct, 3) << __func__ << " " << ino << " " << count << dendl;
./client/Client.cc:10495:    ldout(cct, 1) << "WARNING: ll_forget on " << ino << " " << count
./client/Client.cc:10569:  ldout(cct, 3) << __func__ << " " << vino << dendl;
./client/Client.cc:10590:  ldout(cct, 3) << __func__ << " " << _get_vino(in) << " = " << res << dendl;
./client/Client.cc:10610:  ldout(cct, 3) << __func__ << " " << _get_vino(in) << " = " << res << dendl;
./client/Client.cc:10619:  ldout(cct, 3) << __func__ << " " << vino << " mask " << hex << mask << dec
./client/Client.cc:10660:  ldout(cct, 3) << __func__ << " " << _get_vino(in) << " = " << res << dendl;
./client/Client.cc:10682:  ldout(cct, 3) << __func__ << " " << _get_vino(in) << " = " << res << dendl;
./client/Client.cc:10929:  ldout(cct, 3) << "_getxattr(" << in->ino << ", \"" << name << "\", " << size << ") = " << r << dendl;
./client/Client.cc:10954:  ldout(cct, 3) << __func__ << " " << vino << " " << name << " size " << size << dendl;
./client/Client.cc:11011:  ldout(cct, 3) << __func__ << "(" << in->ino << ", " << size << ") = " << r << dendl;
./client/Client.cc:11025:  ldout(cct, 3) << __func__ << " " << vino << " size " << size << dendl;
./client/Client.cc:11061:  ldout(cct, 3) << __func__ << "(" << in->ino << ", \"" << name << "\") = " <<
./client/Client.cc:11225:  ldout(cct, 3) << __func__ << " " << vino << " " << name << " size " << size << dendl;
./client/Client.cc:11268:  ldout(cct, 3) << "_removexattr(" << in->ino << ", \"" << name << "\") = " << res << dendl;
./client/Client.cc:11291:  ldout(cct, 3) << "ll_removexattr " << vino << " " << name << dendl;
./client/Client.cc:11550:  ldout(cct, 3) << "ll_readlink " << vino << dendl;
./client/Client.cc:11559:  ldout(cct, 3) << "ll_readlink " << vino << " = " << r << dendl;
./client/Client.cc:11566:  ldout(cct, 3) << "_mknod(" << dir->ino << " " << name << ", 0" << oct
./client/Client.cc:11609:  ldout(cct, 3) << "mknod(" << path << ", 0" << oct << mode << dec << ") = " << res << dendl;
./client/Client.cc:11628:  ldout(cct, 3) << "ll_mknod " << vparent << " " << name << dendl;
./client/Client.cc:11650:  ldout(cct, 3) << "ll_mknod " << vparent << " " << name
./client/Client.cc:11669:  ldout(cct, 3) << "ll_mknodx " << vparent << " " << name << dendl;
./client/Client.cc:11691:  ldout(cct, 3) << "ll_mknodx " << vparent << " " << name
./client/Client.cc:11702:  ldout(cct, 3) << "_create(" << dir->ino << " " << name << ", 0" << oct <<
./client/Client.cc:11778:  ldout(cct, 3) << "create(" << path << ", 0" << oct << mode << dec 
./client/Client.cc:11794:  ldout(cct, 3) << "_mkdir(" << dir->ino << " " << name << ", 0" << oct
./client/Client.cc:11833:  ldout(cct, 10) << "_mkdir: making request" << dendl;
./client/Client.cc:11835:  ldout(cct, 10) << "_mkdir result is " << res << dendl;
./client/Client.cc:11839:  ldout(cct, 3) << "_mkdir(" << path << ", 0" << oct << mode << dec << ") = " << res << dendl;
./client/Client.cc:11857:  ldout(cct, 3) << "ll_mkdir " << vparent << " " << name << dendl;
./client/Client.cc:11878:  ldout(cct, 3) << "ll_mkdir " << vparent << " " << name
./client/Client.cc:11895:  ldout(cct, 3) << "ll_mkdirx " << vparent << " " << name << dendl;
./client/Client.cc:11919:  ldout(cct, 3) << "ll_mkdirx " << vparent << " " << name
./client/Client.cc:11928:  ldout(cct, 3) << "_symlink(" << dir->ino << " " << name << ", " << target
./client/Client.cc:11962:  ldout(cct, 3) << "_symlink(\"" << path << "\", \"" << target << "\") = " <<
./client/Client.cc:11981:  ldout(cct, 3) << "ll_symlink " << vparent << " " << name << " -> " << value
./client/Client.cc:12003:  ldout(cct, 3) << "ll_symlink " << vparent << " " << name
./client/Client.cc:12020:  ldout(cct, 3) << "ll_symlinkx " << vparent << " " << name << " -> " << value
./client/Client.cc:12042:  ldout(cct, 3) << "ll_symlinkx " << vparent << " " << name
./client/Client.cc:12050:  ldout(cct, 3) << "_unlink(" << dir->ino << " " << name
./client/Client.cc:12090:  ldout(cct, 3) << "unlink(" << path << ") = " << res << dendl;
./client/Client.cc:12107:  ldout(cct, 3) << "ll_unlink " << vino << " " << name << dendl;
./client/Client.cc:12124:  ldout(cct, 3) << "_rmdir(" << dir->ino << " " << name << " uid "
./client/Client.cc:12167:  ldout(cct, 3) << "rmdir(" << path << ") = " << res << dendl;
./client/Client.cc:12184:  ldout(cct, 3) << "ll_rmdir " << vino << " " << name << dendl;
./client/Client.cc:12202:  ldout(cct, 3) << "_rename(" << fromdir->ino << " " << fromname << " to "
./client/Client.cc:12294:  ldout(cct, 10) << "rename result is " << res << dendl;
./client/Client.cc:12299:  ldout(cct, 3) << "_rename(" << from << ", " << to << ") = " << res << dendl;
./client/Client.cc:12318:  ldout(cct, 3) << "ll_rename " << vparent << " " << name << " to "
./client/Client.cc:12342:  ldout(cct, 3) << "_link(" << in->ino << " to " << dir->ino << " " << newname
./client/Client.cc:12374:  ldout(cct, 10) << "link result is " << res << dendl;
./client/Client.cc:12377:  ldout(cct, 3) << "link(" << existing << ", " << path << ") = " << res << dendl;
./client/Client.cc:12396:  ldout(cct, 3) << "ll_link " << vino << " to " << vnewparent << " " <<
./client/Client.cc:12532:  ldout(cct, 3) << "ll_opendir " << vino << dendl;
./client/Client.cc:12547:  ldout(cct, 3) << "ll_opendir " << vino << " = " << r << " (" << *dirpp << ")"
./client/Client.cc:12555:  ldout(cct, 3) << "ll_releasedir " << dirp << dendl;
./client/Client.cc:12569:  ldout(cct, 3) << "ll_fsyncdir " << dirp << dendl;
./client/Client.cc:12590:  ldout(cct, 3) << "ll_open " << vino << " " << ceph_flags_sys2wire(flags) << dendl;
./client/Client.cc:12612:  ldout(cct, 3) << "ll_open " << vino << " " << ceph_flags_sys2wire(flags) <<
./client/Client.cc:12625:  ldout(cct, 3) << "_ll_create " << vparent << " " << name << " 0" << oct <<
./client/Client.cc:12659:  ldout(cct, 20) << "_ll_create created = " << created << dendl;
./client/Client.cc:12696:  ldout(cct, 3) << "_ll_create " << vparent << " " << name << " 0" << oct <<
./client/Client.cc:12777:  ldout(cct, 3) << "ll_read " << fh << " " << fh->inode->ino << " " << " " << off << "~" << len << dendl;
./client/Client.cc:12855:  ldout(cct, 1) << "ll_block_write for " << vino.ino << "." << blockid
./client/Client.cc:12899:    ldout(cct, 1) << "ll_commit_blocks for " << vino.ino << " from "
./client/Client.cc:12918:  ldout(cct, 3) << "ll_write " << fh << " " << fh->inode->ino << " " << off <<
./client/Client.cc:12931:  ldout(cct, 3) << "ll_write " << fh << " " << off << "~" << len << " = " << r
./client/Client.cc:12955:  ldout(cct, 3) << "ll_flush " << fh << " " << fh->inode->ino << " " << dendl;
./client/Client.cc:12968:  ldout(cct, 3) << "ll_fsync " << fh << " " << fh->inode->ino << " " << dendl;
./client/Client.cc:12986:  ldout(cct, 3) << "ll_sync_inode " << *in << " " << dendl;
./client/Client.cc:13128:  ldout(cct, 3) << __func__ << " " << fh << " " << fh->inode->ino << " " << dendl;
./client/Client.cc:13159:  ldout(cct, 3) << __func__ << " (fh)" << fh << " " << fh->inode->ino << " " <<
./client/Client.cc:13176:  ldout(cct, 3) << "ll_getlk (fh)" << fh << " " << fh->inode->ino << dendl;
./client/Client.cc:13189:  ldout(cct, 3) << __func__ << "  (fh) " << fh << " " << fh->inode->ino << dendl;
./client/Client.cc:13202:  ldout(cct, 3) << __func__ << "  (fh) " << fh << " " << fh->inode->ino << dendl;
./client/Client.cc:13272:  ldout(cct, 3) << __func__ << " tid " << req->get_tid() << dendl;
./client/Client.cc:13298:  ldout(cct, 3) << __func__ << "(" << relpath << ") = 0" << dendl;
./client/Client.cc:13316:  ldout(cct, 3) << __func__ << "(" << fd << ") = 0" << dendl;
./client/Client.cc:13494:  ldout(cct, 3) << __func__ << "(" << fd << ", " << length << ", " << offset << ") = 0" << dendl;
./client/Client.cc:13525:  ldout(cct, 10) << __func__ << " on " << con->get_peer_addr() << dendl;
./client/Client.cc:13530:  ldout(cct, 0) << __func__ << " on " << con->get_peer_addr() << dendl;
./client/Client.cc:13536:  ldout(cct, 0) << __func__ << " on " << con->get_peer_addr() << dendl;
./client/Client.cc:13554:	  ldout(cct, 1) << "reset from mds we were closing; we'll call that closed" << dendl;
./client/Client.cc:13560:	    ldout(cct, 1) << "reset from mds we were opening; retrying" << dendl;
./client/Client.cc:13574:	      ldout(cct, 1) << "reset from mds we were open; close mds session for reconnect" << dendl;
./client/Client.cc:13577:	      ldout(cct, 1) << "reset from mds we were open; mark session as stale" << dendl;
./client/Client.cc:13596:  ldout(cct, 1) << __func__ << " on " << con->get_peer_addr() << dendl;
./client/Client.cc:13613:    ldout(cct, 10) << __func__ << " realm " << realm->ino << dendl;
./client/Client.cc:13626:  ldout(cct, 10) << __func__ << " " << in->vino() << " -> " << quota_in->vino() << dendl;
./client/Client.cc:13762:      ldout(cct, 10) << __func__ << " on pool " << pool_id << " ns " << pool_ns
./client/Client.cc:13770:      ldout(cct, 10) << __func__ << " on pool " << pool_id << " ns " << pool_ns
./client/Client.cc:13789:    ldout(cct, 10) << __func__ << " on pool " << pool_id << " ns " << pool_ns
./client/Client.cc:13794:    ldout(cct, 10) << __func__ << " on pool " << pool_id << " ns " << pool_ns
./client/Client.cc:13836:  ldout(cct, 10) << __func__ << " ino " << in->ino << " result=" << r << dendl;
./client/Client.cc:13884:  ldout(cct, 10) << __func__ << " dir ino " << dir->ino << " result=" << r << dendl;
./client/Client.cc:13912:  ldout(cct, 5) << __func__ << " epoch = " << e << dendl;
./mds/flock.cc:77:  ldout(cct,15) << "is_deadlock " << fl << dendl;
./mds/flock.cc:95:      ldout(cct,15) << " detect deadlock" << dendl;
./mds/flock.cc:113:    ldout(cct,15) << " conflict lock owner " << *p << dendl;
./mds/flock.cc:149:  ldout(cct,15) << "add_lock " << new_lock << dendl;
./mds/flock.cc:156:    ldout(cct,15) << "got overlapping lock, splitting by owner" << dendl;
./mds/flock.cc:162:      ldout(cct,15) << "overlapping lock, and this lock is exclusive, can't set"
./mds/flock.cc:172:        ldout(cct,15) << " blocked by exclusive lock in overlapping_locks" << dendl;
./mds/flock.cc:181:        ldout(cct,15) << "inserting shared lock" << dendl;
./mds/flock.cc:191:    ldout(cct,15) << "no conflicts, inserting " << new_lock << dendl;
./mds/flock.cc:232:    ldout(cct,15) << "splitting by owner" << dendl;
./mds/flock.cc:234:  } else ldout(cct,15) << "attempt to remove lock at " << removal_lock.start
./mds/flock.cc:242:  ldout(cct,15) << "examining " << self_overlapping_locks.size()
./mds/flock.cc:248:    ldout(cct,15) << "self overlapping lock " << (*iter)->second << dendl;
./mds/flock.cc:257:        ldout(cct,15) << "erasing " << (*iter)->second << dendl;
./mds/flock.cc:268:        ldout(cct,15) << "erasing " << (*iter)->second << dendl;
./mds/flock.cc:284:        ldout(cct,15) << "erasing " << (*iter)->second << dendl;
./mds/flock.cc:332:  ldout(cct,15) << "adjust_locks" << dendl;
./mds/flock.cc:341:    ldout(cct,15) << "adjusting lock: " << *old_lock << dendl;
./mds/flock.cc:350:      ldout(cct,15) << "one lock extends forever" << dendl;
./mds/flock.cc:353:        ldout(cct,15) << "same lock type, unifying" << dendl;
./mds/flock.cc:360:        ldout(cct,15) << "shrinking old lock" << dendl;
./mds/flock.cc:384:        ldout(cct,15) << "merging locks, they're the same type" << dendl;
./mds/flock.cc:390:        ldout(cct,15) << "erasing lock " << (*iter)->second << dendl;
./mds/flock.cc:394:        ldout(cct,15) << "locks aren't same type, changing sizes" << dendl;
./mds/flock.cc:424:    ldout(cct,15) << "lock to coalesce: " << *old_lock << dendl;
./mds/flock.cc:464:     ldout(cct,15) << "get_lower_dout(15)eturning end()" << dendl;
./mds/flock.cc:465:   else ldout(cct,15) << "get_lower_bound returning iterator pointing to "
./mds/flock.cc:478:    ldout(cct,15) << "get_last_before returning end()" << dendl;
./mds/flock.cc:479:  else ldout(cct,15) << "get_last_before returning iterator pointing to "
./mds/flock.cc:492:  ldout(cct,15) << "share_space got start: " << start << ", end: " << end
./mds/flock.cc:503:  ldout(cct,15) << "get_overlapping_locks" << dendl;
./mds/flock.cc:547:  ldout(cct,15) << "get_waiting_overlaps" << dendl;
./mds/flock.cc:568:  ldout(cct,15) << "owner lock: " << owner << dendl;
./mds/flock.cc:570:    ldout(cct,15) << "comparing to " << (*iter)->second << dendl;
./mds/flock.cc:572:      ldout(cct,15) << "success, pushing to owned_locks" << dendl;
./mds/flock.cc:576:      ldout(cct,15) << "failure, something not equal in this group "
./mds/MDSAuthCaps.cc:193:    ldout(cct, 10) << __func__ << " inode(path /" << inode_path
./librbd/exclusive_lock/StandardPolicy.cc:19:  ldout(m_image_ctx->cct, 20) << this << " " << __func__ << ": force=" << force
./librbd/exclusive_lock/PreAcquireRequest.cc:49:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreAcquireRequest.cc:60:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PreAcquireRequest.cc:68:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreAcquireRequest.cc:79:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:65:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:76:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:84:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:95:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:105:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:128:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:148:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:158:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:166:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:178:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:195:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:206:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:225:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:236:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:261:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:272:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PreReleaseRequest.cc:284:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:70:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:86:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:90:    ldout(cct, 5) << "exclusive lock dynamically disabled" << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:123:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:139:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:154:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:166:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:182:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:193:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:211:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:224:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:246:  ldout(cct, 10) << dendl;
./librbd/exclusive_lock/PostAcquireRequest.cc:257:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/exclusive_lock/AutomaticPolicy.cc:19:  ldout(m_image_ctx->cct, 20) << this << " " << __func__ << ": force=" << force
./librbd/ImageWatcher.cc:85:  ldout(cct, 10) << this << " unregistering image watcher" << dendl;
./librbd/ImageWatcher.cc:98:  ldout(cct, 10) << this << " "  << __func__ << dendl;
./librbd/ImageWatcher.cc:119:  ldout(m_image_ctx.cct, 20) << this << " remote async request progress: "
./librbd/ImageWatcher.cc:138:  ldout(m_image_ctx.cct, 20) << this << " remote async request finished: "
./librbd/ImageWatcher.cc:149:  ldout(m_image_ctx.cct, 20) << this << " " << __func__ << ": "
./librbd/ImageWatcher.cc:286:  ldout(m_image_ctx.cct, 10) << this << ": " << __func__ << dendl;
./librbd/ImageWatcher.cc:323:  ldout(m_image_ctx.cct, 10) << this << " current lock owner: "
./librbd/ImageWatcher.cc:335:  ldout(m_image_ctx.cct, 10) << this << " notify acquired lock" << dendl;
./librbd/ImageWatcher.cc:348:  ldout(m_image_ctx.cct, 10) << this << " notify released lock" << dendl;
./librbd/ImageWatcher.cc:371:    ldout(m_image_ctx.cct, 15) << this << " requesting exclusive lock" << dendl;
./librbd/ImageWatcher.cc:399:  ldout(m_image_ctx.cct, 10) << this << " notify request lock" << dendl;
./librbd/ImageWatcher.cc:418:    ldout(m_image_ctx.cct, 5) << this << " timed out requesting lock: retrying"
./librbd/ImageWatcher.cc:424:    ldout(m_image_ctx.cct, 5) << this << " peer will not release lock" << dendl;
./librbd/ImageWatcher.cc:434:    ldout(m_image_ctx.cct, 15) << this << " will retry in " << retry_timeout
./librbd/ImageWatcher.cc:468:  ldout(m_image_ctx.cct, 20) << "scheduling async request time out: " << id
./librbd/ImageWatcher.cc:485:    ldout(m_image_ctx.cct, 5) << "async request timed out: " << id << dendl;
./librbd/ImageWatcher.cc:498:  ldout(m_image_ctx.cct, 10) << this << " async request: " << async_request_id
./librbd/ImageWatcher.cc:549:  ldout(m_image_ctx.cct, 10) << this << " image header updated" << dendl;
./librbd/ImageWatcher.cc:563:  ldout(m_image_ctx.cct, 10) << this << " image exclusively locked announcement"
./librbd/ImageWatcher.cc:592:  ldout(m_image_ctx.cct, 10) << this << " exclusive lock released" << dendl;
./librbd/ImageWatcher.cc:598:      ldout(m_image_ctx.cct, 10) << this << " unexpected owner: "
./librbd/ImageWatcher.cc:626:  ldout(m_image_ctx.cct, 10) << this << " exclusive lock requested" << dendl;
./librbd/ImageWatcher.cc:644:      ldout(m_image_ctx.cct, 10) << this << " queuing release of exclusive lock"
./librbd/ImageWatcher.cc:661:    ldout(m_image_ctx.cct, 20) << this << " request progress: "
./librbd/ImageWatcher.cc:676:    ldout(m_image_ctx.cct, 10) << this << " request finished: "
./librbd/ImageWatcher.cc:698:        ldout(m_image_ctx.cct, 10) << this << " remote flatten request: "
./librbd/ImageWatcher.cc:724:        ldout(m_image_ctx.cct, 10) << this << " remote resize request: "
./librbd/ImageWatcher.cc:746:      ldout(m_image_ctx.cct, 10) << this << " remote snap_create request: "
./librbd/ImageWatcher.cc:768:      ldout(m_image_ctx.cct, 10) << this << " remote snap_rename request: "
./librbd/ImageWatcher.cc:790:      ldout(m_image_ctx.cct, 10) << this << " remote snap_remove request: "
./librbd/ImageWatcher.cc:811:      ldout(m_image_ctx.cct, 10) << this << " remote snap_protect request: "
./librbd/ImageWatcher.cc:832:      ldout(m_image_ctx.cct, 10) << this << " remote snap_unprotect request: "
./librbd/ImageWatcher.cc:859:        ldout(m_image_ctx.cct, 10) << this
./librbd/ImageWatcher.cc:880:      ldout(m_image_ctx.cct, 10) << this << " remote rename request: "
./librbd/ImageWatcher.cc:900:      ldout(m_image_ctx.cct, 10) << this << " remote update_features request: "
./librbd/ImageWatcher.cc:979:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/ImageWatcher.cc:1009:  ldout(cct, 10) << this << " C_ResponseMessage: r=" << r << dendl;
./librbd/operation/SnapshotLimitRequest.cc:32:  ldout(cct, 5) << this << " " << __func__ << " r=" << r << dendl;
./librbd/operation/SnapshotLimitRequest.cc:46:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:57:  ldout(cct, 5) << "r=" << r << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:77:  ldout(cct, 5) << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:94:  ldout(cct, 5) << "r=" << r << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:115:  ldout(cct, 5) << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:133:  ldout(cct, 5) << "r=" << r << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:171:        ldout(cct, 1) << "No such snapshot" << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:193:  ldout(cct, 5) << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:205:  ldout(cct, 5) << "r=" << r << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:234:      ldout(cct, 5) << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:252:  ldout(cct, 5) << "r=" << r << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:269:  ldout(cct, 5) << "snap_name=" << m_snap_name << ", "
./librbd/operation/SnapshotRemoveRequest.cc:284:  ldout(cct, 5) << "r=" << r << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:300:  ldout(cct, 5) << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:321:  ldout(cct, 5) << "r=" << r << dendl;
./librbd/operation/SnapshotRemoveRequest.cc:337:  ldout(cct, 5) << dendl;
./librbd/operation/ObjectMapIterate.cc:49:      ldout(image_ctx.cct, 20) << m_oid << " C_VerifyObjectCallback completed "
./librbd/operation/ObjectMapIterate.cc:86:    ldout(cct, 20) << m_oid << " C_VerifyObjectCallback::should_complete: "
./librbd/operation/ObjectMapIterate.cc:95:    ldout(image_ctx.cct, 5) << m_oid
./librbd/operation/ObjectMapIterate.cc:165:    ldout(cct, 10) << "C_VerifyObjectCallback::object_map_action"
./librbd/operation/ObjectMapIterate.cc:182:	ldout(cct, 1) << "object map inconsistent: object "
./librbd/operation/ObjectMapIterate.cc:203:  ldout(cct, 5) << this << " should_complete: " << " r=" << r << dendl;
./librbd/operation/ObjectMapIterate.cc:251:  ldout(cct, 5) << this << " send_verify_objects" << dendl;
./librbd/operation/ObjectMapIterate.cc:282:  ldout(cct, 5) << this << " send_invalidate_object_map" << dendl;
./librbd/operation/MetadataRemoveRequest.cc:32:  ldout(cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/operation/MetadataRemoveRequest.cc:46:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/MetadataSetRequest.cc:33:  ldout(cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/operation/MetadataSetRequest.cc:47:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/TrimRequest.cc:47:    ldout(image_ctx.cct, 10) << "removing (with copyup) " << oid << dendl;
./librbd/operation/TrimRequest.cc:85:    ldout(image_ctx.cct, 10) << "removing " << oid << dendl;
./librbd/operation/TrimRequest.cc:115:  ldout(cct, 10) << this << " trim image " << original_size << " -> "
./librbd/operation/TrimRequest.cc:127:  ldout(cct, 5) << this << " should_complete: r=" << r << dendl;
./librbd/operation/TrimRequest.cc:129:    ldout(cct, 5) << "trim operation interrupted" << dendl;
./librbd/operation/TrimRequest.cc:139:    ldout(cct, 5) << " PRE_TRIM" << dendl;
./librbd/operation/TrimRequest.cc:144:    ldout(cct, 5) << " COPYUP_OBJECTS" << dendl;
./librbd/operation/TrimRequest.cc:149:    ldout(cct, 5) << " REMOVE_OBJECTS" << dendl;
./librbd/operation/TrimRequest.cc:154:    ldout(cct, 5) << " POST_TRIM" << dendl;
./librbd/operation/TrimRequest.cc:159:    ldout(cct, 5) << "CLEAN_BOUNDARY" << dendl;
./librbd/operation/TrimRequest.cc:164:    ldout(cct, 5) << "FINISHED" << dendl;
./librbd/operation/TrimRequest.cc:193:      ldout(image_ctx.cct, 5) << this << " send_pre_trim: "
./librbd/operation/TrimRequest.cc:244:  ldout(image_ctx.cct, 5) << this << " send_copyup_objects: "
./librbd/operation/TrimRequest.cc:264:  ldout(image_ctx.cct, 5) << this << " send_remove_objects: "
./librbd/operation/TrimRequest.cc:287:      ldout(image_ctx.cct, 5) << this << " send_post_trim:"
./librbd/operation/TrimRequest.cc:320:  ldout(image_ctx.cct, 5) << this << " send_clean_boundary: "
./librbd/operation/TrimRequest.cc:341:    ldout(cct, 20) << " ex " << *p << dendl;
./librbd/operation/SnapshotCreateRequest.cc:46:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotCreateRequest.cc:56:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotCreateRequest.cc:69:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotCreateRequest.cc:80:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotCreateRequest.cc:103:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotCreateRequest.cc:110:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotCreateRequest.cc:127:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotCreateRequest.cc:140:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << ", "
./librbd/operation/SnapshotCreateRequest.cc:159:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotCreateRequest.cc:193:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotCreateRequest.cc:222:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotCreateRequest.cc:239:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotCreateRequest.cc:251:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotCreateRequest.cc:266:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotCreateRequest.cc:290:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotUnprotectRequest.cc:70:    ldout(cct, 10) << this << " scanning pool '" << m_pool.second << "'"
./librbd/operation/SnapshotUnprotectRequest.cc:77:      ldout(cct, 1) << "pool '" << m_pool.second << "' no longer exists"
./librbd/operation/SnapshotUnprotectRequest.cc:92:      ldout(cct, 1) << "pool '" << m_pool.second << "' no longer exists"
./librbd/operation/SnapshotUnprotectRequest.cc:123:    ldout(cct, 10) << this << " retrieved children: r=" << r << dendl;
./librbd/operation/SnapshotUnprotectRequest.cc:171:  ldout(cct, 5) << this << " " << __func__ << ": state=" << m_state << ", "
./librbd/operation/SnapshotUnprotectRequest.cc:175:      ldout(cct, 1) << "snapshot is already unprotected" << dendl;
./librbd/operation/SnapshotUnprotectRequest.cc:231:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotUnprotectRequest.cc:246:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotUnprotectRequest.cc:276:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotUnprotectRequest.cc:296:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:35:  ldout(cct, 5) << this << " should_complete: " << " r=" << r << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:40:    ldout(cct, 5) << "RESIZE_OBJECT_MAP" << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:52:    ldout(cct, 5) << "TRIM_IMAGE" << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:59:    ldout(cct, 5) << "VERIFY_OBJECTS" << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:66:    ldout(cct, 5) << "SAVE_OBJECT_MAP" << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:72:    ldout(cct, 5) << "UPDATE_HEADER" << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:84:    ldout(cct, 5) << "rebuild object map operation interrupted" << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:111:  ldout(cct, 5) << this << " send_resize_object_map" << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:132:  ldout(cct, 5) << this << " send_trim_image" << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:165:    ldout(cct, 15) << image_ctx.get_object_name(object_no)
./librbd/operation/RebuildObjectMapRequest.cc:180:  ldout(cct, 5) << this << " send_verify_objects" << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:195:  ldout(cct, 5) << this << " send_save_object_map" << dendl;
./librbd/operation/RebuildObjectMapRequest.cc:215:  ldout(m_image_ctx.cct, 5) << this << " send_update_header" << dendl;
./librbd/operation/SnapshotRenameRequest.cc:65:  ldout(cct, 5) << this << " " << __func__ << ": state=" << m_state << ", "
./librbd/operation/SnapshotRenameRequest.cc:69:      ldout(cct, 1) << "snapshot already exists" << dendl;
./librbd/operation/SnapshotRenameRequest.cc:85:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotProtectRequest.cc:49:  ldout(cct, 5) << this << " " << __func__ << ": state=" << m_state << ", "
./librbd/operation/SnapshotProtectRequest.cc:53:      ldout(cct, 1) << "snapshot is already protected" << dendl;
./librbd/operation/SnapshotProtectRequest.cc:67:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:43:    ldout(cct, 20) << "C_RollbackObject: " << __func__ << ": object_num="
./librbd/operation/SnapshotRollbackRequest.cc:96:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:108:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:136:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:151:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:173:      ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:190:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:201:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:226:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:229:    ldout(cct, 5) << "snapshot rollback operation interrupted" << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:255:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:270:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:283:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/SnapshotRollbackRequest.cc:297:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/FlattenRequest.cc:39:      ldout(cct, 1) << "lost exclusive lock during flatten" << dendl;
./librbd/operation/FlattenRequest.cc:68:  ldout(cct, 5) << this << " should_complete: " << " r=" << r << dendl;
./librbd/operation/FlattenRequest.cc:70:    ldout(cct, 5) << "flatten operation interrupted" << dendl;
./librbd/operation/FlattenRequest.cc:80:    ldout(cct, 5) << "FLATTEN_OBJECTS" << dendl;
./librbd/operation/FlattenRequest.cc:84:    ldout(cct, 5) << "DETACH_CHILD" << dendl;
./librbd/operation/FlattenRequest.cc:88:    ldout(cct, 5) << "UPDATE_HEADER" << dendl;
./librbd/operation/FlattenRequest.cc:104:  ldout(cct, 5) << this << " send" << dendl;
./librbd/operation/FlattenRequest.cc:137:  ldout(cct, 2) << "detaching child" << dendl;
./librbd/operation/FlattenRequest.cc:152:  ldout(cct, 5) << this << " send_update_header" << dendl;
./librbd/operation/FlattenRequest.cc:164:      ldout(cct, 5) << "image already flattened" << dendl;
./librbd/operation/DisableFeaturesRequest.cc:46:  ldout(cct, 20) << this << " " << __func__ << ": features=" << m_features
./librbd/operation/DisableFeaturesRequest.cc:56:  ldout(cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/operation/DisableFeaturesRequest.cc:68:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:80:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:95:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:107:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:135:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:161:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:224:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:242:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:255:  ldout(cct, 20) << this << " " << __func__ << ": m_mirror_mode="
./librbd/operation/DisableFeaturesRequest.cc:272:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:290:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:322:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:337:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:357:      ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:376:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:395:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:412:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:435:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:442:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:458:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:478:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:493:  ldout(cct, 20) << this << " " << __func__ << ": new_features="
./librbd/operation/DisableFeaturesRequest.cc:512:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:517:    ldout(cct, 5) << this << " " << __func__
./librbd/operation/DisableFeaturesRequest.cc:543:  ldout(cct, 20) << this << " " << __func__ << ": disable_flags="
./librbd/operation/DisableFeaturesRequest.cc:559:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:575:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:588:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:602:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/DisableFeaturesRequest.cc:615:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/DisableFeaturesRequest.cc:624:  ldout(cct, 20) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/operation/EnableFeaturesRequest.cc:43:  ldout(cct, 20) << this << " " << __func__ << ": features=" << m_features
./librbd/operation/EnableFeaturesRequest.cc:52:  ldout(cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/operation/EnableFeaturesRequest.cc:64:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/EnableFeaturesRequest.cc:76:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/EnableFeaturesRequest.cc:91:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/EnableFeaturesRequest.cc:103:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/EnableFeaturesRequest.cc:128:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/EnableFeaturesRequest.cc:146:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/EnableFeaturesRequest.cc:229:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/EnableFeaturesRequest.cc:249:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/EnableFeaturesRequest.cc:272:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/EnableFeaturesRequest.cc:279:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/EnableFeaturesRequest.cc:301:  ldout(cct, 20) << this << " " << __func__ << ": enable_flags="
./librbd/operation/EnableFeaturesRequest.cc:318:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/EnableFeaturesRequest.cc:334:  ldout(cct, 20) << this << " " << __func__ << ": new_features="
./librbd/operation/EnableFeaturesRequest.cc:353:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/EnableFeaturesRequest.cc:376:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/EnableFeaturesRequest.cc:391:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/EnableFeaturesRequest.cc:407:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/EnableFeaturesRequest.cc:427:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/EnableFeaturesRequest.cc:443:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/operation/EnableFeaturesRequest.cc:456:  ldout(cct, 20) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/EnableFeaturesRequest.cc:465:  ldout(cct, 20) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/operation/Request.cc:44:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/operation/Request.cc:52:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/operation/Request.cc:67:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/operation/Request.cc:104:    ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/operation/Request.cc:119:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/operation/Request.cc:150:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/operation/Request.cc:162:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/operation/ResizeRequest.cc:96:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/ResizeRequest.cc:106:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/ResizeRequest.cc:123:    ldout(cct, 1) << " shrinking the image is not permitted" << dendl;
./librbd/operation/ResizeRequest.cc:133:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/ResizeRequest.cc:141:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/ResizeRequest.cc:157:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/ResizeRequest.cc:171:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/ResizeRequest.cc:174:    ldout(cct, 5) << "resize operation interrupted" << dendl;
./librbd/operation/ResizeRequest.cc:190:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/ResizeRequest.cc:207:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/ResizeRequest.cc:222:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/ResizeRequest.cc:235:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/ResizeRequest.cc:278:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/ResizeRequest.cc:296:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/ResizeRequest.cc:318:  ldout(cct, 5) << this << " " << __func__ << " "
./librbd/operation/ResizeRequest.cc:338:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/ResizeRequest.cc:349:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/ResizeRequest.cc:360:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/ResizeRequest.cc:377:  ldout(cct, 5) << this << " " << __func__ << " "
./librbd/operation/ResizeRequest.cc:409:  ldout(cct, 5) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/operation/RenameRequest.cc:65:  ldout(cct, 5) << this << " " << __func__ << ": state=" << m_state << ", "
./librbd/operation/RenameRequest.cc:70:      ldout(cct, 1) << "image already exists" << dendl;
./librbd/operation/RenameRequest.cc:127:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/RenameRequest.cc:146:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/RenameRequest.cc:163:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/operation/RenameRequest.cc:191:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/ExclusiveLock.cc:50:  ldout(m_image_ctx.cct, 20) << "=" << accept_requests << dendl;
./librbd/ExclusiveLock.cc:58:  ldout(m_image_ctx.cct, 20) << "=" << accept << dendl;
./librbd/ExclusiveLock.cc:77:  ldout(m_image_ctx.cct, 20) << dendl;
./librbd/ExclusiveLock.cc:90:  ldout(m_image_ctx.cct, 20) << dendl;
./librbd/ExclusiveLock.cc:96:  ldout(m_image_ctx.cct, 10) << dendl;
./librbd/ExclusiveLock.cc:109:  ldout(m_image_ctx.cct, 10) << dendl;
./librbd/ExclusiveLock.cc:124:  ldout(m_image_ctx.cct, 10) << dendl;
./librbd/ExclusiveLock.cc:148:  ldout(m_image_ctx.cct, 10) << ": features=" << features << dendl;
./librbd/ExclusiveLock.cc:166:  ldout(m_image_ctx.cct, 10) << dendl;
./librbd/ExclusiveLock.cc:180:  ldout(m_image_ctx.cct, 10) << dendl;
./librbd/ExclusiveLock.cc:189:    ldout(m_image_ctx.cct, 10) << ": peer nacked lock request" << dendl;
./librbd/ExclusiveLock.cc:203:  ldout(m_image_ctx.cct, 10) << ": r=" << r << dendl;
./librbd/ExclusiveLock.cc:253:  ldout(m_image_ctx.cct, 10) << dendl;
./librbd/ExclusiveLock.cc:265:  ldout(m_image_ctx.cct, 10) << ": r=" << r << dendl;
./librbd/ExclusiveLock.cc:290:  ldout(m_image_ctx.cct, 10) << dendl;
./librbd/ExclusiveLock.cc:303:  ldout(m_image_ctx.cct, 10) << ": r=" << r << " shutting_down="
./librbd/ExclusiveLock.cc:333:  ldout(m_image_ctx.cct, 10) << dendl;
./librbd/Watcher.cc:77:  ldout(cct, 10) << "id=" << notify_id << ", " << "handle=" << handle << dendl;
./librbd/Watcher.cc:81:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/Watcher.cc:105:  ldout(m_cct, 10) << dendl;
./librbd/Watcher.cc:119:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/Watcher.cc:153:  ldout(m_cct, 10) << dendl;
./librbd/Watcher.cc:158:      ldout(m_cct, 10) << "delaying unregister until register completed"
./librbd/Watcher.cc:184:  ldout(m_cct, 5) << "blocked=" << blocked << dendl;
./librbd/Watcher.cc:192:    ldout(m_cct, 5) << "blocked_count=" << m_blocked_count << dendl;
./librbd/Watcher.cc:201:  ldout(m_cct, 5) << "blocked_count=" << m_blocked_count << dendl;
./librbd/Watcher.cc:241:  ldout(m_cct, 10) << dendl;
./librbd/Watcher.cc:266:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/Watcher.cc:275:      ldout(m_cct, 10) << "image is closing, skip rewatch" << dendl;
./librbd/Watcher.cc:281:      ldout(m_cct, 5) << "object does not exist" << dendl;
./librbd/Watcher.cc:305:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ImageState.cc:43:    ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__ << dendl;
./librbd/ImageState.cc:49:	    ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__
./librbd/ImageState.cc:57:    ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__
./librbd/ImageState.cc:63:    ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__ << dendl;
./librbd/ImageState.cc:73:    ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__
./librbd/ImageState.cc:79:    ldout(m_cct, 20) << __func__ << ": watcher=" << watcher << dendl;
./librbd/ImageState.cc:91:    ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__ << ": handle="
./librbd/ImageState.cc:110:      ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__
./librbd/ImageState.cc:117:    ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__ << dendl;
./librbd/ImageState.cc:128:    ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__ << ": handle="
./librbd/ImageState.cc:143:    ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__ << ": handle="
./librbd/ImageState.cc:177:      ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__
./librbd/ImageState.cc:183:      ldout(m_cct, 20) << "ImageUpdateWatchers::" << __func__
./librbd/ImageState.cc:262:  ldout(cct, 20) << __func__ << dendl;
./librbd/ImageState.cc:287:  ldout(cct, 20) << __func__ << dendl;
./librbd/ImageState.cc:303:  ldout(cct, 20) << __func__ << ": refresh_seq = " << m_refresh_seq << ", "
./librbd/ImageState.cc:327:  ldout(cct, 20) << __func__ << dendl;
./librbd/ImageState.cc:386:  ldout(cct, 20) << __func__ << ": snap_id=" << snap_id << dendl;
./librbd/ImageState.cc:398:  ldout(cct, 10) << __func__ << dendl;
./librbd/ImageState.cc:415:  ldout(cct, 10) << __func__ << dendl;
./librbd/ImageState.cc:430:  ldout(cct, 20) << __func__ << dendl;
./librbd/ImageState.cc:434:  ldout(cct, 20) << __func__ << ": handle=" << *handle << dendl;
./librbd/ImageState.cc:441:  ldout(cct, 20) << __func__ << ": handle=" << handle << dendl;
./librbd/ImageState.cc:451:  ldout(cct, 20) << __func__ << dendl;
./librbd/ImageState.cc:459:  ldout(cct, 20) << __func__ << dendl;
./librbd/ImageState.cc:578:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/ImageState.cc:595:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/ImageState.cc:609:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/ImageState.cc:625:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/ImageState.cc:640:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/ImageState.cc:660:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/ImageState.cc:670:    ldout(cct, 5) << "incomplete refresh: not updating sequence" << dendl;
./librbd/ImageState.cc:690:  ldout(cct, 10) << this << " " << __func__ << ": "
./librbd/ImageState.cc:706:  ldout(cct, 10) << this << " " << __func__ << " r=" << r << dendl;
./librbd/ImageState.cc:719:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/internal.cc:147:    ldout(cct, 20) << "detect format of " << name << " : "
./librbd/internal.cc:519:    ldout(cct, 20) << "list " << &io_ctx << dendl;
./librbd/internal.cc:559:    ldout(cct, 20) << "children flatten " << ictx->name << dendl;
./librbd/internal.cc:635:    ldout(cct, 20) << "children list " << ictx->name << dendl;
./librbd/internal.cc:700:    ldout(ictx->cct, 20) << "get_snap_namespace " << ictx << " " << snap_name
./librbd/internal.cc:716:    ldout(ictx->cct, 20) << "snap_is_protected " << ictx << " " << snap_name
./librbd/internal.cc:739:    ldout(cct, 20) << __func__ << " "  << &io_ctx << " name = " << imgname
./librbd/internal.cc:746:    ldout(cct, 2) << "adding rbd image to directory..." << dendl;
./librbd/internal.cc:757:    ldout(cct, 2) << "creating rbd image..." << dendl;
./librbd/internal.cc:778:    ldout(cct, 2) << "done." << dendl;
./librbd/internal.cc:845:    ldout(cct, 10) << __func__ << " name=" << image_name << ", "
./librbd/internal.cc:966:    ldout(cct, 10) << __func__ << " "
./librbd/internal.cc:987:    ldout(cct, 20) << "rename " << &io_ctx << " " << srcname << " -> "
./librbd/internal.cc:1005:    ldout(ictx->cct, 20) << "info " << ictx << dendl;
./librbd/internal.cc:1129:    ldout(cct, 20) << __func__ << " " << ictx << " fd " << fd << " type" << type << dendl;
./librbd/internal.cc:1167:    ldout(cct, 20) << __func__ << ": ictx=" << ictx << ", "
./librbd/internal.cc:1216:    ldout(cct, 20) << __func__ << ": ictx=" << ictx << dendl;
./librbd/internal.cc:1244:    ldout(cct, 20) << __func__ << ": ictx=" << ictx << dendl;
./librbd/internal.cc:1273:    ldout(cct, 20) << __func__ << ": ictx=" << ictx << ", "
./librbd/internal.cc:1336:    ldout(cct, 20) << "remove " << &io_ctx << " "
./librbd/internal.cc:1355:    ldout(cct, 20) << "trash_move " << &io_ctx << " " << image_name
./librbd/internal.cc:1376:      ldout(cct, 10) << "cannot move v1 image to trash" << dendl;
./librbd/internal.cc:1429:    ldout(cct, 20) << __func__ << " " << &io_ctx << dendl;
./librbd/internal.cc:1450:    ldout(cct, 20) << "trash_list " << &io_ctx << dendl;
./librbd/internal.cc:1488:    ldout(cct, 20) << "trash_remove " << &io_ctx << " " << image_id
./librbd/internal.cc:1532:    ldout(cct, 20) << "trash_restore " << &io_ctx << " " << image_id << " "
./librbd/internal.cc:1547:      ldout(cct, 20) << "restoring image id " << image_id << " with name "
./librbd/internal.cc:1562:        ldout(cct, 2) << "an image with the same name already exists" << dendl;
./librbd/internal.cc:1569:      ldout(cct, 2) << "adding id object" << dendl;
./librbd/internal.cc:1581:    ldout(cct, 2) << "adding rbd image from v2 directory..." << dendl;
./librbd/internal.cc:1590:    ldout(cct, 2) << "removing image from trash..." << dendl;
./librbd/internal.cc:1611:    ldout(ictx->cct, 20) << "snap_list " << ictx << dendl;
./librbd/internal.cc:1633:    ldout(ictx->cct, 20) << "snap_exists " << ictx << " " << snap_name << dendl;
./librbd/internal.cc:1647:    ldout(ictx->cct, 20) << "snap_remove " << ictx << " " << snap_name << " flags: " << flags << dendl;
./librbd/internal.cc:1731:    ldout(cct, 20) << "copy " << src->name
./librbd/internal.cc:1980:    ldout(ictx->cct, 20) << "list_locks on image " << ictx << dendl;
./librbd/internal.cc:2010:    ldout(ictx->cct, 20) << "lock image " << ictx << " exclusive=" << exclusive
./librbd/internal.cc:2039:    ldout(ictx->cct, 20) << "unlock image " << ictx
./librbd/internal.cc:2062:    ldout(ictx->cct, 20) << "break_lock image " << ictx << " client='" << client
./librbd/internal.cc:2137:    ldout(ictx->cct, 20) << "read_iterate " << ictx << " off = " << off
./librbd/internal.cc:2224:    ldout(cct, 20) << "invalidate_cache " << ictx << dendl;
./librbd/internal.cc:2246:    ldout(cct, 20) << __func__ << " " << ictx << " numcomp = " << numcomp
./librbd/internal.cc:2261:    ldout(cct, 20) << "metadata_get " << ictx << " key=" << key << dendl;
./librbd/internal.cc:2274:    ldout(cct, 20) << "metadata_list " << ictx << dendl;
./librbd/internal.cc:2299:      ldout(ictx->cct, 20) << "C_RBD_Readahead on " << oid << ": "
./librbd/internal.cc:2334:      ldout(ictx->cct, 20) << "(readahead logical) " << readahead_offset << "~" << readahead_length << dendl;
./librbd/internal.cc:2340:	  ldout(ictx->cct, 20) << "(readahead) oid " << q->oid << " " << q->offset << "~" << q->length << dendl;
./librbd/ImageCtx.cc:234:    ldout(cct, 10) << "init_layout stripe_unit " << stripe_unit
./librbd/ImageCtx.cc:656:    ldout(cct, 10) << "prune_parent_extents image overlap " << overlap
./librbd/ImageCtx.cc:672:        ldout(cct, 20) << "flush async operations: " << on_finish << " "
./librbd/ImageCtx.cc:691:        ldout(cct, 10) << "canceling async requests: count="
./librbd/ImageCtx.cc:694:          ldout(cct, 10) << "canceling async request: " << req << dendl;
./librbd/ImageCtx.cc:707:    ldout(cct, 10) << "clear pending AioCompletion: count="
./librbd/ImageCtx.cc:737:    ldout(cct, 20) << __func__ << dendl;
./librbd/TrashWatcher.cc:38:  ldout(cct, 20) << dendl;
./librbd/TrashWatcher.cc:54:  ldout(cct, 20) << dendl;
./librbd/TrashWatcher.cc:69:  ldout(cct, 15) << "notify_id=" << notify_id << ", "
./librbd/TrashWatcher.cc:93:  ldout(cct, 20) << dendl;
./librbd/TrashWatcher.cc:102:  ldout(cct, 20) << dendl;
./librbd/ObjectMap.cc:108:  ldout(m_image_ctx.cct, 20) << "object_no=" << object_no << " r=" << exists
./librbd/ObjectMap.cc:231:  ldout(cct, 20) << dendl;
./librbd/ObjectMap.cc:245:    ldout(cct, 20) << "detaining object map update due to in-flight update: "
./librbd/ObjectMap.cc:255:  ldout(cct, 20) << "in-flight update cell: " << cell << dendl;
./librbd/ObjectMap.cc:268:  ldout(cct, 20) << "cell=" << cell << ", r=" << r << dendl;
./librbd/ObjectMap.cc:299:  ldout(cct, 20) << "start=" << start_object_no << ", "
./librbd/ObjectMap.cc:307:      ldout(cct, 20) << "skipping update of invalid object map" << dendl;
./librbd/ObjectMap.cc:320:      ldout(cct, 20) << "object map update not required" << dendl;
./librbd/managed_lock/ReacquireRequest.cc:46:  ldout(cct, 10) << dendl;
./librbd/managed_lock/ReacquireRequest.cc:64:  ldout(cct, 10) << ": r=" << r << dendl;
./librbd/managed_lock/ReacquireRequest.cc:67:    ldout(cct, 10) << ": OSD doesn't support updating lock" << dendl;
./librbd/managed_lock/GetLockerRequest.cc:41:  ldout(m_cct, 10) << dendl;
./librbd/managed_lock/GetLockerRequest.cc:57:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/GetLockerRequest.cc:76:    ldout(m_cct, 20) << "no lockers detected" << dendl;
./librbd/managed_lock/GetLockerRequest.cc:82:    ldout(m_cct, 5) <<"locked by external mechanism: tag=" << lock_tag << dendl;
./librbd/managed_lock/GetLockerRequest.cc:88:    ldout(m_cct, 5) << "incompatible shared lock type detected" << dendl;
./librbd/managed_lock/GetLockerRequest.cc:92:    ldout(m_cct, 5) << "incompatible exclusive lock type detected" << dendl;
./librbd/managed_lock/GetLockerRequest.cc:100:    ldout(m_cct, 5) << "locked by external mechanism: "
./librbd/managed_lock/GetLockerRequest.cc:110:    ldout(m_cct, 20) << "no valid lockers detected" << dendl;
./librbd/managed_lock/GetLockerRequest.cc:115:  ldout(m_cct, 10) << "retrieved exclusive locker: "
./librbd/managed_lock/GetLockerRequest.cc:122:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/ReleaseRequest.cc:58:  ldout(cct, 10) << "entity=client." << m_ioctx.get_instance_id() << ", "
./librbd/managed_lock/ReleaseRequest.cc:75:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/BreakRequest.cc:69:  ldout(m_cct, 10) << dendl;
./librbd/managed_lock/BreakRequest.cc:85:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/BreakRequest.cc:99:    ldout(m_cct, 20) << "watcher=["
./librbd/managed_lock/BreakRequest.cc:106:      ldout(m_cct, 10) << "lock owner is still alive" << dendl;
./librbd/managed_lock/BreakRequest.cc:121:  ldout(m_cct, 10) << dendl;
./librbd/managed_lock/BreakRequest.cc:133:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/BreakRequest.cc:136:    ldout(m_cct, 5) << "no lock owner" << dendl;
./librbd/managed_lock/BreakRequest.cc:148:    ldout(m_cct, 5) << "no longer lock owner" << dendl;
./librbd/managed_lock/BreakRequest.cc:164:  ldout(m_cct, 10) << "local entity=" << entity_name << ", "
./librbd/managed_lock/BreakRequest.cc:184:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/BreakRequest.cc:197:  ldout(m_cct, 10) << dendl;
./librbd/managed_lock/BreakRequest.cc:213:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/BreakRequest.cc:226:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/AcquireRequest.cc:75:  ldout(m_cct, 10) << dendl;
./librbd/managed_lock/AcquireRequest.cc:86:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/AcquireRequest.cc:89:    ldout(m_cct, 20) << "no lockers detected" << dendl;
./librbd/managed_lock/AcquireRequest.cc:92:    ldout(m_cct, 5) << "incompatible lock detected" << dendl;
./librbd/managed_lock/AcquireRequest.cc:106:  ldout(m_cct, 10) << "entity=client." << m_ioctx.get_instance_id() << ", "
./librbd/managed_lock/AcquireRequest.cc:124:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/AcquireRequest.cc:130:    ldout(m_cct, 5) << "already locked, refreshing locker" << dendl;
./librbd/managed_lock/AcquireRequest.cc:144:  ldout(m_cct, 10) << dendl;
./librbd/managed_lock/AcquireRequest.cc:156:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/managed_lock/AcquireRequest.cc:159:    ldout(m_cct, 5) << "lock owner is still alive" << dendl;
./librbd/api/Group.cc:129:  ldout(cct, 20) << "listing images in group name "
./librbd/api/Group.cc:167:  ldout(cct, 20) << "removing image " << image_id
./librbd/api/Group.cc:222:  ldout(cct, 20) << "Removing snapshots" << dendl;
./librbd/api/Group.cc:229:      ldout(cct, 1) << "Failed to create io context for image" << dendl;
./librbd/api/Group.cc:257:  ldout(cct, 20) << "Opened participating images. " <<
./librbd/api/Group.cc:271:      ldout(cct, 20) << "removing individual snapshot from image " << ictx->name
./librbd/api/Group.cc:296:  ldout(cct, 20) << "Removed images snapshots removing snapshot record."
./librbd/api/Group.cc:324:  ldout(cct, 20) << "io_ctx=" << &group_ioctx
./librbd/api/Group.cc:339:  ldout(cct, 20) << "removing image from group name " << group_name
./librbd/api/Group.cc:352:  ldout(cct, 2) << "adding group to directory..." << dendl;
./librbd/api/Group.cc:388:  ldout(cct, 20) << "group_remove " << &io_ctx << " " << group_name << dendl;
./librbd/api/Group.cc:457:  ldout(cct, 20) << "io_ctx=" << &io_ctx << dendl;
./librbd/api/Group.cc:495:  ldout(cct, 20) << "io_ctx=" << &group_ioctx
./librbd/api/Group.cc:512:  ldout(cct, 20) << "adding image to group name " << group_name
./librbd/api/Group.cc:527:  ldout(cct, 20) << "adding image " << image_name
./librbd/api/Group.cc:569:  ldout(cct, 20) << "io_ctx=" << &group_ioctx
./librbd/api/Group.cc:584:  ldout(cct, 20) << "removing image from group name " << group_name
./librbd/api/Group.cc:607:  ldout(cct, 20) << "io_ctx=" << &group_ioctx
./librbd/api/Group.cc:643:  ldout(cct, 20) << "group_rename " << &io_ctx << " " << src_name
./librbd/api/Group.cc:727:  ldout(cct, 20) << "Found " << image_count << " images in group" << dendl;
./librbd/api/Group.cc:763:      ldout(cct, 1) << "Failed to create io context for image" << dendl;
./librbd/api/Group.cc:766:    ldout(cct, 20) << "Opening image with id " << image.spec.image_id << dendl;
./librbd/api/Group.cc:778:  ldout(cct, 20) << "Issued open request waiting for the completion" << dendl;
./librbd/api/Group.cc:782:    ldout(cct, 20) << "Waiting for completion on on_finish: " <<
./librbd/api/Group.cc:796:  ldout(cct, 20) << "Requesting exclusive locks for images" << dendl;
./librbd/api/Group.cc:855:	ldout(cct, 20) << "Couldn't find created snapshot with namespace: "
./librbd/api/Group.cc:884:    ldout(cct, 20) << "Removing individual snapshot with name: " <<
./librbd/api/DiffIterate.cc:95:      ldout(cct, 20) << "object " << m_oid << ": list_snaps complete" << dendl;
./librbd/api/DiffIterate.cc:98:      ldout(cct, 20) << "object " << m_oid << ": list_snaps (not found)"
./librbd/api/DiffIterate.cc:103:      ldout(cct, 20) << "object " << m_oid << ": list_snaps failed: "
./librbd/api/DiffIterate.cc:143:      ldout(cct, 1) << "object " << m_oid << ": need to provide full object"
./librbd/api/DiffIterate.cc:146:    ldout(cct, 20) << "  diff " << diff << " end_exists=" << end_exists
./librbd/api/DiffIterate.cc:165:      ldout(cct, 20) << "diff_iterate object " << m_oid << " extent "
./librbd/api/DiffIterate.cc:175:        ldout(cct, 20) << " opos " << opos
./librbd/api/DiffIterate.cc:182:          ldout(cct, 20) << "   overlap extent " << s.get_start() << "~"
./librbd/api/DiffIterate.cc:206:          ldout(m_cct, 20) << " reporting parent overlap " << o << dendl;
./librbd/api/DiffIterate.cc:238:  ldout(ictx->cct, 20) << "diff_iterate " << ictx << " off = " << off
./librbd/api/DiffIterate.cc:315:        ldout(cct, 5) << "fast diff disabled" << dendl;
./librbd/api/DiffIterate.cc:317:        ldout(cct, 5) << "fast diff enabled" << dendl;
./librbd/api/DiffIterate.cc:326:  ldout(cct, 5) << "diff_iterate from " << from_snap_id << " to "
./librbd/api/DiffIterate.cc:340:      ldout(cct, 10) << " first getting parent diff" << dendl;
./librbd/api/DiffIterate.cc:371:      ldout(cct, 20) << "object " << p->first << dendl;
./librbd/api/DiffIterate.cc:454:      ldout(cct, 1) << "diff_object_map: cannot perform fast diff on invalid "
./librbd/api/DiffIterate.cc:468:    ldout(cct, 20) << "diff_object_map: loaded object map " << oid << dendl;
./librbd/api/DiffIterate.cc:473:      ldout(cct, 1) << "diff_object_map: object map too small: "
./librbd/api/DiffIterate.cc:487:      ldout(cct, 20) << __func__ << ": object state: " << i << " "
./librbd/api/DiffIterate.cc:501:    ldout(cct, 20) << "diff_object_map: computed overlap diffs" << dendl;
./librbd/api/DiffIterate.cc:506:        ldout(cct, 20) << __func__ << ": object state: " << i << " "
./librbd/api/DiffIterate.cc:515:    ldout(cct, 20) << "diff_object_map: computed resize diffs" << dendl;
./librbd/api/Image.cc:28:  ldout(cct, 20) << "image_ctx=" << ictx << dendl;
./librbd/api/Image.cc:43:  ldout(cct, 20) << "io_ctx=" << &io_ctx << dendl;
./librbd/api/Image.cc:100:      ldout(cct, 1) << "pool " << it->second << " no longer exists" << dendl;
./librbd/api/Image.cc:115:      ldout(cct, 1) << "pool " << it->second << " no longer exists" << dendl;
./librbd/api/Image.cc:152:      ldout(cct, 1) << "pool " << child_image.pool_id << " no longer exists"
./librbd/api/Image.cc:169:  ldout(cct, 20) << src->name
./librbd/api/Image.cc:341:  ldout(ictx->cct, 20) << "snap_set " << ictx << " snap = "
./librbd/api/Image.cc:364:  ldout(ictx->cct, 20) << "snap_set " << ictx << " "
./librbd/api/Mirror.cc:141:  ldout(cct, 20) << "ictx=" << ictx << dendl;
./librbd/api/Mirror.cc:206:  ldout(cct, 20) << "ictx=" << ictx << dendl;
./librbd/api/Mirror.cc:233:    ldout(cct, 20) << "ignoring disable command: mirroring is not enabled for "
./librbd/api/Mirror.cc:237:    ldout(cct, 5) << "mirroring not supported by OSD" << dendl;
./librbd/api/Mirror.cc:340:  ldout(cct, 20) << "ictx=" << ictx << ", "
./librbd/api/Mirror.cc:365:  ldout(cct, 20) << "ictx=" << ictx << dendl;
./librbd/api/Mirror.cc:374:  ldout(cct, 20) << "ictx=" << ictx << dendl;
./librbd/api/Mirror.cc:413:  ldout(cct, 20) << "ictx=" << ictx << dendl;
./librbd/api/Mirror.cc:438:  ldout(cct, 20) << "ictx=" << ictx << dendl;
./librbd/api/Mirror.cc:463:  ldout(cct, 20) << dendl;
./librbd/api/Mirror.cc:492:  ldout(cct, 20) << dendl;
./librbd/api/Mirror.cc:668:  ldout(cct, 20) << "name=" << cluster_name << ", "
./librbd/api/Mirror.cc:685:      ldout(cct, 5) << "duplicate UUID detected, retrying" << dendl;
./librbd/api/Mirror.cc:698:  ldout(cct, 20) << "uuid=" << uuid << dendl;
./librbd/api/Mirror.cc:713:  ldout(cct, 20) << dendl;
./librbd/api/Mirror.cc:738:  ldout(cct, 20) << "uuid=" << uuid << ", "
./librbd/api/Mirror.cc:755:  ldout(cct, 20) << "uuid=" << uuid << ", "
./librbd/Journal.cc:83:    ldout(cct, 20) << this << " C_IsTagOwner::" << __func__ << ": r=" << r
./librbd/Journal.cc:168:    ldout(cct, 20) << __func__ << dendl;
./librbd/Journal.cc:178:    ldout(cct, 20) << __func__ << ": r=" << r << dendl;
./librbd/Journal.cc:210:    ldout(cct, 20) << __func__ << dendl;
./librbd/Journal.cc:222:    ldout(cct, 20) << __func__ << ": r=" << r << dendl;
./librbd/Journal.cc:239:  ldout(cct, 20) << __func__ << dendl;
./librbd/Journal.cc:337:  ldout(cct, 5) << this << ": ictx=" << &m_image_ctx << dendl;
./librbd/Journal.cc:373:  ldout(cct, 5) << __func__ << ": image=" << image_id << dendl;
./librbd/Journal.cc:392:  ldout(cct, 5) << __func__ << ": image=" << image_id << dendl;
./librbd/Journal.cc:409:  ldout(cct, 5) << __func__ << ": image=" << image_id << dendl;
./librbd/Journal.cc:436:  ldout(cct, 20) << __func__ << dendl;
./librbd/Journal.cc:450:  ldout(cct, 20) << __func__ << dendl;
./librbd/Journal.cc:460:  ldout(cct, 20) << __func__ << dendl;
./librbd/Journal.cc:505:  ldout(cct, 20) << __func__ << dendl;
./librbd/Journal.cc:515:  ldout(cct, 20) << __func__ << dendl;
./librbd/Journal.cc:565:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:582:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:651:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:687:  ldout(cct, 20) << this << " " << __func__ << ":  mirror_uuid=" << mirror_uuid
./librbd/Journal.cc:709:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:788:  ldout(cct, 20) << this << " " << __func__ << ": "
./librbd/Journal.cc:808:  ldout(cct, 20) << this << " " << __func__ << ": tid=" << tid << ", "
./librbd/Journal.cc:825:  ldout(cct, 20) << this << " " << __func__ << ": tid=" << tid << ", "
./librbd/Journal.cc:849:    ldout(cct, 20) << this << " " << __func__ << ": "
./librbd/Journal.cc:886:  ldout(cct, 10) << this << " " << __func__ << ": "
./librbd/Journal.cc:894:  ldout(cct, 10) << this << " " << __func__ << ": op_tid=" << op_tid << ", "
./librbd/Journal.cc:926:  ldout(cct, 10) << this << " " << __func__ << ": op_tid=" << op_tid << dendl;
./librbd/Journal.cc:938:  ldout(cct, 20) << this << " " << __func__ << ": tid=" << tid << ", "
./librbd/Journal.cc:955:  ldout(cct, 20) << this << " " << __func__ << ": tid=" << tid << ", "
./librbd/Journal.cc:974:    ldout(cct, 20) << this << " " << __func__ << ": "
./librbd/Journal.cc:989:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:1011:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:1037:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:1057:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:1090:  ldout(cct, 20) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/Journal.cc:1115:  ldout(cct, 20) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/Journal.cc:1138:  ldout(cct, 20) << this << " " << __func__ << ": tid=" << it->first << " "
./librbd/Journal.cc:1178:  ldout(cct, 20) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/Journal.cc:1193:  ldout(cct, 20) << this << " " << __func__ << ": "
./librbd/Journal.cc:1212:    ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:1251:    ldout(cct, 20) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/Journal.cc:1262:      ldout(cct, 20) << this << " handle_replay_complete: "
./librbd/Journal.cc:1284:      ldout(cct, 20) << this << " handle_replay_complete: "
./librbd/Journal.cc:1295:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:1315:  ldout(cct, 20) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/Journal.cc:1336:          ldout(cct, 20) << this << " handle_replay_process_safe: "
./librbd/Journal.cc:1365:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:1382:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:1404:  ldout(cct, 20) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/Journal.cc:1415:  ldout(cct, 20) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/Journal.cc:1439:  ldout(cct, 20) << this << " " << __func__ << ": r=" << r << ", "
./librbd/Journal.cc:1474:  ldout(cct, 20) << this << " " << __func__ << ": "
./librbd/Journal.cc:1490:  ldout(cct, 20) << this << " " << __func__ << ": r=" << r << ", "
./librbd/Journal.cc:1523:  ldout(cct, 20) << this << " " << __func__ << ": new state=" << state << dendl;
./librbd/Journal.cc:1565:  ldout(cct, 20) << this << " " << __func__ << ": on_state=" << on_state
./librbd/Journal.cc:1579:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/Journal.cc:1645:    ldout(cct, 20) << this << " " << __func__ << ": primary image" << dendl;
./librbd/Journal.cc:1648:    ldout(cct, 20) << this << " " << __func__ << ": no listeners" << dendl;
./librbd/Journal.cc:1653:  ldout(cct, 20) << this << " " << __func__ << ": "
./librbd/Journal.cc:1689:  ldout(cct, 20) << this << " " << __func__ << ": "
./librbd/LibrbdWriteback.cc:60:      ldout(m_cct, 20) << "aio_cb completing " << dendl;
./librbd/LibrbdWriteback.cc:65:      ldout(m_cct, 20) << "aio_cb finished" << dendl;
./librbd/LibrbdWriteback.cc:80:      ldout(m_cct, 20) << "C_OrderedWrite completing " << m_result << dendl;
./librbd/LibrbdWriteback.cc:88:      ldout(m_cct, 20) << "C_OrderedWrite finished " << m_result << dendl;
./librbd/LibrbdWriteback.cc:175:    ldout(m_ictx->cct, 10) << "may_copy_on_write " << oid << " " << read_off
./librbd/LibrbdWriteback.cc:201:    ldout(m_ictx->cct, 20) << "write will wait for result " << result << dendl;
./librbd/LibrbdWriteback.cc:226:    ldout(m_ictx->cct, 20) << __func__ << ": " << oid << " "
./librbd/LibrbdWriteback.cc:259:    ldout(m_ictx->cct, 20) << "complete_writes() oid " << oid << dendl;
./librbd/LibrbdWriteback.cc:276:      ldout(m_ictx->cct, 20) << "complete_writes() completing " << result
./librbd/ManagedLock.cc:122:  ldout(m_cct, 20) << "=" << lock_owner << dendl;
./librbd/ManagedLock.cc:128:  ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:143:      ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:162:      ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:181:      ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:199:      ldout(m_cct, 10) << "woke up waiting acquire" << dendl;
./librbd/ManagedLock.cc:210:      ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:225:  ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:247:  ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:272:  ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:287:      ldout(m_cct, 5) << "client is not lock owner -- client blacklisted"
./librbd/ManagedLock.cc:290:      ldout(m_cct, 5) << "client is not lock owner -- no lock detected"
./librbd/ManagedLock.cc:293:      ldout(m_cct, 5) << "client is not lock owner -- owned by different client"
./librbd/ManagedLock.cc:459:  ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:478:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:496:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:499:    ldout(m_cct, 5) << "unable to acquire exclusive lock" << dendl;
./librbd/ManagedLock.cc:504:    ldout(m_cct, 5) << "successfully acquired exclusive lock" << dendl;
./librbd/ManagedLock.cc:517:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:524:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:539:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:572:    ldout(m_cct, 10) << "skipping reacquire since cookie still valid"
./librbd/ManagedLock.cc:580:  ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:597:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:604:      ldout(m_cct, 10) << "updating lock is not supported" << dendl;
./librbd/ManagedLock.cc:650:  ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:661:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:684:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:703:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:711:  ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:732:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:739:  ldout(m_cct, 10) << dendl;
./librbd/ManagedLock.cc:751:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:775:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:782:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/ManagedLock.cc:793:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/DeepCopyRequest.cc:66:  ldout(m_cct, 20) << dendl;
./librbd/DeepCopyRequest.cc:88:  ldout(m_cct, 20) << dendl;
./librbd/DeepCopyRequest.cc:103:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/DeepCopyRequest.cc:115:    ldout(m_cct, 10) << "snapshot copy canceled" << dendl;
./librbd/DeepCopyRequest.cc:137:  ldout(m_cct, 20) << dendl;
./librbd/DeepCopyRequest.cc:152:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/DeepCopyRequest.cc:164:    ldout(m_cct, 10) << "image copy canceled" << dendl;
./librbd/DeepCopyRequest.cc:197:  ldout(m_cct, 20) << dendl;
./librbd/DeepCopyRequest.cc:226:  ldout(m_cct, 20) << dendl;
./librbd/DeepCopyRequest.cc:247:  ldout(m_cct, 20) << dendl;
./librbd/DeepCopyRequest.cc:259:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/DeepCopyRequest.cc:273:  ldout(m_cct, 20) << dendl;
./librbd/DeepCopyRequest.cc:284:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/DeepCopyRequest.cc:318:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/mirror/DisableRequest.cc:42:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/DisableRequest.cc:59:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/DisableRequest.cc:68:      ldout(cct, 20) << this << " " << __func__
./librbd/mirror/DisableRequest.cc:72:      ldout(cct, 5) << this << " " << __func__
./librbd/mirror/DisableRequest.cc:88:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/DisableRequest.cc:100:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/DisableRequest.cc:122:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/DisableRequest.cc:141:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/DisableRequest.cc:156:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/DisableRequest.cc:170:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/DisableRequest.cc:190:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/DisableRequest.cc:205:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/DisableRequest.cc:219:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/DisableRequest.cc:234:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/DisableRequest.cc:306:  ldout(cct, 10) << this << " " << __func__ << ": client_id=" << client_id
./librbd/mirror/DisableRequest.cc:330:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/DisableRequest.cc:355:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/DisableRequest.cc:383:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/DisableRequest.cc:411:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/DisableRequest.cc:428:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/DisableRequest.cc:440:  ldout(cct, 20) << this << " " << __func__
./librbd/mirror/DisableRequest.cc:450:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/DisableRequest.cc:465:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/GetStatusRequest.cc:36:  ldout(cct, 20) << dendl;
./librbd/mirror/GetStatusRequest.cc:48:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/GetStatusRequest.cc:66:  ldout(cct, 20) << dendl;
./librbd/mirror/GetStatusRequest.cc:82:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/GetStatusRequest.cc:103:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/PromoteRequest.cc:32:  ldout(cct, 20) << dendl;
./librbd/mirror/PromoteRequest.cc:44:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/PromoteRequest.cc:71:  ldout(cct, 20) << dendl;
./librbd/mirror/PromoteRequest.cc:81:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/PromoteRequest.cc:94:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/EnableRequest.cc:41:  ldout(m_cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/EnableRequest.cc:57:  ldout(m_cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/EnableRequest.cc:66:      ldout(m_cct, 10) << this << " " << __func__
./librbd/mirror/EnableRequest.cc:101:  ldout(m_cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/EnableRequest.cc:112:  ldout(m_cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/EnableRequest.cc:132:  ldout(m_cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/EnableRequest.cc:148:  ldout(m_cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/EnableRequest.cc:162:  ldout(m_cct, 10) << this << " " << __func__ << dendl;
./librbd/mirror/EnableRequest.cc:176:  ldout(m_cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/mirror/DemoteRequest.cc:33:  ldout(cct, 20) << dendl;
./librbd/mirror/DemoteRequest.cc:45:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/DemoteRequest.cc:88:  ldout(cct, 20) << dendl;
./librbd/mirror/DemoteRequest.cc:99:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/DemoteRequest.cc:123:  ldout(cct, 20) << dendl;
./librbd/mirror/DemoteRequest.cc:133:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/DemoteRequest.cc:146:  ldout(cct, 20) << dendl;
./librbd/mirror/DemoteRequest.cc:164:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/DemoteRequest.cc:188:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/GetInfoRequest.cc:37:  ldout(cct, 20) << dendl;
./librbd/mirror/GetInfoRequest.cc:47:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/GetInfoRequest.cc:61:  ldout(cct, 20) << dendl;
./librbd/mirror/GetInfoRequest.cc:76:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/GetInfoRequest.cc:87:    ldout(cct, 20) << "mirroring is disabled" << dendl;
./librbd/mirror/GetInfoRequest.cc:103:  ldout(cct, 20) << dendl;
./librbd/mirror/GetInfoRequest.cc:114:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/mirror/GetInfoRequest.cc:135:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/librbd.cc:94:    ldout(cct, 20) << "C_AioComplete::finish: r=" << r << dendl;
./librbd/librbd.cc:114:    ldout(ictx->cct, 20) << "C_OpenComplete::finish: r=" << r << dendl;
./librbd/librbd.cc:135:    ldout(ictx->cct, 20) << "C_OpenAfterCloseComplete::finish: r=" << r
./librbd/librbd.cc:1897:    ldout(ictx->cct, 10) << "Image::aio_read() buf=" << (void *)bl.c_str() << "~"
./librbd/librbd.cc:1911:    ldout(ictx->cct, 10) << "Image::aio_read() buf=" << (void *)bl.c_str() << "~"
./librbd/librbd.cc:3747:  ldout(ictx->cct, 20) << "list_lockers r = " << r << " lockers.size() = " << lockers.size() << dendl;
./librbd/watcher/RewatchRequest.cc:41:  ldout(cct, 10) << dendl;
./librbd/watcher/RewatchRequest.cc:55:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/watcher/RewatchRequest.cc:69:  ldout(cct, 10) << dendl;
./librbd/watcher/RewatchRequest.cc:80:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/watcher/RewatchRequest.cc:98:  ldout(cct, 10) << "r=" << r << dendl;
./librbd/watcher/Notifier.cc:67:    ldout(m_cct, 20) << "pending=" << m_pending_aio_notifies << dendl;
./librbd/watcher/Notifier.cc:78:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/watcher/Notifier.cc:84:  ldout(m_cct, 20) << "pending=" << m_pending_aio_notifies << dendl;
./librbd/trash/MoveRequest.cc:31:  ldout(m_cct, 10) << dendl;
./librbd/trash/MoveRequest.cc:45:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/trash/MoveRequest.cc:48:    ldout(m_cct, 10) << "previous unfinished deferred remove for image: "
./librbd/trash/MoveRequest.cc:62:  ldout(m_cct, 10) << dendl;
./librbd/trash/MoveRequest.cc:74:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/trash/MoveRequest.cc:88:  ldout(m_cct, 10) << dendl;
./librbd/trash/MoveRequest.cc:103:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/trash/MoveRequest.cc:115:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/object_map/CreateRequest.cc:56:  ldout(cct, 20) << __func__ << dendl;
./librbd/object_map/CreateRequest.cc:82:  ldout(cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/object_map/SnapshotRemoveRequest.cc:68:  ldout(cct, 5) << this << " " << __func__ << ": state=" << m_state << ", "
./librbd/object_map/SnapshotRemoveRequest.cc:116:  ldout(cct, 5) << this << " " << __func__ << ": snap_oid=" << snap_oid
./librbd/object_map/SnapshotRemoveRequest.cc:133:  ldout(cct, 5) << this << " " << __func__ << ": oid=" << oid << dendl;
./librbd/object_map/SnapshotRemoveRequest.cc:153:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/object_map/SnapshotRemoveRequest.cc:165:  ldout(cct, 5) << this << " " << __func__ << ": oid=" << oid << dendl;
./librbd/object_map/SnapshotRemoveRequest.cc:196:    ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/object_map/UpdateRequest.cc:45:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", oid=" << oid << ", "
./librbd/object_map/UpdateRequest.cc:73:  ldout(m_image_ctx.cct, 20) << "r=" << r << dendl;
./librbd/object_map/UpdateRequest.cc:98:    ldout(m_image_ctx.cct, 20) << dendl;
./librbd/object_map/RemoveRequest.cc:36:  ldout(cct, 20) << __func__ << dendl;
./librbd/object_map/RemoveRequest.cc:64:  ldout(cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/object_map/RefreshRequest.cc:45:  ldout(cct, 20) << this << " " << __func__ << ": "
./librbd/object_map/RefreshRequest.cc:75:  ldout(cct, 10) << this << " " << __func__ << ": oid=" << oid << dendl;
./librbd/object_map/RefreshRequest.cc:88:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/object_map/RefreshRequest.cc:99:  ldout(cct, 10) << this << " " << __func__ << ": oid=" << oid << dendl;
./librbd/object_map/RefreshRequest.cc:116:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *ret_val << dendl;
./librbd/object_map/RefreshRequest.cc:146:  ldout(cct, 20) << "refreshed object map: num_objs="
./librbd/object_map/RefreshRequest.cc:150:    ldout(cct, 1) << "object map larger than current object count: "
./librbd/object_map/RefreshRequest.cc:162:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/object_map/RefreshRequest.cc:182:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *ret_val << dendl;
./librbd/object_map/RefreshRequest.cc:192:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/object_map/RefreshRequest.cc:212:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *ret_val << dendl;
./librbd/object_map/RefreshRequest.cc:223:  ldout(cct, 10) << this << " " << __func__ << ": oid=" << oid << dendl;
./librbd/object_map/RefreshRequest.cc:245:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *ret_val << dendl;
./librbd/object_map/RefreshRequest.cc:259:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/object_map/RefreshRequest.cc:276:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *ret_val << dendl;
./librbd/object_map/SnapshotCreateRequest.cc:47:  ldout(cct, 5) << this << " " << __func__ << ": state=" << m_state << ", "
./librbd/object_map/SnapshotCreateRequest.cc:83:  ldout(cct, 5) << this << " " << __func__ << ": oid=" << oid << dendl;
./librbd/object_map/SnapshotCreateRequest.cc:100:  ldout(cct, 5) << this << " " << __func__ << ": snap_oid=" << snap_oid
./librbd/object_map/SnapshotCreateRequest.cc:121:  ldout(cct, 5) << this << " " << __func__ << ": oid=" << oid << dendl;
./librbd/object_map/UnlockRequest.cc:35:  ldout(cct, 10) << this << " " << __func__ << ": oid=" << oid << dendl;
./librbd/object_map/UnlockRequest.cc:51:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *ret_val << dendl;
./librbd/object_map/SnapshotRollbackRequest.cc:48:  ldout(cct, 5) << this << " " << __func__ << ": state=" << m_state << ", "
./librbd/object_map/SnapshotRollbackRequest.cc:82:  ldout(cct, 5) << this << " " << __func__ << ": snap_oid=" << snap_oid
./librbd/object_map/SnapshotRollbackRequest.cc:102:  ldout(cct, 5) << this << " " << __func__ << ": snap_oid=" << snap_oid
./librbd/object_map/SnapshotRollbackRequest.cc:121:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/object_map/Request.cc:20:  ldout(cct, 20) << this << " should_complete: r=" << r << dendl;
./librbd/object_map/Request.cc:35:    ldout(cct, 20) << "INVALIDATE" << dendl;
./librbd/object_map/LockRequest.cc:35:  ldout(cct, 10) << this << " " << __func__ << ": oid=" << oid << dendl;
./librbd/object_map/LockRequest.cc:52:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *ret_val << dendl;
./librbd/object_map/LockRequest.cc:75:  ldout(cct, 10) << this << " " << __func__ << ": oid=" << oid << dendl;
./librbd/object_map/LockRequest.cc:91:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *ret_val << dendl;
./librbd/object_map/LockRequest.cc:120:  ldout(cct, 10) << this << " " << __func__ << ": oid=" << oid << ", "
./librbd/object_map/LockRequest.cc:140:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *ret_val << dendl;
./librbd/object_map/ResizeRequest.cc:39:  ldout(cct, 5) << this << " resizing on-disk object map: "
./librbd/object_map/ResizeRequest.cc:59:  ldout(cct, 5) << this << " resizing in-memory object map: "
./librbd/deep_copy/SnapshotCopyRequest.cc:90:  ldout(m_cct, 20) << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:136:      ldout(m_cct, 20) << "m_src_image_ctx->is_snap_unprotected("
./librbd/deep_copy/SnapshotCopyRequest.cc:172:  ldout(m_cct, 20) << "snap_name=" << m_snap_name << ", "
./librbd/deep_copy/SnapshotCopyRequest.cc:193:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:267:  ldout(m_cct, 20) << ""
./librbd/deep_copy/SnapshotCopyRequest.cc:289:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:362:  ldout(m_cct, 20) << "snap_name=" << m_snap_name << ", "
./librbd/deep_copy/SnapshotCopyRequest.cc:390:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:409:  ldout(m_cct, 20) << "mapping source snap id " << m_prev_snap_id << " to "
./librbd/deep_copy/SnapshotCopyRequest.cc:475:  ldout(m_cct, 20) << "snap_name=" << m_snap_name << ", "
./librbd/deep_copy/SnapshotCopyRequest.cc:496:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:518:  ldout(m_cct, 20) << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:539:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:558:  ldout(m_cct, 10) << "snapshot copy canceled" << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:565:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SnapshotCopyRequest.cc:605:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/MetadataCopyRequest.cc:40:  ldout(m_cct, 20) << "start_key=" << m_last_metadata_key << dendl;
./librbd/deep_copy/MetadataCopyRequest.cc:56:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/MetadataCopyRequest.cc:82:  ldout(m_cct, 20) << "count=" << metadata.size() << dendl;
./librbd/deep_copy/MetadataCopyRequest.cc:97:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/MetadataCopyRequest.cc:115:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SnapshotCreateRequest.cc:45:  ldout(m_cct, 20) << dendl;
./librbd/deep_copy/SnapshotCreateRequest.cc:56:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SnapshotCreateRequest.cc:69:  ldout(m_cct, 20) << "snap_name=" << m_snap_name << dendl;
./librbd/deep_copy/SnapshotCreateRequest.cc:91:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SnapshotCreateRequest.cc:126:  ldout(m_cct, 20) << "object_map_oid=" << object_map_oid << ", "
./librbd/deep_copy/SnapshotCreateRequest.cc:153:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SnapshotCreateRequest.cc:176:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/ImageCopyRequest.cc:54:  ldout(m_cct, 20) << dendl;
./librbd/deep_copy/ImageCopyRequest.cc:75:  ldout(m_cct, 20) << "start_object=" << m_object_no << ", "
./librbd/deep_copy/ImageCopyRequest.cc:102:    ldout(m_cct, 10) << "image copy canceled" << dendl;
./librbd/deep_copy/ImageCopyRequest.cc:112:  ldout(m_cct, 20) << "object_num=" << ono << dendl;
./librbd/deep_copy/ImageCopyRequest.cc:127:  ldout(m_cct, 20) << "object_no=" << object_no << ", r=" << r << dendl;
./librbd/deep_copy/ImageCopyRequest.cc:167:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SetHeadRequest.cc:47:  ldout(m_cct, 20) << dendl;
./librbd/deep_copy/SetHeadRequest.cc:76:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SetHeadRequest.cc:104:  ldout(m_cct, 20) << dendl;
./librbd/deep_copy/SetHeadRequest.cc:128:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SetHeadRequest.cc:157:  ldout(m_cct, 20) << dendl;
./librbd/deep_copy/SetHeadRequest.cc:181:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/SetHeadRequest.cc:210:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:54:  ldout(m_cct, 20) << "dst_oid=" << m_dst_oid << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:70:  ldout(m_cct, 20) << "src_oid=" << m_src_oid << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:93:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:113:    ldout(m_cct, 20) << "retrying using updated snap set" << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:162:      ldout(m_cct, 20) << "src_snap_seq=" << src_snap_seq << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:165:    ldout(m_cct, 20) << "read op: " << copy_op.src_offset << "~"
./librbd/deep_copy/ObjectCopyRequest.cc:183:  ldout(m_cct, 20) << "read " << m_src_oid << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:192:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:195:    ldout(m_cct, 5) << "object missing when forced to read whole object"
./librbd/deep_copy/ObjectCopyRequest.cc:204:    ldout(m_cct, 5) << "object missing potentially due to removed snapshot"
./librbd/deep_copy/ObjectCopyRequest.cc:244:  ldout(m_cct, 20) << "dst_snap_seq=" << dst_snap_seq << ", "
./librbd/deep_copy/ObjectCopyRequest.cc:255:        ldout(m_cct, 20) << "write op: " << e.first << "~" << e.second
./librbd/deep_copy/ObjectCopyRequest.cc:266:      ldout(m_cct, 20) << "zero op: " << copy_op.dst_offset << "~"
./librbd/deep_copy/ObjectCopyRequest.cc:271:      ldout(m_cct, 20) << "trunc op: " << copy_op.dst_offset << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:275:      ldout(m_cct, 20) << "remove op" << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:312:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:360:  ldout(m_cct, 20) << "dst_snap_id=" << dst_snap_id << ", object_state="
./librbd/deep_copy/ObjectCopyRequest.cc:392:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:464:  ldout(m_cct, 20) << m_src_object_extents.size() << " src extents" << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:492:      ldout(m_cct, 1) << "need to read full object" << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:503:    ldout(m_cct, 20) << "start_src_snap_id=" << start_src_snap_id << ", "
./librbd/deep_copy/ObjectCopyRequest.cc:520:        ldout(m_cct, 20) << "clearing truncate diff: " << trunc << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:554:            ldout(m_cct, 20) << "extent " << e.offset << "~" << e.length
./librbd/deep_copy/ObjectCopyRequest.cc:565:        ldout(m_cct, 20) << "src_object_extent: " << e.offset << "~" << e.length
./librbd/deep_copy/ObjectCopyRequest.cc:575:            ldout(m_cct, 20) << "read/write op: " << it.get_start() << "~"
./librbd/deep_copy/ObjectCopyRequest.cc:597:  ldout(m_cct, 20) << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:612:          ldout(m_cct, 20) << "src_snap_seq=" << src_snap_seq
./librbd/deep_copy/ObjectCopyRequest.cc:625:        ldout(m_cct, 20) << "src_snap_seq=" << src_snap_seq
./librbd/deep_copy/ObjectCopyRequest.cc:639:  ldout(m_cct, 20) << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:666:            ldout(m_cct, 20) << "COPY_OP_TYPE_REMOVE" << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:670:            ldout(m_cct, 20) << "COPY_OP_TYPE_TRUNC " << z.get_start() << dendl;
./librbd/deep_copy/ObjectCopyRequest.cc:678:        ldout(m_cct, 20) << "COPY_OP_TYPE_ZERO " << z.get_start() << "~"
./librbd/deep_copy/ObjectCopyRequest.cc:682:    ldout(m_cct, 20) << "src_snap_seq=" << src_snap_seq << ", end_size="
./librbd/deep_copy/ObjectCopyRequest.cc:697:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/io/AioCompletion.cc:48:  ldout(cct, 20) << "r=" << rval << dendl;
./librbd/io/AioCompletion.cc:146:  ldout(cct, 20) << "pending=" << count << dendl;
./librbd/io/AioCompletion.cc:170:  ldout(cct, 20) << "cb=" << complete_cb << ", "
./librbd/io/ImageRequest.cc:102:  ldout(cct, 20) << get_request_type() << ": ictx=" << &image_ctx << ", "
./librbd/io/ImageRequest.cc:205:      ldout(cct, 20) << "oid " << extent.oid << " " << extent.offset << "~"
./librbd/io/ImageRequest.cc:314:    ldout(cct, 20) << "oid " << p->oid << " " << p->offset << "~" << p->length
./librbd/io/ReadResult.cc:44:    ldout(cct, 20) << "dropping read result" << dendl;
./librbd/io/ReadResult.cc:48:    ldout(cct, 20) << "copying resulting bytes to "
./librbd/io/ReadResult.cc:57:    ldout(cct, 20) << "copying resulting " << bl.length() << " bytes to iovec "
./librbd/io/ReadResult.cc:76:    ldout(cct, 20) << "moved resulting " << bufferlist.bl->length() << " "
./librbd/io/ReadResult.cc:90:  ldout(cct, 10) << "C_ImageReadRequest: r=" << r
./librbd/io/ReadResult.cc:119:  ldout(cct, 10) << "C_ObjectReadRequest: r=" << r
./librbd/io/ReadResult.cc:126:    ldout(cct, 10) << " got " << extent_map
./librbd/io/AsyncOperation.cc:32:      ldout(image_ctx->cct, 20) << "completed flush: " << flush_ctx << dendl;
./librbd/io/AsyncOperation.cc:44:  ldout(m_image_ctx->cct, 20) << this << " " << __func__ << dendl;
./librbd/io/AsyncOperation.cc:50:  ldout(m_image_ctx->cct, 20) << this << " " << __func__ << dendl;
./librbd/io/AsyncOperation.cc:60:      ldout(m_image_ctx->cct, 20) << "moving flush contexts to previous op: "
./librbd/io/AsyncOperation.cc:78:  ldout(m_image_ctx->cct, 20) << this << " " << __func__ << ": "
./librbd/io/ImageRequestWQ.cc:87:  ldout(cct, 5) << "ictx=" << image_ctx << dendl;
./librbd/io/ImageRequestWQ.cc:107:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", off=" << off << ", "
./librbd/io/ImageRequestWQ.cc:120:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", off=" << off << ", "
./librbd/io/ImageRequestWQ.cc:146:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", off=" << off << ", "
./librbd/io/ImageRequestWQ.cc:172:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", off=" << off << ", "
./librbd/io/ImageRequestWQ.cc:201:  ldout(cct, 20) << "compare_and_write ictx=" << &m_image_ctx << ", off="
./librbd/io/ImageRequestWQ.cc:228:  ldout(cct, 20) << "ictx=" << &m_image_ctx << dendl;
./librbd/io/ImageRequestWQ.cc:255:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", "
./librbd/io/ImageRequestWQ.cc:297:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", "
./librbd/io/ImageRequestWQ.cc:335:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", "
./librbd/io/ImageRequestWQ.cc:371:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", "
./librbd/io/ImageRequestWQ.cc:406:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", "
./librbd/io/ImageRequestWQ.cc:448:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", "
./librbd/io/ImageRequestWQ.cc:485:    ldout(cct, 5) << __func__ << ": in_flight=" << m_in_flight_ios.load()
./librbd/io/ImageRequestWQ.cc:512:    ldout(cct, 5) << &m_image_ctx << ", " << "num="
./librbd/io/ImageRequestWQ.cc:534:    ldout(cct, 5) << &m_image_ctx << ", " << "num="
./librbd/io/ImageRequestWQ.cc:549:  ldout(cct, 20) << dendl;
./librbd/io/ImageRequestWQ.cc:589:  ldout(cct, 15) << "r=" << r << ", " << "req=" << item << dendl;
./librbd/io/ImageRequestWQ.cc:612:    ldout(cct, 15) << "throttling IO " << peek_item << dendl;
./librbd/io/ImageRequestWQ.cc:647:      ldout(cct, 5) << "exclusive lock required: delaying IO " << item << dendl;
./librbd/io/ImageRequestWQ.cc:672:    ldout(cct, 5) << "image refresh required: delaying IO " << item << dendl;
./librbd/io/ImageRequestWQ.cc:690:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", "
./librbd/io/ImageRequestWQ.cc:762:  ldout(cct, 5) << "completing shut down" << dendl;
./librbd/io/ImageRequestWQ.cc:790:  ldout(cct, 20) << "ictx=" << &m_image_ctx << ", "
./librbd/io/ImageRequestWQ.cc:806:  ldout(cct, 5) << "r=" << r << ", " << "req=" << req << dendl;
./librbd/io/ImageRequestWQ.cc:825:  ldout(cct, 5) << "resuming IO after image refresh: r=" << r << ", "
./librbd/io/ObjectRequest.cc:158:    ldout(m_ictx->cct, 20) << "overlap " << parent_overlap << " "
./librbd/io/ObjectRequest.cc:168:  ldout(m_ictx->cct, 20) << "r=" << r << dendl;
./librbd/io/ObjectRequest.cc:175:  ldout(m_ictx->cct, 20) << "r=" << r << dendl;
./librbd/io/ObjectRequest.cc:199:  ldout(image_ctx->cct, 20) << dendl;
./librbd/io/ObjectRequest.cc:218:  ldout(image_ctx->cct, 20) << dendl;
./librbd/io/ObjectRequest.cc:243:  ldout(image_ctx->cct, 20) << "r=" << r << dendl;
./librbd/io/ObjectRequest.cc:286:  ldout(image_ctx->cct, 20) << dendl;
./librbd/io/ObjectRequest.cc:299:  ldout(image_ctx->cct, 20) << "r=" << r << dendl;
./librbd/io/ObjectRequest.cc:336:  ldout(image_ctx->cct, 20) << dendl;
./librbd/io/ObjectRequest.cc:402:  ldout(image_ctx->cct, 20) << this->get_op_type() << " " << this->m_oid << " "
./librbd/io/ObjectRequest.cc:418:    ldout(image_ctx->cct, 20) << "skipping no-op on nonexistent object"
./librbd/io/ObjectRequest.cc:446:  ldout(image_ctx->cct, 20) << this->m_oid << " " << this->m_object_off
./librbd/io/ObjectRequest.cc:467:  ldout(image_ctx->cct, 20) << "r=" << r << dendl;
./librbd/io/ObjectRequest.cc:476:  ldout(image_ctx->cct, 20) << dendl;
./librbd/io/ObjectRequest.cc:480:    ldout(image_ctx->cct, 20) << "guarding write" << dendl;
./librbd/io/ObjectRequest.cc:501:  ldout(image_ctx->cct, 20) << "r=" << r << dendl;
./librbd/io/ObjectRequest.cc:510:    ldout(image_ctx->cct, 10) << "failed to write object" << dendl;
./librbd/io/ObjectRequest.cc:526:  ldout(image_ctx->cct, 20) << dendl;
./librbd/io/ObjectRequest.cc:554:  ldout(image_ctx->cct, 20) << "r=" << r << dendl;
./librbd/io/ObjectRequest.cc:586:  ldout(image_ctx->cct, 20) << dendl;
./librbd/io/ObjectRequest.cc:609:  ldout(image_ctx->cct, 20) << "r=" << r << dendl;
./librbd/io/ObjectRequest.cc:631:    ldout(cct, 20) << "oid " << this->m_oid << " " << this->m_object_off << "~"
./librbd/io/ObjectDispatcher.cc:195:  ldout(cct, 5) << dendl;
./librbd/io/ObjectDispatcher.cc:214:  ldout(cct, 5) << "object_dispatch_layer=" << type << dendl;
./librbd/io/ObjectDispatcher.cc:228:  ldout(cct, 5) << "object_dispatch_layer=" << object_dispatch_layer << dendl;
./librbd/io/ObjectDispatcher.cc:270:  ldout(cct, 5) << dendl;
./librbd/io/ObjectDispatcher.cc:280:  ldout(cct, 5) << dendl;
./librbd/io/ObjectDispatcher.cc:292:  ldout(cct, 20) << object_no << " " << object_off << "~" << object_len
./librbd/io/ObjectDispatcher.cc:306:  ldout(cct, 20) << "object_dispatch_spec=" << object_dispatch_spec << dendl;
./librbd/io/ObjectDispatch.cc:26:  ldout(cct, 5) << dendl;
./librbd/io/ObjectDispatch.cc:40:  ldout(cct, 20) << oid << " " << object_off << "~" << object_len << dendl;
./librbd/io/ObjectDispatch.cc:59:  ldout(cct, 20) << oid << " " << object_off << "~" << object_len << dendl;
./librbd/io/ObjectDispatch.cc:78:  ldout(cct, 20) << oid << " " << object_off << "~" << data.length() << dendl;
./librbd/io/ObjectDispatch.cc:97:  ldout(cct, 20) << oid << " " << object_off << "~" << object_len << dendl;
./librbd/io/ObjectDispatch.cc:118:  ldout(cct, 20) << oid << " " << object_off << "~" << write_data.length()
./librbd/io/CopyupRequest.cc:103:  ldout(m_ictx->cct, 20) << req << dendl;
./librbd/io/CopyupRequest.cc:112:    ldout(m_ictx->cct, 20) << "completing request " << req << dendl;
./librbd/io/CopyupRequest.cc:126:  ldout(m_ictx->cct, 20) << "oid " << m_oid << dendl;
./librbd/io/CopyupRequest.cc:151:    ldout(m_ictx->cct, 20) << "copyup with empty snapshot context" << dendl;
./librbd/io/CopyupRequest.cc:172:      ldout(m_ictx->cct, 20) << "add_copyup_ops " << req << dendl;
./librbd/io/CopyupRequest.cc:216:  ldout(m_ictx->cct, 20) << "completion " << comp
./librbd/io/CopyupRequest.cc:237:  ldout(cct, 20) << "oid " << m_oid
./librbd/io/CopyupRequest.cc:243:    ldout(cct, 20) << "READ_FROM_PARENT" << dendl;
./librbd/io/CopyupRequest.cc:247:        ldout(cct, 20) << "nop, skipping" << dendl;
./librbd/io/CopyupRequest.cc:256:    ldout(cct, 20) << "OBJECT_MAP_HEAD" << dendl;
./librbd/io/CopyupRequest.cc:261:    ldout(cct, 20) << "OBJECT_MAP" << dendl;
./librbd/io/CopyupRequest.cc:271:    ldout(cct, 20) << "COPYUP (" << pending_copyups << " pending)"
./librbd/io/CopyupRequest.cc:304:  ldout(cct, 20) << dendl;
./librbd/io/CopyupRequest.cc:338:        ldout(cct, 20) << req->get_op_type() << " object no "
./librbd/io/CopyupRequest.cc:366:    ldout(m_ictx->cct, 20) << "oid " << m_oid << dendl;
./librbd/journal/CreateRequest.cc:41:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/CreateRequest.cc:58:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/CreateRequest.cc:82:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/CreateRequest.cc:96:  ldout(m_cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/journal/CreateRequest.cc:110:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/CreateRequest.cc:121:  ldout(m_cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/journal/CreateRequest.cc:135:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/CreateRequest.cc:148:  ldout(m_cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/journal/CreateRequest.cc:160:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/CreateRequest.cc:172:  ldout(m_cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/journal/CreateRequest.cc:196:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/CreateRequest.cc:208:  ldout(m_cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/journal/CreateRequest.cc:221:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/CreateRequest.cc:224:    ldout(m_cct, 20) << "done." << dendl;
./librbd/journal/ResetRequest.cc:35:  ldout(m_cct, 10) << dendl;
./librbd/journal/ResetRequest.cc:45:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/journal/ResetRequest.cc:48:    ldout(m_cct, 5) << "journal does not exist" << dendl;
./librbd/journal/ResetRequest.cc:73:  ldout(m_cct, 10) << dendl;
./librbd/journal/ResetRequest.cc:83:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/journal/ResetRequest.cc:104:  ldout(m_cct, 10) << dendl;
./librbd/journal/ResetRequest.cc:115:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/journal/ResetRequest.cc:128:  ldout(m_cct, 10) << dendl;
./librbd/journal/ResetRequest.cc:143:  ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/journal/ResetRequest.cc:153:   ldout(m_cct, 10) << "r=" << r << dendl;
./librbd/journal/Utils.cc:46:  ldout(cct, 20) << "C_DecodeTag: " << this << " " << __func__ << ": "
./librbd/journal/Utils.cc:77:  ldout(cct, 20) << "C_DecodeTags: " << this << " " << __func__ << ": "
./librbd/journal/PromoteRequest.cc:40:  ldout(cct, 20) << dendl;
./librbd/journal/PromoteRequest.cc:56:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/PromoteRequest.cc:71:  ldout(cct, 20) << dendl;
./librbd/journal/PromoteRequest.cc:100:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/PromoteRequest.cc:116:  ldout(cct, 20) << dendl;
./librbd/journal/PromoteRequest.cc:133:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/PromoteRequest.cc:149:  ldout(cct, 20) << dendl;
./librbd/journal/PromoteRequest.cc:161:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/PromoteRequest.cc:175:  ldout(cct, 20) << dendl;
./librbd/journal/PromoteRequest.cc:185:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/PromoteRequest.cc:200:  ldout(cct, 20) << dendl;
./librbd/journal/PromoteRequest.cc:211:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/PromoteRequest.cc:228:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/RemoveRequest.cc:35:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/RemoveRequest.cc:42:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/RemoveRequest.cc:56:  ldout(m_cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/journal/RemoveRequest.cc:75:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/RemoveRequest.cc:85:  ldout(m_cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/journal/RemoveRequest.cc:99:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/RemoveRequest.cc:109:  ldout(m_cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/journal/RemoveRequest.cc:121:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/journal/RemoveRequest.cc:133:  ldout(m_cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/journal/RemoveRequest.cc:142:    ldout(m_cct, 20) << "done." << dendl;
./librbd/journal/Replay.cc:120:    ldout(cct, 20) << ": ExecuteOp::" << __func__ << dendl;
./librbd/journal/Replay.cc:125:      ldout(cct, 5) << ": lost exclusive lock -- skipping op" << dendl;
./librbd/journal/Replay.cc:158:      ldout(cct, 20) << ": C_RefreshIfRequired::" << __func__ << ": "
./librbd/journal/Replay.cc:204:  ldout(cct, 20) << ": on_ready=" << on_ready << ", on_safe=" << on_safe
./librbd/journal/Replay.cc:212:    ldout(cct, 5) << ": lost exclusive lock -- skipping event" << dendl;
./librbd/journal/Replay.cc:225:  ldout(cct, 20) << dendl;
./librbd/journal/Replay.cc:302:  ldout(cct, 20) << ": op_tid=" << op_tid << dendl;
./librbd/journal/Replay.cc:342:  ldout(cct, 20) << ": AIO discard event" << dendl;
./librbd/journal/Replay.cc:372:  ldout(cct, 20) << ": AIO write event" << dendl;
./librbd/journal/Replay.cc:403:  ldout(cct, 20) << ": AIO flush event" << dendl;
./librbd/journal/Replay.cc:422:  ldout(cct, 20) << ": AIO writesame event" << dendl;
./librbd/journal/Replay.cc:453:  ldout(cct, 20) << ": AIO CompareAndWrite event" << dendl;
./librbd/journal/Replay.cc:481:  ldout(cct, 20) << ": Op finish event: "
./librbd/journal/Replay.cc:492:      ldout(cct, 10) << ": unable to locate associated op: assuming previously "
./librbd/journal/Replay.cc:536:  ldout(cct, 20) << ": Snap create event" << dendl;
./librbd/journal/Replay.cc:565:  ldout(cct, 20) << ": Snap remove event" << dendl;
./librbd/journal/Replay.cc:589:  ldout(cct, 20) << ": Snap rename event" << dendl;
./librbd/journal/Replay.cc:613:  ldout(cct, 20) << ": Snap protect event" << dendl;
./librbd/journal/Replay.cc:637:  ldout(cct, 20) << ": Snap unprotect event" << dendl;
./librbd/journal/Replay.cc:665:  ldout(cct, 20) << ": Snap rollback start event" << dendl;
./librbd/journal/Replay.cc:687:  ldout(cct, 20) << ": Rename event" << dendl;
./librbd/journal/Replay.cc:711:  ldout(cct, 20) << ": Resize start event" << dendl;
./librbd/journal/Replay.cc:736:  ldout(cct, 20) << ": Flatten start event" << dendl;
./librbd/journal/Replay.cc:760:  ldout(cct, 20) << ": Demote/Promote event" << dendl;
./librbd/journal/Replay.cc:769:  ldout(cct, 20) << ": Snap limit event" << dendl;
./librbd/journal/Replay.cc:793:  ldout(cct, 20) << ": Update features event" << dendl;
./librbd/journal/Replay.cc:818:  ldout(cct, 20) << ": Metadata set event" << dendl;
./librbd/journal/Replay.cc:840:  ldout(cct, 20) << ": Metadata remove event" << dendl;
./librbd/journal/Replay.cc:865:  ldout(cct, 20) << ": unknown event" << dendl;
./librbd/journal/Replay.cc:875:  ldout(cct, 20) << ": on_ready=" << on_ready << ", "
./librbd/journal/Replay.cc:899:  ldout(cct, 20) << ": r=" << r << dendl;
./librbd/journal/Replay.cc:931:    ldout(cct, 10) << ": resuming paused AIO" << dendl;
./librbd/journal/Replay.cc:939:    ldout(cct, 20) << ": completing safe context: " << ctx << dendl;
./librbd/journal/Replay.cc:944:    ldout(cct, 20) << ": completing flush context: " << on_flush << dendl;
./librbd/journal/Replay.cc:956:    ldout(cct, 5) << ": ignoring event after shut down" << dendl;
./librbd/journal/Replay.cc:985:  ldout(cct, 20) << ": op_tid=" << op_tid << ", "
./librbd/journal/Replay.cc:1064:    ldout(cct, 5) << ": ignoring event after shut down" << dendl;
./librbd/journal/Replay.cc:1080:    ldout(cct, 10) << ": hit AIO replay low-water mark: scheduling flush"
./librbd/journal/Replay.cc:1090:    ldout(cct, 10) << ": hit AIO replay high-water mark: pausing replay"
./librbd/journal/Replay.cc:1111:    ldout(cct, 5) << ": ignoring event after shut down" << dendl;
./librbd/journal/OpenRequest.cc:45:  ldout(cct, 20) << dendl;
./librbd/journal/OpenRequest.cc:55:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/OpenRequest.cc:94:  ldout(cct, 20) << this << " " << __func__ << ": "
./librbd/journal/OpenRequest.cc:110:  ldout(cct, 20) << dendl;
./librbd/journal/OpenRequest.cc:122:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/OpenRequest.cc:135:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/DemoteRequest.cc:45:  ldout(cct, 20) << dendl;
./librbd/journal/DemoteRequest.cc:61:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/DemoteRequest.cc:81:  ldout(cct, 20) << dendl;
./librbd/journal/DemoteRequest.cc:116:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/DemoteRequest.cc:132:  ldout(cct, 20) << dendl;
./librbd/journal/DemoteRequest.cc:150:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/DemoteRequest.cc:166:  ldout(cct, 20) << dendl;
./librbd/journal/DemoteRequest.cc:178:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/DemoteRequest.cc:192:  ldout(cct, 20) << dendl;
./librbd/journal/DemoteRequest.cc:202:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/DemoteRequest.cc:217:  ldout(cct, 20) << dendl;
./librbd/journal/DemoteRequest.cc:228:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/DemoteRequest.cc:246:  ldout(cct, 20) << "r=" << r << dendl;
./librbd/journal/ObjectDispatch.cc:89:  ldout(cct, 20) << oid << " " << object_off << "~" << object_len << dendl;
./librbd/journal/ObjectDispatch.cc:113:  ldout(cct, 20) << oid << " " << object_off << "~" << data.length() << dendl;
./librbd/journal/ObjectDispatch.cc:138:  ldout(cct, 20) << oid << " " << object_off << "~" << object_len << dendl;
./librbd/journal/ObjectDispatch.cc:164:  ldout(cct, 20) << oid << " " << object_off << "~" << write_data.length()
./librbd/journal/ObjectDispatch.cc:182:  ldout(cct, 20) << object_no << " " << object_off << "~" << object_len
./librbd/journal/ObjectDispatch.cc:201:  ldout(cct, 20) << "journal_tid=" << journal_tid << dendl;
./librbd/cache/PassthroughImageCache.cc:26:  ldout(cct, 20) << "image_extents=" << image_extents << ", "
./librbd/cache/PassthroughImageCache.cc:39:  ldout(cct, 20) << "image_extents=" << image_extents << ", "
./librbd/cache/PassthroughImageCache.cc:50:  ldout(cct, 20) << "offset=" << offset << ", "
./librbd/cache/PassthroughImageCache.cc:60:  ldout(cct, 20) << "on_finish=" << on_finish << dendl;
./librbd/cache/PassthroughImageCache.cc:70:  ldout(cct, 20) << "offset=" << offset << ", "
./librbd/cache/PassthroughImageCache.cc:87:  ldout(cct, 20) << "image_extents=" << image_extents << ", "
./librbd/cache/PassthroughImageCache.cc:98:  ldout(cct, 20) << dendl;
./librbd/cache/PassthroughImageCache.cc:106:  ldout(cct, 20) << dendl;
./librbd/cache/PassthroughImageCache.cc:114:  ldout(cct, 20) << dendl;
./librbd/cache/PassthroughImageCache.cc:123:  ldout(cct, 20) << dendl;
./librbd/cache/ImageWriteback.cc:27:  ldout(cct, 20) << "image_extents=" << image_extents << ", "
./librbd/cache/ImageWriteback.cc:43:  ldout(cct, 20) << "image_extents=" << image_extents << ", "
./librbd/cache/ImageWriteback.cc:59:  ldout(cct, 20) << "offset=" << offset << ", "
./librbd/cache/ImageWriteback.cc:74:  ldout(cct, 20) << "on_finish=" << on_finish << dendl;
./librbd/cache/ImageWriteback.cc:89:  ldout(cct, 20) << "offset=" << offset << ", "
./librbd/cache/ImageWriteback.cc:110:  ldout(cct, 20) << "image_extents=" << image_extents << ", "
./librbd/cache/ObjectCacherObjectDispatch.cc:93:  ldout(cct, 5) << dendl;
./librbd/cache/ObjectCacherObjectDispatch.cc:96:  ldout(cct, 5) << "enabling caching..." << dendl;
./librbd/cache/ObjectCacherObjectDispatch.cc:104:  ldout(cct, 5) << "Initial cache settings:"
./librbd/cache/ObjectCacherObjectDispatch.cc:129:  ldout(cct, 5) << " cache bytes " << m_image_ctx->cache_size
./librbd/cache/ObjectCacherObjectDispatch.cc:145:  ldout(cct, 5) << dendl;
./librbd/cache/ObjectCacherObjectDispatch.cc:178:  ldout(cct, 20) << "object_no=" << object_no << " " << object_off << "~"
./librbd/cache/ObjectCacherObjectDispatch.cc:214:  ldout(cct, 20) << "object_no=" << object_no << " " << object_off << "~"
./librbd/cache/ObjectCacherObjectDispatch.cc:255:  ldout(cct, 20) << "object_no=" << object_no << " " << object_off << "~"
./librbd/cache/ObjectCacherObjectDispatch.cc:290:  ldout(cct, 20) << "object_no=" << object_no << " " << object_off << "~"
./librbd/cache/ObjectCacherObjectDispatch.cc:315:  ldout(cct, 20) << "object_no=" << object_no << " " << object_off << "~"
./librbd/cache/ObjectCacherObjectDispatch.cc:345:  ldout(cct, 20) << dendl;
./librbd/cache/ObjectCacherObjectDispatch.cc:357:    ldout(cct, 5) << "saw first user flush, enabling writeback" << dendl;
./librbd/cache/ObjectCacherObjectDispatch.cc:369:  ldout(cct, 5) << dendl;
./librbd/cache/ObjectCacherObjectDispatch.cc:388:  ldout(cct, 5) << dendl;
./librbd/image_watcher/NotifyLockOwner.cc:37:  ldout(cct, 20) << dendl;
./librbd/image_watcher/NotifyLockOwner.cc:46:  ldout(cct, 20) << ": r=" << r << dendl;
./librbd/image_watcher/NotifyLockOwner.cc:70:    ldout(cct, 1) << ": no lock owners detected" << dendl;
./librbd/MirroringWatcher.cc:47:  ldout(cct, 20) << dendl;
./librbd/MirroringWatcher.cc:76:  ldout(cct, 20) << dendl;
./librbd/MirroringWatcher.cc:94:  ldout(cct, 15) << ": notify_id=" << notify_id << ", "
./librbd/MirroringWatcher.cc:118:  ldout(cct, 20) << ": mode updated: " << payload.mirror_mode << dendl;
./librbd/MirroringWatcher.cc:127:  ldout(cct, 20) << ": image state updated" << dendl;
./librbd/Operations.cc:68:        ldout(cct, 5) << "update notification on missing header" << dendl;
./librbd/Operations.cc:153:    ldout(cct, 20) << __func__ << dendl;
./librbd/Operations.cc:163:    ldout(cct, 20) << __func__ << ": r=" << r << dendl;
./librbd/Operations.cc:206:    ldout(cct, 20) << __func__ << dendl;
./librbd/Operations.cc:226:    ldout(cct, 20) << __func__ << ": r=" << r << dendl;
./librbd/Operations.cc:250:    ldout(cct, 20) << __func__ << dendl;
./librbd/Operations.cc:260:    ldout(cct, 20) << __func__ << ": r=" << r << dendl;
./librbd/Operations.cc:263:      ldout(cct, 5) << request_type << " not supported by current lock owner"
./librbd/Operations.cc:275:    ldout(cct, 5) << request_type << " timed out notifying lock owner"
./librbd/Operations.cc:284:    ldout(cct, 20) << __func__ << dendl;
./librbd/Operations.cc:295:    ldout(cct, 20) << __func__ << ": r=" << r << dendl;
./librbd/Operations.cc:334:  ldout(cct, 20) << "flatten" << dendl;
./librbd/Operations.cc:364:  ldout(cct, 20) << "flatten finished" << dendl;
./librbd/Operations.cc:376:  ldout(cct, 20) << "flatten" << dendl;
./librbd/Operations.cc:425:  ldout(cct, 10) << "rebuild_object_map" << dendl;
./librbd/Operations.cc:440:  ldout(cct, 10) << "rebuild object map finished" << dendl;
./librbd/Operations.cc:455:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/Operations.cc:477:  ldout(cct, 5) << this << " " << __func__ << dendl;
./librbd/Operations.cc:521:  ldout(cct, 5) << this << " " << __func__ << ": dest_name=" << dstname
./librbd/Operations.cc:585:  ldout(cct, 5) << this << " " << __func__ << ": dest_name=" << dest_name
./librbd/Operations.cc:616:  ldout(cct, 5) << this << " " << __func__ << ": "
./librbd/Operations.cc:641:  ldout(cct, 2) << "resize finished" << dendl;
./librbd/Operations.cc:655:  ldout(cct, 5) << this << " " << __func__ << ": "
./librbd/Operations.cc:708:  ldout(cct, 5) << this << " " << __func__ << ": snap_name=" << snap_name
./librbd/Operations.cc:745:  ldout(cct, 5) << this << " " << __func__ << ": snap_name=" << snap_name
./librbd/Operations.cc:773:  ldout(cct, 5) << this << " " << __func__ << ": snap_name=" << snap_name
./librbd/Operations.cc:825:  ldout(cct, 5) << this << " " << __func__ << ": snap_name=" << snap_name
./librbd/Operations.cc:882:  ldout(cct, 5) << this << " " << __func__ << ": snap_name=" << snap_name
./librbd/Operations.cc:929:  ldout(cct, 5) << this << " " << __func__ << ": snap_name=" << snap_name
./librbd/Operations.cc:970:  ldout(cct, 5) << this << " " << __func__ << ": "
./librbd/Operations.cc:1047:  ldout(cct, 5) << this << " " << __func__ << ": "
./librbd/Operations.cc:1062:  ldout(cct, 5) << this << " " << __func__ << ": snap_name=" << snap_name
./librbd/Operations.cc:1149:  ldout(cct, 5) << this << " " << __func__ << ": snap_name=" << snap_name
./librbd/Operations.cc:1162:  ldout(cct, 5) << this << " " << __func__ << ": snap_name=" << snap_name
./librbd/Operations.cc:1244:  ldout(cct, 5) << this << " " << __func__ << ": snap_name=" << snap_name
./librbd/Operations.cc:1256:  ldout(cct, 5) << this << " " << __func__ << ": limit=" << limit << dendl;
./librbd/Operations.cc:1288:  ldout(cct, 5) << this << " " << __func__ << ": limit=" << limit
./librbd/Operations.cc:1299:  ldout(cct, 5) << this << " " << __func__ << ": features=" << features
./librbd/Operations.cc:1361:  ldout(cct, 2) << "update_features finished" << dendl;
./librbd/Operations.cc:1374:  ldout(cct, 5) << this << " " << __func__ << ": features=" << features
./librbd/Operations.cc:1399:  ldout(cct, 5) << this << " " << __func__ << ": key=" << key << ", value="
./librbd/Operations.cc:1448:  ldout(cct, 5) << this << " " << __func__ << ": key=" << key << ", value="
./librbd/Operations.cc:1466:  ldout(cct, 5) << this << " " << __func__ << ": key=" << key << dendl;
./librbd/Operations.cc:1514:  ldout(cct, 5) << this << " " << __func__ << ": key=" << key << dendl;
./librbd/image/SetFlagsRequest.cc:37:  ldout(cct, 20) << __func__ << dendl;
./librbd/image/SetFlagsRequest.cc:66:  ldout(cct, 20) << __func__ << ": r=" << *result << dendl;
./librbd/image/CreateRequest.cc:218:  ldout(m_cct, 20) << "name=" << m_image_name << ", "
./librbd/image/CreateRequest.cc:234:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:277:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:294:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:330:    ldout(m_cct, 10) << "failed to release self-managed snapshot " << snap_id
./librbd/image/CreateRequest.cc:339:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:367:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:383:  ldout(m_cct, 10) << "validating overwrite support" << dendl;
./librbd/image/CreateRequest.cc:406:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:422:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:436:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:451:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:471:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:488:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:496:    ldout(m_cct, 10) << "error retrieving server supported features set: "
./librbd/image/CreateRequest.cc:500:    ldout(m_cct, 10) << "limiting default features set to server supported: "
./librbd/image/CreateRequest.cc:509:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:539:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:559:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:574:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:594:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:610:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:631:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:647:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:691:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:711:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:733:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:744:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:760:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:763:    ldout(m_cct, 20) << "done." << dendl;
./librbd/image/CreateRequest.cc:779:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:794:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:811:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:823:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:835:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:847:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:859:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:874:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/CreateRequest.cc:886:  ldout(m_cct, 20) << dendl;
./librbd/image/CreateRequest.cc:898:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:65:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:72:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:83:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:116:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:127:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:145:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:163:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:176:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:183:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:204:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:221:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:238:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:259:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:265:    ldout(m_cct, 5) << "error retrieving mirror image: " << cpp_strerror(r)
./librbd/image/RemoveRequest.cc:274:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:291:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:297:    ldout(m_cct, 5) << "error listing mirror watchers: " << cpp_strerror(r)
./librbd/image/RemoveRequest.cc:328:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:345:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:377:  ldout(m_cct, 20) << "snap_id=" << snap_id << ", "
./librbd/image/RemoveRequest.cc:391:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:413:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:428:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:445:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:455:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:469:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:482:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:496:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:508:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:528:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:540:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:552:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:568:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:581:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:594:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:610:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:625:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:641:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:656:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:677:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:688:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:700:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:721:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:737:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:753:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:776:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:792:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:815:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:827:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:841:  ldout(m_cct, 20) << dendl;
./librbd/image/RemoveRequest.cc:856:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RemoveRequest.cc:868:  ldout(m_cct, 20) << "r=" << r << dendl;
./librbd/image/RefreshParentRequest.cc:81:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshParentRequest.cc:96:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshParentRequest.cc:128:  ldout(cct, 10) << this << " " << __func__ << " r=" << *result << dendl;
./librbd/image/RefreshParentRequest.cc:151:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshParentRequest.cc:164:  ldout(cct, 10) << this << " " << __func__ << " r=" << *result << dendl;
./librbd/image/RefreshParentRequest.cc:182:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshParentRequest.cc:195:  ldout(cct, 10) << this << " " << __func__ << " r=" << *result << dendl;
./librbd/image/RefreshParentRequest.cc:212:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshParentRequest.cc:224:  ldout(cct, 10) << this << " " << __func__ << " r=" << *result << dendl;
./librbd/image/RefreshParentRequest.cc:243:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:48:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:58:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/CloseRequest.cc:66:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:76:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/CloseRequest.cc:90:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:100:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/CloseRequest.cc:125:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:136:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/CloseRequest.cc:163:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:179:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/CloseRequest.cc:195:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:204:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/CloseRequest.cc:218:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:228:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/CloseRequest.cc:236:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:246:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/CloseRequest.cc:259:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:268:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/CloseRequest.cc:280:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/CloseRequest.cc:290:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/CloseRequest.cc:314:  ldout(cct, 10) << this << " " << __func__ << ": r=" << r << dendl;
./librbd/image/RefreshRequest.cc:73:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:91:  ldout(cct, 10) << this << " " << __func__ << ": " << "r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:118:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:136:  ldout(cct, 10) << this << " " << __func__ << ": " << "r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:172:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:190:  ldout(cct, 10) << this << " " << __func__ << ": "
./librbd/image/RefreshRequest.cc:219:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:231:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:240:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:265:  ldout(cct, 10) << this << " " << __func__ << ": "
./librbd/image/RefreshRequest.cc:297:    ldout(cct, 5) << "ignoring dynamically disabled exclusive lock" << dendl;
./librbd/image/RefreshRequest.cc:309:  ldout(cct, 10) << this << " " << __func__ << ": "
./librbd/image/RefreshRequest.cc:327:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:336:    ldout(cct, 10) << "config metadata not supported by OSD" << dendl;
./librbd/image/RefreshRequest.cc:363:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:381:  ldout(cct, 10) << this << " " << __func__ << ": "
./librbd/image/RefreshRequest.cc:392:    ldout(cct, 10) << "OSD does not support RBD flags, disabling object map "
./librbd/image/RefreshRequest.cc:402:    ldout(cct, 10) << "out-of-sync snapshot state detected" << dendl;
./librbd/image/RefreshRequest.cc:423:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:440:  ldout(cct, 10) << this << " " << __func__ << ": "
./librbd/image/RefreshRequest.cc:461:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:479:  ldout(cct, 10) << this << " " << __func__ << ": "
./librbd/image/RefreshRequest.cc:489:    ldout(cct, 10) << "OSD does not support groups" << dendl;
./librbd/image/RefreshRequest.cc:511:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:529:  ldout(cct, 10) << this << " " << __func__ << ": "
./librbd/image/RefreshRequest.cc:539:    ldout(cct, 10) << "out-of-sync snapshot state detected" << dendl;
./librbd/image/RefreshRequest.cc:543:    ldout(cct, 10) << "retrying using legacy snapshot methods" << dendl;
./librbd/image/RefreshRequest.cc:560:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:579:  ldout(cct, 10) << this << " " << __func__ << ": "
./librbd/image/RefreshRequest.cc:592:    ldout(cct, 10) << "out-of-sync snapshot state detected" << dendl;
./librbd/image/RefreshRequest.cc:616:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:635:  ldout(cct, 10) << this << " " << __func__ << ": " << "r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:644:    ldout(cct, 10) << "out-of-sync snapshot state detected" << dendl;
./librbd/image/RefreshRequest.cc:675:      ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:695:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:720:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:736:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:783:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:797:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:825:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:840:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:867:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:897:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:913:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:925:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:939:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:951:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:967:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:981:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:1008:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:1021:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:1047:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:1060:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:1079:    ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:1105:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:1121:    ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/RefreshRequest.cc:1129:  ldout(cct, 20) << this << " " << __func__ << dendl;
./librbd/image/RefreshRequest.cc:1167:        ldout(cct, 20) << "new snapshot id=" << m_snapc.snaps[i].val
./librbd/image/OpenRequest.cc:56:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:65:    ldout(cct, 1) << "RBD image format 1 is deprecated. "
./librbd/image/OpenRequest.cc:81:    ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:101:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:119:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:136:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:155:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:171:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:183:    ldout(cct, 10) << "image id " << m_image_ctx->id << " does not exist in "
./librbd/image/OpenRequest.cc:195:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:211:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:224:      ldout(cct, 5) << "failed to retrieve name for image id "
./librbd/image/OpenRequest.cc:241:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:261:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:287:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:304:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:330:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:347:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:369:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:386:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:424:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:436:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:456:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:477:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:489:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:509:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:533:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/OpenRequest.cc:548:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/OpenRequest.cc:562:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/CloneRequest.cc:53:  ldout(m_cct, 20) << "clone " << &m_p_imctx->md_ctx << " name " << m_p_imctx->name
./librbd/image/CloneRequest.cc:61:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:67:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:111:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:163:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:180:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:193:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:222:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:234:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:246:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:260:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:275:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:294:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:309:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:323:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:338:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:353:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:368:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:382:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:393:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:413:  ldout(m_cct, 20) << this << " " << __func__ << ": "
./librbd/image/CloneRequest.cc:430:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:440:      ldout(m_cct, 10) << "config metadata not supported by OSD" << dendl;
./librbd/image/CloneRequest.cc:469:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:484:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:497:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:518:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:543:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:557:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:569:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:582:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:602:  ldout(m_cct, 20) << this << " " << __func__ << dendl;
./librbd/image/CloneRequest.cc:614:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:625:  ldout(m_cct, 20) << this << " " << __func__ << " r=" << r << dendl;
./librbd/image/CloneRequest.cc:628:    ldout(m_cct, 20) << "done." << dendl;
./librbd/image/SetSnapRequest.cc:69:  ldout(cct, 10) << __func__ << dendl;
./librbd/image/SetSnapRequest.cc:84:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/SetSnapRequest.cc:98:  ldout(cct, 10) << __func__ << dendl;
./librbd/image/SetSnapRequest.cc:113:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/SetSnapRequest.cc:126:      ldout(cct, 5) << "failed to locate snapshot '" << m_snap_id << "'"
./librbd/image/SetSnapRequest.cc:150:  ldout(cct, 10) << __func__ << dendl;
./librbd/image/SetSnapRequest.cc:162:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/SetSnapRequest.cc:209:  ldout(cct, 10) << __func__ << dendl;
./librbd/image/SetSnapRequest.cc:223:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/SetSnapRequest.cc:260:  ldout(cct, 10) << __func__ << dendl;
./librbd/image/SetSnapRequest.cc:273:  ldout(cct, 10) << __func__ << ": r=" << *result << dendl;
./librbd/image/SetSnapRequest.cc:299:  ldout(cct, 10) << this << " " << __func__ << dendl;
./librbd/image/SetSnapRequest.cc:311:  ldout(cct, 10) << this << " " << __func__ << ": r=" << *result << dendl;
./librbd/image/SetSnapRequest.cc:324:  ldout(cct, 10) << __func__ << dendl;
./librbd/image/DetachChildRequest.cc:55:  ldout(cct, 5) << dendl;
./librbd/image/DetachChildRequest.cc:77:  ldout(cct, 5) << "r=" << r << dendl;
./librbd/image/DetachChildRequest.cc:94:  ldout(cct, 5) << dendl;
./librbd/image/DetachChildRequest.cc:110:  ldout(cct, 5) << "r=" << r << dendl;
./librbd/image/DetachChildRequest.cc:127:  ldout(cct, 5) << "r=" << r << dendl;
./global/global_init.cc:484:  ldout(cct, 1) << "finished global_init_daemonize" << dendl;
./log/test.cc:344:  ldout(cct, 20) << "Log depth=" << depth << " x=" << x << dendl;
./log/test.cc:356:  ldout(cct, 20) << "Preparing recursion string" << dendl;
./log/test.cc:363:    ldout(cct, 20) << "End " << recursion(cct) << "x=" << x << dendl;
./log/test.cc:365:    ldout(cct, 20) << "End x=" << x << dendl;
./log/test.cc:375:    ldout(g_ceph_context, 20) << "Iteration " << i << dendl;
./log/test.cc:386:    ldout(g_ceph_context, 20) << "Iteration " << i << dendl;
./java/native/libcephfs_jni.cc:433:	ldout(cct, 10) << "jni: ceph_mount: " << (c_root ? c_root : "<NULL>") << dendl;
./java/native/libcephfs_jni.cc:437:	ldout(cct, 10) << "jni: ceph_mount: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:460:	ldout(cct, 10) << "jni: ceph_unmount enter" << dendl;
./java/native/libcephfs_jni.cc:466:	ldout(cct, 10) << "jni: ceph_unmount exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:486:	ldout(cct, 10) << "jni: ceph_release called" << dendl;
./java/native/libcephfs_jni.cc:525:	ldout(cct, 10) << "jni: conf_set: opt " << c_opt << " val " << c_val << dendl;
./java/native/libcephfs_jni.cc:529:	ldout(cct, 10) << "jni: conf_set: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:572:		ldout(cct, 10) << "jni: conf_get: opt " << c_opt << " len " << buflen << dendl;
./java/native/libcephfs_jni.cc:586:	ldout(cct, 10) << "jni: conf_get: ret " << ret << dendl;
./java/native/libcephfs_jni.cc:621:	ldout(cct, 10) << "jni: conf_read_file: path " << c_path << dendl;
./java/native/libcephfs_jni.cc:625:	ldout(cct, 10) << "jni: conf_read_file: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:659:	ldout(cct, 10) << "jni: statfs: path " << c_path << dendl;
./java/native/libcephfs_jni.cc:663:	ldout(cct, 10) << "jni: statfs: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:697:	ldout(cct, 10) << "jni: getcwd: enter" << dendl;
./java/native/libcephfs_jni.cc:705:	ldout(cct, 10) << "jni: getcwd: exit ret " << c_cwd << dendl;
./java/native/libcephfs_jni.cc:732:	ldout(cct, 10) << "jni: chdir: path " << c_path << dendl;
./java/native/libcephfs_jni.cc:736:	ldout(cct, 10) << "jni: chdir: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:775:	ldout(cct, 10) << "jni: listdir: opendir: path " << c_path << dendl;
./java/native/libcephfs_jni.cc:785:	ldout(cct, 10) << "jni: listdir: opendir: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:796:		ldout(cct, 10) << "jni: listdir: getdnames: enter" << dendl;
./java/native/libcephfs_jni.cc:809:		ldout(cct, 10) << "jni: listdir: getdnames: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:827:				ldout(cct, 20) << "jni: listdir: take path " << *ent << dendl;
./java/native/libcephfs_jni.cc:903:	ldout(cct, 10) << "jni: link: oldpath " << c_oldpath <<
./java/native/libcephfs_jni.cc:908:	ldout(cct, 10) << "jni: link: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:941:	ldout(cct, 10) << "jni: unlink: path " << c_path << dendl;
./java/native/libcephfs_jni.cc:945:	ldout(cct, 10) << "jni: unlink: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:985:	ldout(cct, 10) << "jni: rename: from " << c_from << " to " << c_to << dendl;
./java/native/libcephfs_jni.cc:989:	ldout(cct, 10) << "jni: rename: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1022:	ldout(cct, 10) << "jni: mkdir: path " << c_path << " mode " << (int)j_mode << dendl;
./java/native/libcephfs_jni.cc:1026:	ldout(cct, 10) << "jni: mkdir: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1058:	ldout(cct, 10) << "jni: mkdirs: path " << c_path << " mode " << (int)j_mode << dendl;
./java/native/libcephfs_jni.cc:1062:	ldout(cct, 10) << "jni: mkdirs: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1094:	ldout(cct, 10) << "jni: rmdir: path " << c_path << dendl;
./java/native/libcephfs_jni.cc:1098:	ldout(cct, 10) << "jni: rmdir: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1133:		ldout(cct, 10) << "jni: readlink: lstatx " << c_path << dendl;
./java/native/libcephfs_jni.cc:1136:		ldout(cct, 10) << "jni: readlink: lstat exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1150:		ldout(cct, 10) << "jni: readlink: size " << stx.stx_size << " path " << c_path << dendl;
./java/native/libcephfs_jni.cc:1154:		ldout(cct, 10) << "jni: readlink: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1211:	ldout(cct, 10) << "jni: symlink: oldpath " << c_oldpath <<
./java/native/libcephfs_jni.cc:1216:	ldout(cct, 10) << "jni: symlink: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1282:	ldout(cct, 10) << "jni: lstat: path " << c_path << dendl;
./java/native/libcephfs_jni.cc:1286:	ldout(cct, 10) << "jni: lstat exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1324:	ldout(cct, 10) << "jni: stat: path " << c_path << dendl;
./java/native/libcephfs_jni.cc:1328:	ldout(cct, 10) << "jni: stat exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1378:	ldout(cct, 10) << "jni: setattr: path " << c_path << " mask " << mask << dendl;
./java/native/libcephfs_jni.cc:1382:	ldout(cct, 10) << "jni: setattr: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1414:	ldout(cct, 10) << "jni: chmod: path " << c_path << " mode " << (int)j_mode << dendl;
./java/native/libcephfs_jni.cc:1418:	ldout(cct, 10) << "jni: chmod: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1442:	ldout(cct, 10) << "jni: fchmod: fd " << (int)j_fd << " mode " << (int)j_mode << dendl;
./java/native/libcephfs_jni.cc:1446:	ldout(cct, 10) << "jni: fchmod: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1476:	ldout(cct, 10) << "jni: truncate: path " << c_path << " size " << (loff_t)j_size << dendl;
./java/native/libcephfs_jni.cc:1480:	ldout(cct, 10) << "jni: truncate: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1512:	ldout(cct, 10) << "jni: open: path " << c_path << " flags " << flags
./java/native/libcephfs_jni.cc:1517:	ldout(cct, 10) << "jni: open: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1559:	ldout(cct, 10) << "jni: open_layout: path " << c_path << " flags " << flags
./java/native/libcephfs_jni.cc:1567:	ldout(cct, 10) << "jni: open_layout: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1593:	ldout(cct, 10) << "jni: close: fd " << (int)j_fd << dendl;
./java/native/libcephfs_jni.cc:1597:	ldout(cct, 10) << "jni: close: ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1635:	ldout(cct, 10) << "jni: lseek: fd " << (int)j_fd << " offset "
./java/native/libcephfs_jni.cc:1640:	ldout(cct, 10) << "jni: lseek: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1675:	ldout(cct, 10) << "jni: read: fd " << (int)j_fd << " len " << (long)j_size <<
./java/native/libcephfs_jni.cc:1680:	ldout(cct, 10) << "jni: read: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1717:	ldout(cct, 10) << "jni: write: fd " << (int)j_fd << " len " << (long)j_size <<
./java/native/libcephfs_jni.cc:1722:	ldout(cct, 10) << "jni: write: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1747:	ldout(cct, 10) << "jni: ftruncate: fd " << (int)j_fd <<
./java/native/libcephfs_jni.cc:1752:	ldout(cct, 10) << "jni: ftruncate: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1772:	ldout(cct, 10) << "jni: fsync: fd " << (int)j_fd <<
./java/native/libcephfs_jni.cc:1777:	ldout(cct, 10) << "jni: fsync: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1797:	ldout(cct, 10) << "jni: flock: fd " << (int)j_fd <<
./java/native/libcephfs_jni.cc:1820:	ldout(cct, 10) << "jni: flock: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1844:	ldout(cct, 10) << "jni: fstat: fd " << (int)j_fd << dendl;
./java/native/libcephfs_jni.cc:1848:	ldout(cct, 10) << "jni: fstat exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1872:	ldout(cct, 10) << "jni: sync_fs: enter" << dendl;
./java/native/libcephfs_jni.cc:1876:	ldout(cct, 10) << "jni: sync_fs: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:1935:	ldout(cct, 10) << "jni: getxattr: path " << c_path << " name " << c_name <<
./java/native/libcephfs_jni.cc:1942:	ldout(cct, 10) << "jni: getxattr: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2006:	ldout(cct, 10) << "jni: lgetxattr: path " << c_path << " name " << c_name <<
./java/native/libcephfs_jni.cc:2013:	ldout(cct, 10) << "jni: lgetxattr: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2062:		ldout(cct, 10) << "jni: listxattr: path " << c_path << " len " << buflen << dendl;
./java/native/libcephfs_jni.cc:2077:	ldout(cct, 10) << "jni: listxattr: ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2158:		ldout(cct, 10) << "jni: llistxattr: path " << c_path << " len " << buflen << dendl;
./java/native/libcephfs_jni.cc:2173:	ldout(cct, 10) << "jni: llistxattr: ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2249:	ldout(cct, 10) << "jni: removexattr: path " << c_path << " name " << c_name << dendl;
./java/native/libcephfs_jni.cc:2253:	ldout(cct, 10) << "jni: removexattr: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2295:	ldout(cct, 10) << "jni: lremovexattr: path " << c_path << " name " << c_name << dendl;
./java/native/libcephfs_jni.cc:2299:	ldout(cct, 10) << "jni: lremovexattr: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2375:	ldout(cct, 10) << "jni: setxattr: path " << c_path << " name " << c_name
./java/native/libcephfs_jni.cc:2380:	ldout(cct, 10) << "jni: setxattr: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2457:	ldout(cct, 10) << "jni: lsetxattr: path " << c_path << " name " << c_name
./java/native/libcephfs_jni.cc:2462:	ldout(cct, 10) << "jni: lsetxattr: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2488:	ldout(cct, 10) << "jni: get_file_stripe_unit: fd " << (int)j_fd << dendl;
./java/native/libcephfs_jni.cc:2492:	ldout(cct, 10) << "jni: get_file_stripe_unit: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2514:	ldout(cct, 10) << "jni: get_file_replication: fd " << (int)j_fd << dendl;
./java/native/libcephfs_jni.cc:2518:	ldout(cct, 10) << "jni: get_file_replication: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2542:	ldout(cct, 10) << "jni: get_file_pool_name: fd " << (int)j_fd << dendl;
./java/native/libcephfs_jni.cc:2573:	ldout(cct, 10) << "jni: get_file_pool_name: ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2603:	ldout(cct, 10) << "jni: get_default_data_pool_name" << dendl;
./java/native/libcephfs_jni.cc:2617:	ldout(cct, 10) << "jni: get_default_data_pool_name: ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2646:	ldout(cct, 10) << "jni: localize_reads: val " << val << dendl;
./java/native/libcephfs_jni.cc:2650:	ldout(cct, 10) << "jni: localize_reads: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2672:	ldout(cct, 10) << "jni: get_stripe_unit_granularity" << dendl;
./java/native/libcephfs_jni.cc:2676:	ldout(cct, 10) << "jni: get_stripe_unit_granularity: exit ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2706:	ldout(cct, 10) << "jni: get_pool_id: name " << c_name << dendl;
./java/native/libcephfs_jni.cc:2712:	ldout(cct, 10) << "jni: get_pool_id: ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2733:	ldout(cct, 10) << "jni: get_pool_replication: poolid " << jpoolid << dendl;
./java/native/libcephfs_jni.cc:2739:	ldout(cct, 10) << "jni: get_pool_replication: ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2761:	ldout(cct, 10) << "jni: get_file_extent_osds: fd " << fd << " off " << off << dendl;
./java/native/libcephfs_jni.cc:2783:	ldout(cct, 10) << "jni: get_file_extent_osds: ret " << ret << dendl;
./java/native/libcephfs_jni.cc:2828:  ldout(cct, 10) << "jni: osd loc: osd " << osdid << dendl;
./java/native/libcephfs_jni.cc:2855:  ldout(cct, 10) << "jni: osd loc: osd " << osdid << " ret " << ret << dendl;
./java/native/libcephfs_jni.cc:3019:  ldout(cct, 10) << "jni: get_osd_addr: osd " << osd << dendl;
./java/native/libcephfs_jni.cc:3023:  ldout(cct, 10) << "jni: get_osd_addr: ret " << ret << dendl;
./libradosstriper/RadosStriperImpl.cc:957:  ldout(cdata->m_striper->cct(), 10)
./libradosstriper/RadosStriperImpl.cc:1006:  ldout(cct(), 10)
./osd/OSDMapMapping.cc:150:  ldout(m->cct, 20) << __func__ << " " << i->job << " " << i->pool
./osd/OSDMapMapping.cc:167:      ldout(cct, 20) << __func__ << " " << job << " " << p.first << " [" << ps
./osd/Watch.cc:246:    ldout(osd->cct, 10) << "HandleWatchTimeout" << dendl;
./osd/PG.cc:602:  ldout(pg->cct, 10) << __func__ << ": locs:" << locs << dendl;
./osd/PG.cc:616:  ldout(pg->cct, 10) << __func__ << ": adding sources in batch "
./osd/PG.cc:666:      ldout(pg->cct, 10) << __func__ << " " << soid
./osd/PG.cc:672:      ldout(pg->cct, 10) << "search_for_missing " << soid << " " << need
./osd/PG.cc:680:      ldout(pg->cct, 10) << "search_for_missing " << soid << " " << need
./osd/PG.cc:690:      ldout(pg->cct, 10) << "search_for_missing " << soid << " " << need
./osd/PG.cc:698:	ldout(pg->cct, 10) << "search_for_missing " << soid << " " << need
./osd/PG.cc:704:    ldout(pg->cct, 10) << "search_for_missing " << soid << " " << need
./osd/PG.cc:725:  ldout(pg->cct, 20) << "needs_recovery_map missing " << needs_recovery_map
./osd/PG.cc:740:    ldout(pg->cct, 10) << __func__ << " source osd." << *p << " now down" << dendl;
./osd/PG.cc:746:    ldout(pg->cct, 10) << __func__ << " no source osds (" << missing_loc_sources << ") went down" << dendl;
./osd/PG.cc:748:    ldout(pg->cct, 10) << __func__ << " sources osds " << now_down << " now down, remaining sources are "
./osd/PG.cc:6631:  ldout(pg->cct, 10) << "Ending blocked outgoing recovery messages" << dendl;
./osd/PG.cc:6639:  ldout(pg->cct, 10) << "Started advmap" << dendl;
./osd/PG.cc:6648:    ldout(pg->cct, 10) << "should_restart_peering, transitioning to Reset"
./osd/PG.cc:6690:  ldout(pg->cct, 10) << "Ending blocked outgoing recovery messages" << dendl;
./osd/PG.cc:6698:  ldout(pg->cct, 10) << "Reset advmap" << dendl;
./osd/PG.cc:6709:    ldout(pg->cct, 10) << "should restart peering, calling start_peering_interval again"
./osd/PG.cc:6768:    ldout(pg->cct, 1) << "transitioning to Primary" << dendl;
./osd/PG.cc:6771:    ldout(pg->cct, 1) << "transitioning to Stray" << dendl;
./osd/PG.cc:6816:  ldout(pg->cct, 7) << "handle_pg_notify from osd." << notevt.from << dendl;
./osd/PG.cc:6825:  ldout(pg->cct, 7) << "handle ActMap primary" << dendl;
./osd/PG.cc:6857:    ldout(pg->cct,10) << "marking for scrub" << dendl;
./osd/PG.cc:6907:  ldout(pg->cct, 10) << "Peering advmap" << dendl;
./osd/PG.cc:6909:    ldout(pg->cct, 1) << "Peering, affected_by_map, going to Reset" << dendl;
./osd/PG.cc:6975:  ldout(pg->cct, 10) << "Leaving Peering" << dendl;
./osd/PG.cc:7031:  ldout(pg->cct, 10) << "defer backfill, retry delay " << c.delay << dendl;
./osd/PG.cc:7043:  ldout(pg->cct, 10) << "backfill has unfound, can't continue" << dendl;
./osd/PG.cc:7332:    ldout(pg->cct, 10) << "backfill reservation rejected: failure injection"
./osd/PG.cc:7337:    ldout(pg->cct, 10) << "backfill reservation rejected: backfill full"
./osd/PG.cc:7401:    ldout(pg->cct, 10) << "backfill reservation rejected after reservation: "
./osd/PG.cc:7407:    ldout(pg->cct, 10) << "backfill reservation rejected after reservation: backfill full"
./osd/PG.cc:7689:    ldout(pg->cct, 10) << "got defer recovery but not recovering" << dendl;
./osd/PG.cc:7692:  ldout(pg->cct, 10) << "defer recovery, retry delay " << evt.delay << dendl;
./osd/PG.cc:7704:  ldout(pg->cct, 10) << "recovery has unfound, can't continue" << dendl;
./osd/PG.cc:7835:  ldout(pg->cct, 10) << "In Active, about to call activate" << dendl;
./osd/PG.cc:7853:  ldout(pg->cct, 10) << "Activate Finished" << dendl;
./osd/PG.cc:7866:    ldout(pg->cct, 10) << "Active advmap interval change, fast return" << dendl;
./osd/PG.cc:7869:  ldout(pg->cct, 10) << "Active advmap" << dendl;
./osd/PG.cc:7904:      ldout(pg->cct,10) << __func__ << " new removed_snaps " << i->second
./osd/PG.cc:7939:      ldout(pg->cct,10) << __func__ << " new purged_snaps " << j->second
./osd/PG.cc:7954:    ldout(pg->cct, 10) << *pg << " snap_trimq now " << pg->snap_trimq << dendl;
./osd/PG.cc:7982:    ldout(pg->cct, 20) << "reporting stats to osd after " << (advmap.osdmap->get_epoch() - pg->info.stats.reported_epoch)
./osd/PG.cc:7996:  ldout(pg->cct, 10) << "Active: handling ActMap" << dendl;
./osd/PG.cc:8021:    ldout(pg->cct, 10) << "Active: kicking snap trim" << dendl;
./osd/PG.cc:8039:    ldout(pg->cct, 10) << "Active: got notify from " << notevt.from
./osd/PG.cc:8043:    ldout(pg->cct, 10) << "Active: got notify from " << notevt.from
./osd/PG.cc:8047:    ldout(pg->cct, 10) << "Active: got notify from " << notevt.from
./osd/PG.cc:8065:  ldout(pg->cct,10) << " replica osd." << trim.from << " lcod " << trim.trim_to << dendl;
./osd/PG.cc:8084:    ldout(pg->cct, 10) << " peer osd." << infoevt.from
./osd/PG.cc:8099:  ldout(pg->cct, 10) << "searching osd." << logevt.from
./osd/PG.cc:8204:    ldout(pg->cct, 10) << __func__ << " flushes in progress, moving "
./osd/PG.cc:8253:  ldout(pg->cct, 10) << "In ReplicaActive, about to call activate" << dendl;
./osd/PG.cc:8258:  ldout(pg->cct, 10) << "Activate Finished" << dendl;
./osd/PG.cc:8273:  ldout(pg->cct, 10) << "received log from " << logevt.from << dendl;
./osd/PG.cc:8348:    ldout(pg->cct,10) << __func__ << " pool is deleted" << dendl;
./osd/PG.cc:8359:  ldout(pg->cct, 10) << "got info+log from osd." << logevt.from << " " << msg->info << " " << msg->log << dendl;
./osd/PG.cc:8387:  ldout(pg->cct, 10) << "got info from osd." << infoevt.from << " " << infoevt.info << dendl;
./osd/PG.cc:8497:    ldout(pg->cct,10) << __func__ << " delete priority changed, resetting"
./osd/PG.cc:8576:      ldout(pg->cct, 10) << " have osd." << peer << " info " << pg->peer_info[peer] << dendl;
./osd/PG.cc:8580:      ldout(pg->cct, 10) << " already requested info from osd." << peer << dendl;
./osd/PG.cc:8583:      ldout(pg->cct, 10) << " not querying info from down osd." << peer << dendl;
./osd/PG.cc:8585:      ldout(pg->cct, 10) << " querying info from osd." << peer << dendl;
./osd/PG.cc:8615:      ldout(pg->cct, 10) << " last_epoch_started moved forward, rebuilding prior" << dendl;
./osd/PG.cc:8624:	  ldout(pg->cct, 20) << " dropping osd." << *p << " from info_requested, no longer in probe set" << dendl;
./osd/PG.cc:8632:    ldout(pg->cct, 20) << "Adding osd: " << infoevt.from.osd << " peer features: "
./osd/PG.cc:8638:      ldout(pg->cct, 20) << "Common peer features: " << hex << pg->get_min_peer_features() << dec << dendl;
./osd/PG.cc:8639:      ldout(pg->cct, 20) << "Common acting features: " << hex << pg->get_min_acting_features() << dec << dendl;
./osd/PG.cc:8640:      ldout(pg->cct, 20) << "Common upacting features: " << hex << pg->get_min_upacting_features() << dec << dendl;
./osd/PG.cc:8714:    ldout(pg->cct, 10) << " not contiguous with osd." << auth_log_shard << ", down" << dendl;
./osd/PG.cc:8733:  ldout(pg->cct, 10) << " requesting log from osd." << auth_log_shard << dendl;
./osd/PG.cc:8754:    ldout(pg->cct, 10) << "GetLog: auth_log_shard osd."
./osd/PG.cc:8769:    ldout(pg->cct, 10) << "GetLog: discarding log from "
./osd/PG.cc:8773:  ldout(pg->cct, 10) << "GetLog: received master log from osd"
./osd/PG.cc:8783:  ldout(pg->cct, 10) << "leaving GetLog" << dendl;
./osd/PG.cc:8785:    ldout(pg->cct, 10) << "processing master log" << dendl;
./osd/PG.cc:8826:  ldout(pg->cct, 10) << "verifying no want_acting " << pg->want_acting << " targets didn't go down" << dendl;
./osd/PG.cc:8829:      ldout(pg->cct, 10) << " want_acting target osd." << *p << " went down, resetting" << dendl;
./osd/PG.cc:8840:  ldout(pg->cct, 10) << "In WaitActingChange, ignoring MLocRec" << dendl;
./osd/PG.cc:8847:  ldout(pg->cct, 10) << "In WaitActingChange, ignoring MInfoRec" << dendl;
./osd/PG.cc:8854:  ldout(pg->cct, 10) << "In WaitActingChange, ignoring MNotifyRec" << dendl;
./osd/PG.cc:8928:      ldout(pg->cct, 10) << " last_epoch_started moved forward, re-enter getinfo" << dendl;
./osd/PG.cc:8972:  ldout(pg->cct, 7) << "handle_pg_notify from osd." << notevt.from << dendl;
./osd/PG.cc:9030:      ldout(pg->cct, 10) << " osd." << *i << " is not contiguous, will restart backfill" << dendl;
./osd/PG.cc:9035:      ldout(pg->cct, 10) << " osd." << *i << " will fully backfill; can infer empty missing set" << dendl;
./osd/PG.cc:9046:      ldout(pg->cct, 10) << " osd." << *i << " has no missing, identical log" << dendl;
./osd/PG.cc:9056:      ldout(pg->cct, 10) << " requesting log+missing since " << since << " from osd." << *i << dendl;
./osd/PG.cc:9065:      ldout(pg->cct, 10) << " requesting fulllog+missing from osd." << *i
./osd/PG.cc:9080:      ldout(pg->cct, 10) << " still need up_thru update before going active"
./osd/PG.cc:9102:      ldout(pg->cct, 10) << " still need up_thru update before going active"
./osd/PG.cc:9106:      ldout(pg->cct, 10) << "Got last missing, don't need missing "
./osd/PG.cc:9169:  ldout(pg->cct, 10) << "Noting missing from osd." << logevt.from << dendl;
./osd/PG.cc:9200:  ldout(pg->cct, 5) << "enter " << state_name << dendl;
./osd/PG.cc:9208:  ldout(pg->cct, 5) << "exit " << state_name << " " << dur << " " << event_count << " " << event_time << dendl;
./osd/PrimaryLogPG.cc:15005:  ldout(pg->cct, 20) << "enter " << state_name << dendl;
./osd/PrimaryLogPG.cc:15010:  ldout(pg->cct, 20) << "exit " << state_name << dendl;
./osd/PrimaryLogPG.cc:15034:  ldout(pg->cct, 10) << "NotTrimming react KickTrim" << dendl;
./osd/PrimaryLogPG.cc:15037:    ldout(pg->cct, 10) << "NotTrimming not primary or active" << dendl;
./osd/PrimaryLogPG.cc:15042:    ldout(pg->cct, 10) << "NotTrimming not clean or nothing to trim" << dendl;
./osd/PrimaryLogPG.cc:15046:    ldout(pg->cct, 10) << " scrubbing, will requeue snap_trimmer after" << dendl;
./osd/PrimaryLogPG.cc:15056:  ldout(pg->cct, 10) << "WaitReservation react SnapTrimReserved" << dendl;
./osd/PrimaryLogPG.cc:15065:  ldout(pg->cct, 10) << "NotTrimming: trimming "
./osd/PrimaryLogPG.cc:15093:    ldout(pg->cct, 10) << "something changed, reverting to NotTrimming" << dendl;
./osd/PrimaryLogPG.cc:15098:  ldout(pg->cct, 10) << "AwaitAsyncWork: trimming snap " << snap_to_trim << dendl;
./osd/PrimaryLogPG.cc:15113:    ldout(pg->cct, 10) << "got ENOENT" << dendl;
./osd/PrimaryLogPG.cc:15115:    ldout(pg->cct, 10) << "adding snap " << snap_to_trim
./osd/PrimaryLogPG.cc:15120:    ldout(pg->cct, 10) << "purged_snaps now "
./osd/PrimaryLogPG.cc:15138:    ldout(pg->cct, 10) << "AwaitAsyncWork react trimming " << object << dendl;
./osd/PrimaryLogPG.cc:15143:	ldout(pg->cct, 10) << "could not get write lock on obj "
./osd/PrimaryLogPG.cc:15147:	ldout(pg->cct, 10) << "Snaptrim error=" << error << dendl;
./osd/PrimaryLogPG.cc:15150:	ldout(pg->cct, 10) << "letting the ones we already started finish" << dendl;
./osd/PrimaryLogPG.cc:15154:	ldout(pg->cct, 10) << "waiting for it to clear"
./osd/ClassHandler.cc:54:  ldout(cct, 10) << __func__ << dendl;
./osd/ClassHandler.cc:70:      ldout(cct, 10) << __func__ << " found " << cname << dendl;
./osd/ClassHandler.cc:125:      ldout(cct, 0) << "_get_class not permitted to load " << cname << dendl;
./osd/ClassHandler.cc:129:    ldout(cct, 10) << "_get_class adding new class name " << cname << " " << cls << dendl;
./osd/ClassHandler.cc:149:    ldout(cct, 10) << "_load_class " << cls->name << " from " << fname << dendl;
./osd/ClassHandler.cc:157:	ldout(cct, 0) << __func__ << " could not stat class " << fname
./osd/ClassHandler.cc:160:	ldout(cct, 0) << "_load_class could not open class " << fname
./osd/ClassHandler.cc:194:    ldout(cct, 10) << "_load_class " << cls->name << " satisfied dependency " << dc->name << dendl;
./osd/ClassHandler.cc:205:  ldout(cct, 10) << "_load_class " << cls->name << " success" << dendl;
./osd/ClassHandler.cc:217:  ldout(cct, 10) << "register_class " << cname << " status " << cls->status << dendl;
./osd/ClassHandler.cc:220:    ldout(cct, 0) << "class " << cname << " isn't loaded; is the class registering under the wrong name?" << dendl;
./osd/ClassHandler.cc:242:  ldout(handler->cct, 10) << "register_method " << name << "." << mname << " flags " << flags << " " << (void*)func << dendl;
./osd/ClassHandler.cc:256:  ldout(handler->cct, 10) << "register_cxx_method " << name << "." << mname << " flags " << flags << " " << (void*)func << dendl;
./osd/OSDMap.cc:231:        ldout(cct, 10) << __func__ << " from " << new_pool.first << " to "
./osd/OSDMap.cc:296:      ldout(cct, 30) << "containing_subtree_is_down(" << id << ") = false" << dendl;
./osd/OSDMap.cc:302:      ldout(cct, 30) << "containing_subtree_is_down(" << id << ") = true ... " << type << " >= " << subtree_type << dendl;
./osd/OSDMap.cc:1551:  ldout(cct, 10) << __func__ << dendl;
./osd/OSDMap.cc:1561:      ldout(cct, 10) << __func__ << " removing pg_temp " << pg.first
./osd/OSDMap.cc:1575:      ldout(cct, 10) << __func__ << "  removing pg_temp " << pg.first
./osd/OSDMap.cc:1585:      ldout(cct, 10) << __func__ << "  removing pg_temp " << pg.first << " "
./osd/OSDMap.cc:1597:      ldout(cct, 10) << __func__ << "  removing primary_temp " << pg.first
./osd/OSDMap.cc:1609:      ldout(cct, 10) << __func__ << "  removing primary_temp "
./osd/OSDMap.cc:1624:  ldout(cct, 10) << __func__ << dendl;
./osd/OSDMap.cc:1670:    ldout(cct, 10) << __func__ << " pg " << pg
./osd/OSDMap.cc:1715:        ldout(cct, 10) << __func__ << " cancel invalid pending "
./osd/OSDMap.cc:1722:        ldout(cct, 10) << __func__ << " cancel invalid pg_upmap entry "
./osd/OSDMap.cc:1732:        ldout(cct, 10) << __func__ << " cancel invalid pending "
./osd/OSDMap.cc:1739:        ldout(cct, 10) << __func__ << " cancel invalid "
./osd/OSDMap.cc:3619:  ldout(cct, 10) << "build_simple on " << nosd
./osd/OSDMap.cc:3762:    ldout(cct, 10) << " adding osd." << o << " at " << loc << dendl;
./osd/OSDMap.cc:3833:    ldout(cct, 5) << " adding osd." << o << " at " << loc << dendl;
./osd/OSDMap.cc:4031:  ldout(cct, 10) << __func__ << dendl;
./osd/OSDMap.cc:4038:      ldout(cct, 10) << " removing redundant pg_upmap " << p.first << " "
./osd/OSDMap.cc:4055:      ldout(cct, 10) << " removing no-op pg_upmap_items " << p.first << " "
./osd/OSDMap.cc:4060:      ldout(cct, 10) << " simplifying partially no-op pg_upmap_items "
./osd/OSDMap.cc:4158:      ldout(cct,30) << __func__ << " pool " << i.first << " ruleno " << ruleno << dendl;
./osd/OSDMap.cc:4175:      ldout(cct, 20) << " osd." << i.first << " weight " << i.second
./osd/OSDMap.cc:4184:    ldout(cct, 10) << " osd_weight_total " << osd_weight_total << dendl;
./osd/OSDMap.cc:4185:    ldout(cct, 10) << " pgs_per_weight " << pgs_per_weight << dendl;
./osd/OSDMap.cc:4195:      ldout(cct, 20) << " osd." << i.first
./osd/OSDMap.cc:4220:    ldout(cct, 10) << " total_deviation " << total_deviation
./osd/OSDMap.cc:4236:	ldout(cct, 10) << " osd." << osd
./osd/OSDMap.cc:4244:      ldout(cct, 10) << " osd." << osd << " move " << num_to_move << dendl;
./osd/OSDMap.cc:4256:	      ldout(cct, 10) << "  dropping pg_upmap_items " << pg
./osd/OSDMap.cc:4274:	  ldout(cct, 20) << "  already remapped " << pg << dendl;
./osd/OSDMap.cc:4277:	ldout(cct, 10) << "  trying " << pg << dendl;
./osd/OSDMap.cc:4282:	ldout(cct, 10) << "  " << pg << " " << orig << " -> " << out << dendl;
./osd/OSDMap.cc:4294:	ldout(cct, 10) << "  " << pg << " pg_upmap_items " << rmi << dendl;
./osd/OSDMap.cc:4304:      ldout(cct, 10) << " failed to find any changes to make" << dendl;
./osd/OSDMap.cc:4308:      ldout(cct, 10) << " hit max iterations, stopping" << dendl;
./osd/OSDMap.cc:4312:  ldout(cct, 10) << " start deviation " << start_deviation << dendl;
./osd/OSDMap.cc:4313:  ldout(cct, 10) << " end deviation " << end_deviation << dendl;
./journal/Journaler.cc:147:    ldout(m_cct, 20) << "using image pool for journal data" << dendl;
./journal/Journaler.cc:150:    ldout(m_cct, 20) << "using pool id=" << pool_id << " for journal data"
./journal/Journaler.cc:156:	ldout(m_cct, 1) << "pool id=" << pool_id << " no longer exists"
./journal/Journaler.cc:229:  ldout(m_cct, 5) << "creating new journal: " << m_header_oid << dendl;
./journal/JournalRecorder.cc:112:    ldout(m_cct, 10) << "object " << object_ptr->get_oid() << " now full"
./journal/JournalRecorder.cc:150:    ldout(m_cct, 20) << __func__ << ": close already in-progress" << dendl;
./journal/JournalRecorder.cc:164:  ldout(m_cct, 20) << __func__ << ": closing active object set "
./journal/JournalRecorder.cc:175:  ldout(m_cct, 20) << __func__ << ": advance to object set " << m_current_set
./journal/JournalRecorder.cc:183:  ldout(m_cct, 20) << __func__ << ": r=" << r << dendl;
./journal/JournalRecorder.cc:201:  ldout(m_cct, 10) << __func__ << ": opening object set " << m_current_set
./journal/JournalRecorder.cc:234:      ldout(m_cct, 10) << __func__ << ": closing object "
./journal/JournalRecorder.cc:240:        ldout(m_cct, 20) << __func__ << ": object "
./journal/JournalRecorder.cc:273:  ldout(m_cct, 10) << __func__ << ": "
./journal/JournalRecorder.cc:296:    ldout(m_cct, 20) << __func__ << ": "
./journal/JournalRecorder.cc:303:      ldout(m_cct, 20) << __func__ << ": closing current object set "
./journal/JournalRecorder.cc:313:  ldout(m_cct, 10) << __func__ << ": " << object_recorder->get_oid() << dendl;
./journal/JournalRecorder.cc:327:  ldout(m_cct, 20) << __func__ << ": object "
./journal/JournalRecorder.cc:341:  ldout(m_cct, 10) << __func__ << ": " << object_recorder->get_oid() << dendl;
./journal/JournalRecorder.cc:351:  ldout(m_cct, 20) << __func__ << ": object "
./journal/ObjectRecorder.cc:83:  ldout(m_cct, 20) << __func__ << ": " << m_oid << dendl;
./journal/ObjectRecorder.cc:117:  ldout(m_cct, 20) << __func__ << ": " << m_oid << " flushing " << *future
./journal/ObjectRecorder.cc:155:  ldout(m_cct, 20) << __func__ << ": " << m_oid << dendl;
./journal/ObjectRecorder.cc:168:  ldout(m_cct, 20) << __func__ << ": " << m_oid << dendl;
./journal/ObjectRecorder.cc:245:  ldout(m_cct, 10) << __func__ << ": " << m_oid << " tid=" << tid
./journal/ObjectRecorder.cc:286:    ldout(m_cct, 20) << __func__ << ": " << *buf_it->first << " marked safe"
./journal/ObjectRecorder.cc:305:  ldout(m_cct, 10) << __func__ << ": " << m_oid << " append overflowed"
./journal/ObjectRecorder.cc:331:    ldout(m_cct, 20) << __func__ << ": overflowed " << *it->first
./journal/ObjectRecorder.cc:343:    ldout(m_cct, 20) << __func__ << ": flushing " << *it->first
./journal/ObjectRecorder.cc:368:    ldout(m_cct, 10) << __func__ << ": " << m_oid << " flushing journal tid="
./journal/ObjectRecorder.cc:375:      ldout(m_cct, 20) << __func__ << ": flushing " << *it->first << dendl;
./journal/ObjectPlayer.cc:41:  ldout(m_cct, 10) << __func__ << ": " << m_oid << dendl;
./journal/ObjectPlayer.cc:61:  ldout(m_cct, 20) << __func__ << ": " << m_oid << " watch" << dendl;
./journal/ObjectPlayer.cc:73:  ldout(m_cct, 20) << __func__ << ": " << m_oid << " unwatch" << dendl;
./journal/ObjectPlayer.cc:109:  ldout(m_cct, 10) << __func__ << ": " << m_oid << ", r=" << r << ", len="
./journal/ObjectPlayer.cc:146:          ldout(m_cct, 20) << ": partial record detected, will re-fetch"
./journal/ObjectPlayer.cc:164:    ldout(m_cct, 20) << ": " << entry << " decoded" << dendl;
./journal/ObjectPlayer.cc:182:      ldout(m_cct, 10) << ": " << entry << " is duplicate, replacing" << dendl;
./journal/ObjectPlayer.cc:224:    ldout(m_cct, 20) << ": clearing invalid range: " << intersect_range
./journal/ObjectPlayer.cc:236:  ldout(m_cct, 20) << __func__ << ": " << m_oid << " scheduling watch" << dendl;
./journal/ObjectPlayer.cc:247:  ldout(m_cct, 20) << __func__ << ": " << m_oid << " cancelling watch" << dendl;
./journal/ObjectPlayer.cc:261:  ldout(m_cct, 10) << __func__ << ": " << m_oid << " polling" << dendl;
./journal/ObjectPlayer.cc:270:  ldout(m_cct, 10) << __func__ << ": " << m_oid << " poll complete, r=" << r
./journal/JournalTrimmer.cc:50:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalTrimmer.cc:67:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalTrimmer.cc:100:  ldout(m_cct, 20) << __func__ << ": commit_tid=" << commit_tid << dendl;
./journal/JournalTrimmer.cc:108:  ldout(m_cct, 20) << __func__ << ": min_set=" << minimum_set << dendl;
./journal/JournalTrimmer.cc:130:  ldout(m_cct, 20) << __func__ << ": removing object set " << object_set
./journal/JournalTrimmer.cc:138:    ldout(m_cct, 20) << "removing journal object " << oid << dendl;
./journal/JournalTrimmer.cc:149:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalTrimmer.cc:186:    ldout(m_cct, 20) << "object set " << minimum_commit_set << " still "
./journal/JournalTrimmer.cc:192:  ldout(m_cct, 20) << __func__ << ": r=" << r << ", set=" << object_set << ", "
./journal/JournalTrimmer.cc:215:    ldout(m_cct, 20) << "completing remove set context" << dendl;
./journal/JournalPlayer.cc:65:    ldout(m_cct, 5) << "commit position: " << commit_position << dendl;
./journal/JournalPlayer.cc:122:  ldout(m_cct, 10) << __func__ << ": prefetching "
./journal/JournalPlayer.cc:141:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalPlayer.cc:169:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalPlayer.cc:215:  ldout(m_cct, 10) << __func__ << ": object_num=" << object_number << ", "
./journal/JournalPlayer.cc:222:      ldout(m_cct, 10) << "PREFETCH" << dendl;
./journal/JournalPlayer.cc:226:      ldout(m_cct, 10) << "PLAYBACK" << dendl;
./journal/JournalPlayer.cc:230:      ldout(m_cct, 10) << "ERROR" << dendl;
./journal/JournalPlayer.cc:246:  ldout(m_cct, 10) << __func__ << ": object_num=" << object_number << dendl;
./journal/JournalPlayer.cc:269:      ldout(m_cct, 15) << "seeking known commit position " << position << " in "
./journal/JournalPlayer.cc:281:          ldout(m_cct, 10) << "located next uncommitted entry: " << entry
./journal/JournalPlayer.cc:286:        ldout(m_cct, 20) << "skipping committed entry: " << entry << dendl;
./journal/JournalPlayer.cc:301:      ldout(m_cct, 10) << "refetching potentially partially decoded object"
./journal/JournalPlayer.cc:306:      ldout(m_cct, 10) << "prefetch of object complete" << dendl;
./journal/JournalPlayer.cc:320:  ldout(m_cct, 10) << "switching to playback mode" << dendl;
./journal/JournalPlayer.cc:351:  ldout(m_cct, 10) << __func__ << ": object_num=" << object_number << dendl;
./journal/JournalPlayer.cc:365:    ldout(m_cct, 20) << __func__ << ": waiting for in-flight fetch" << dendl;
./journal/JournalPlayer.cc:377:      ldout(m_cct, 10) << __func__ << ": waiting for full object set" << dendl;
./journal/JournalPlayer.cc:396:        ldout(m_cct, 10) << __func__ << ": "
./journal/JournalPlayer.cc:405:        ldout(m_cct, 10) << __func__ << ": detected stale entry: "
./journal/JournalPlayer.cc:414:        ldout(m_cct, 10) << __func__ << ": new tag detected: "
./journal/JournalPlayer.cc:428:        ldout(m_cct, 20) << __func__ << ": "
./journal/JournalPlayer.cc:437:        ldout(m_cct, 10) << __func__ << ": waiting for first entry: "
./journal/JournalPlayer.cc:441:        ldout(m_cct, 10) << __func__ << ": no more entries" << dendl;
./journal/JournalPlayer.cc:446:        ldout(m_cct, 10) << __func__ << ": assuming no more in-sequence entries: "
./journal/JournalPlayer.cc:454:        ldout(m_cct, 10) << __func__ << ": refetch required: "
./journal/JournalPlayer.cc:459:        ldout(m_cct, 10) << __func__ << ": no more in-sequence entries: "
./journal/JournalPlayer.cc:466:        ldout(m_cct, 10) << __func__ << ": no more entries -- watch required"
./journal/JournalPlayer.cc:477:  ldout(m_cct, 10) << __func__ << ": pruning remaining entries for tag "
./journal/JournalPlayer.cc:488:    ldout(m_cct, 15) << __func__ << ": checking " << object_player->get_oid()
./journal/JournalPlayer.cc:494:        ldout(m_cct, 20) << __func__ << ": pruned " << entry << dendl;
./journal/JournalPlayer.cc:505:    ldout(m_cct, 15) << __func__ << ": resetting refetch state to immediate"
./journal/JournalPlayer.cc:560:  ldout(m_cct, 20) << __func__ << ": new offset "
./journal/JournalPlayer.cc:574:    ldout(m_cct, 20) << __func__ << ": " << player->get_oid() << " requires "
./journal/JournalPlayer.cc:578:    ldout(m_cct, 20) << __func__ << ": new active set detected, all players "
./journal/JournalPlayer.cc:587:  ldout(m_cct, 15) << __func__ << ": " << player->get_oid() << " empty"
./journal/JournalPlayer.cc:619:  ldout(m_cct, 10) << __func__ << ": " << oid << dendl;
./journal/JournalPlayer.cc:626:  ldout(m_cct, 10) << __func__ << ": "
./journal/JournalPlayer.cc:646:  ldout(m_cct, 10) << __func__ << dendl;
./journal/JournalPlayer.cc:667:  ldout(m_cct, 10) << __func__ << dendl;
./journal/JournalPlayer.cc:678:    ldout(m_cct, 20) << __func__ << ": asserting active tag="
./journal/JournalPlayer.cc:704:        ldout(m_cct, 20) << __func__ << ": immediately refetching "
./journal/JournalPlayer.cc:720:  ldout(m_cct, 20) << __func__ << ": scheduling watch on "
./journal/JournalPlayer.cc:728:  ldout(m_cct, 10) << __func__ << ": r=" << r << dendl;
./journal/JournalPlayer.cc:761:  ldout(m_cct, 10) << __func__ << ": r=" << r << dendl;
./journal/JournalPlayer.cc:770:    ldout(m_cct, 10) << __func__ << ": tag " << *m_active_tag_tid << " "
./journal/JournalPlayer.cc:789:  ldout(m_cct, 10) << __func__ << ": entries available" << dendl;
./journal/JournalPlayer.cc:798:  ldout(m_cct, 10) << __func__ << ": replay complete: r=" << r << dendl;
./journal/JournalMetadata.cc:49:    ldout(cct, 20) << "C_GetClient: " << __func__ << dendl;
./journal/JournalMetadata.cc:64:    ldout(cct, 20) << "C_GetClient: " << __func__ << ": r=" << r << dendl;
./journal/JournalMetadata.cc:107:    ldout(cct, 20) << "C_AllocateTag: " << __func__ << dendl;
./journal/JournalMetadata.cc:123:    ldout(cct, 20) << "C_AllocateTag: " << __func__ << ": r=" << r << dendl;
./journal/JournalMetadata.cc:137:    ldout(cct, 20) << "C_AllocateTag: " << __func__ << dendl;
./journal/JournalMetadata.cc:152:    ldout(cct, 20) << "C_AllocateTag: " << __func__ << ": r=" << r << dendl;
./journal/JournalMetadata.cc:166:    ldout(cct, 20) << "C_AllocateTag: " << __func__ << dendl;
./journal/JournalMetadata.cc:182:    ldout(cct, 20) << "C_AllocateTag: " << __func__ << ": r=" << r << dendl;
./journal/JournalMetadata.cc:365:    ldout(cct, 20) << "C_AssertActiveTag: " << __func__ << dendl;
./journal/JournalMetadata.cc:380:    ldout(cct, 20) << "C_AssertActiveTag: " << __func__ << ": r=" << r << dendl;
./journal/JournalMetadata.cc:458:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalMetadata.cc:471:      ldout(m_cct, 20) << "shut_down: waiting for ops" << dendl;
./journal/JournalMetadata.cc:475:      ldout(m_cct, 20) << "shut_down: flushing watch" << dendl;
./journal/JournalMetadata.cc:515:  ldout(m_cct, 10) << __func__ << ": " << m_client_id << dendl;
./journal/JournalMetadata.cc:531:  ldout(m_cct, 10) << __func__ << ": " << m_client_id << dendl;
./journal/JournalMetadata.cc:548:  ldout(m_cct, 10) << __func__ << ": " << m_client_id << dendl;
./journal/JournalMetadata.cc:613:  ldout(m_cct, 20) << __func__ << ": current=" << m_minimum_set
./journal/JournalMetadata.cc:642:  ldout(m_cct, 20) << __func__ << ": current=" << m_active_set
./journal/JournalMetadata.cc:674:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalMetadata.cc:682:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalMetadata.cc:735:  ldout(m_cct, 10) << "initialized immutable metadata" << dendl;
./journal/JournalMetadata.cc:740:  ldout(m_cct, 10) << "refreshing mutable metadata" << dendl;
./journal/JournalMetadata.cc:756:  ldout(m_cct, 10) << "refreshed mutable metadata: r=" << r << dendl;
./journal/JournalMetadata.cc:764:	ldout(m_cct, 0) << "client flagged disconnected: " << m_client_id
./journal/JournalMetadata.cc:802:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalMetadata.cc:813:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalMetadata.cc:828:  ldout(m_cct, 20) << __func__ << ": "
./journal/JournalMetadata.cc:893:      ldout(m_cct, 5) << __func__ << ": journal header not found" << dendl;
./journal/JournalMetadata.cc:895:      ldout(m_cct, 5) << __func__ << ": client blacklisted" << dendl;
./journal/JournalMetadata.cc:902:    ldout(m_cct, 10) << __func__ << ": reset journal watch" << dendl;
./journal/JournalMetadata.cc:908:  ldout(m_cct, 10) << "journal header updated" << dendl;
./journal/JournalMetadata.cc:926:    ldout(m_cct, 5) << "journal watch error: header removed" << dendl;
./journal/JournalMetadata.cc:955:  ldout(m_cct, 20) << "allocated commit tid: commit_tid=" << commit_tid << " ["
./journal/JournalMetadata.cc:971:  ldout(m_cct, 20) << __func__ << ": "
./journal/JournalMetadata.cc:993:  ldout(m_cct, 20) << "committed tid=" << commit_tid << dendl;
./journal/JournalMetadata.cc:1052:    ldout(m_cct, 20) << "updated commit position: " << commit_position << ", "
./journal/JournalMetadata.cc:1059:    ldout(m_cct, 20) << "canceling stale commit: on_safe=" << stale_ctx
./journal/JournalMetadata.cc:1066:  ldout(m_cct, 10) << "notifying journal header update" << dendl;
./journal/JournalMetadata.cc:1073:  ldout(m_cct, 10) << "async notifying journal header update" << dendl;
./journal/JournalMetadata.cc:1094:  ldout(m_cct, 10) << "notified journal header update: r=" << r << dendl;
./journal/JournalMetadata.cc:1098:  ldout(m_cct, 20) << __func__ << dendl;
./journal/JournalMetadata.cc:1121:        ldout(m_cct, 1) << __func__ << ": " << client_id
./journal/JournalMetadata.cc:1125:            ldout(m_cct, 10) << __func__ << ": " << client_id
./journal/JournalMetadata.cc:1143:    ldout(m_cct, 20) << __func__ << ": no laggy clients to disconnect" << dendl;
./rgw/rgw_file.cc:395:      ldout(get_context(), 0) << __func__
./rgw/rgw_file.cc:404:      ldout(get_context(), 12) << __func__
./rgw/rgw_file.cc:414:      ldout(get_context(), 12) << __func__
./rgw/rgw_file.cc:433:	  ldout(get_context(), 1)
./rgw/rgw_file.cc:443:	ldout(get_context(), 12)
./rgw/rgw_file.cc:461:	  ldout(get_context(), 12)
./rgw/rgw_file.cc:472:	  ldout(get_context(), 1)
./rgw/rgw_file.cc:1300:      ldout(s->cct, 0) << __func__ << " called on empty object" << dendl;
./rgw/rgw_file.cc:1321:      ldout(s->cct, 20) << "processor->prepare() returned ret=" << op_ret
./rgw/rgw_file.cc:1330:      ldout(s->cct, 1) << "Cannot load plugin for rgw_compression_type "
./rgw/rgw_file.cc:1349:      ldout(s->cct, 5)
./rgw/rgw_file.cc:1372:	ldout(s->cct, 20) << "processor->thottle_data() returned ret="
./rgw/rgw_file.cc:1377:      ldout(s->cct, 5) << "NOTICE: processor->throttle_data() returned -EEXIST, need to restart write" << dendl;
./rgw/rgw_file.cc:1395:	ldout(s->cct, 0) << "ERROR: processor->prepare() returned "
./rgw/rgw_file.cc:1455:      ldout(s->cct, 20) << "storing " << RGW_ATTR_COMPRESSION
./rgw/rgw_rest_s3.cc:109:    ldout(s->cct, 20) << __CEPH_ASSERT_FUNCTION << " redirecting per x-amz-website-redirect-location=" << s->redirect << dendl;
./rgw/rgw_rest_s3.cc:230:      ldout(s->cct, 0) << "ERROR: failed to decode pg ver attr, ignoring" << dendl;
./rgw/rgw_rest_s3.cc:237:      ldout(s->cct, 0) << "ERROR: failed to decode pg ver attr, ignoring" << dendl;
./rgw/rgw_rest_s3.cc:305:          ldout(s->cct,0) << "Error caught buffer::error couldn't decode TagSet " << dendl;
./rgw/rgw_rest_s3.cc:382:      ldout(s->cct,0) << "ERROR: caught buffer::error, couldn't decode TagSet" << dendl;
./rgw/rgw_rest_s3.cc:432:  ldout(s->cct, 20) << "Read " << obj_tags.count() << "tags" << dendl;
./rgw/rgw_rest_s3.cc:670:        ldout(s->cct, 5) << "bad shard id specified: " << shard_id_str << dendl;
./rgw/rgw_rest_s3.cc:945:    ldout(s->cct, 0) << "ERROR: failed to initialize parser" << dendl;
./rgw/rgw_rest_s3.cc:950:    ldout(s->cct, 10) << "NOTICE: failed to parse data: " << data << dendl;
./rgw/rgw_rest_s3.cc:958:    ldout(s->cct, 10) << "NOTICE: bad versioning config input" << dendl;
./rgw/rgw_rest_s3.cc:982:        ldout(s->cct, 0) << "ERROR: RGWSetBucketVersioning_ObjStore_S3::get_params(): unexpected switch case mfa_status=" << status_conf.mfa_status << dendl;
./rgw/rgw_rest_s3.cc:1022:    ldout(s->cct, 0) << "ERROR: failed to initialize parser" << dendl;
./rgw/rgw_rest_s3.cc:1028:    ldout(s->cct, 5) << "failed to parse xml: " << str << dendl;
./rgw/rgw_rest_s3.cc:1036:    ldout(s->cct, 5) << "unexpected xml: " << str << dendl;
./rgw/rgw_rest_s3.cc:1196:      ldout(s->cct, 0) << "ERROR: failed to initialize parser" << dendl;
./rgw/rgw_rest_s3.cc:1201:    ldout(s->cct, 20) << "create bucket input data=" << data << dendl;
./rgw/rgw_rest_s3.cc:1204:      ldout(s->cct, 0) << "failed to parse input: " << data << dendl;
./rgw/rgw_rest_s3.cc:1209:      ldout(s->cct, 0) << "provided input did not specify location constraint correctly" << dendl;
./rgw/rgw_rest_s3.cc:1213:    ldout(s->cct, 10) << "create bucket location constraint: "
./rgw/rgw_rest_s3.cc:1301:      ldout(s->cct, 5) << "x-amz-copy-source bad format" << dendl;
./rgw/rgw_rest_s3.cc:1325:         ldout(s->cct, 5) << "source bucket name is empty" << dendl;
./rgw/rgw_rest_s3.cc:1335:      ldout(s->cct, 5) << __func__ << "(): get_bucket_info() returned ret=" << ret << dendl;
./rgw/rgw_rest_s3.cc:1346:        ldout(s->cct, 5) << "x-amz-copy-source-range bad format" << dendl;
./rgw/rgw_rest_s3.cc:1353:        ldout(s->cct, 5) << "x-amz-copy-source-range bad format" << dendl;
./rgw/rgw_rest_s3.cc:1370:      ldout(s->cct,0) << "setting obj tags failed with " << ret << dendl;
./rgw/rgw_rest_s3.cc:1576:  ldout(s->cct, 20) << "adding bucket to policy env: " << s->bucket.name
./rgw/rgw_rest_s3.cc:1588:      ldout(s->cct, 20) << "read part header -- part.name="
./rgw/rgw_rest_s3.cc:1592:        ldout(s->cct, 20) << "field.name=" << pair.first << dendl;
./rgw/rgw_rest_s3.cc:1593:        ldout(s->cct, 20) << "field.val=" << pair.second.val << dendl;
./rgw/rgw_rest_s3.cc:1594:        ldout(s->cct, 20) << "field.params:" << dendl;
./rgw/rgw_rest_s3.cc:1597:          ldout(s->cct, 20) << " " << param_pair.first
./rgw/rgw_rest_s3.cc:1713:      ldout(s->cct, 0) << "Couldn't init RGWObjTags XML parser" << dendl;
./rgw/rgw_rest_s3.cc:1718:      ldout(s->cct,0 ) << "Invalid Tagging XML" << dendl;
./rgw/rgw_rest_s3.cc:1739:    ldout(s->cct, 20) << "Read " << obj_tags.count() << "tags" << dendl;
./rgw/rgw_rest_s3.cc:1756:      ldout(s->cct, 0) << "Signature verification algorithm AWS v4 (AWS4-HMAC-SHA256)" << dendl;
./rgw/rgw_rest_s3.cc:1759:      ldout(s->cct, 0) << "Signature verification algorithm AWS v2" << dendl;
./rgw/rgw_rest_s3.cc:1769:        ldout(s->cct, 0) << "No S3 aws4 credential found!" << dendl;
./rgw/rgw_rest_s3.cc:1777:        ldout(s->cct, 0) << "No aws4 signature found!" << dendl;
./rgw/rgw_rest_s3.cc:1785:        ldout(s->cct, 0) << "No aws4 date found!" << dendl;
./rgw/rgw_rest_s3.cc:1795:        ldout(s->cct, 0) << "No S3 aws2 access key found!" << dendl;
./rgw/rgw_rest_s3.cc:1801:        ldout(s->cct, 0) << "No aws2 signature found!" << dendl;
./rgw/rgw_rest_s3.cc:1817:      ldout(s->cct, 20) << "Successful Signature Verification!" << dendl;
./rgw/rgw_rest_s3.cc:1824:      ldout(s->cct, 0) << "failed to decode_base64 policy" << dendl;
./rgw/rgw_rest_s3.cc:1830:    ldout(s->cct, 20) << "POST policy: " << decoded_policy.c_str() << dendl;
./rgw/rgw_rest_s3.cc:1838:      ldout(s->cct, 0) << "failed to parse policy" << dendl;
./rgw/rgw_rest_s3.cc:1857:      ldout(s->cct, 0) << "policy check failed" << dendl;
./rgw/rgw_rest_s3.cc:1862:    ldout(s->cct, 0) << "No attached policy found!" << dendl;
./rgw/rgw_rest_s3.cc:1869:  ldout(s->cct, 20) << "canned_acl=" << canned_acl << dendl;
./rgw/rgw_rest_s3.cc:2062:      ldout(s->cct, 10) << "failed to parse time: " << if_unmod_decoded << dendl;
./rgw/rgw_rest_s3.cc:2124:	ldout(s->cct, 0) <<
./rgw/rgw_rest_s3.cc:2145:      ldout(s->cct, 0) << s->err.message << dendl;
./rgw/rgw_rest_s3.cc:2160:    ldout(s->cct, 0) << s->err.message << dendl;
./rgw/rgw_rest_s3.cc:2270:      ldout(s->cct, 0) << __func__ <<  "decode life cycle config failed" << dendl;
./rgw/rgw_rest_s3.cc:2382:    ldout(s->cct, 15) << "CORSConfiguration";
./rgw/rgw_rest_s3.cc:2495:    ldout(s->cct, 0) << "ERROR: failed to initialize parser" << dendl;
./rgw/rgw_rest_s3.cc:2501:    ldout(s->cct, 10) << "failed to parse data: " << data << dendl;
./rgw/rgw_rest_s3.cc:2842:    ldout(s->cct, 5) << s->err.message << dendl;
./rgw/rgw_rest_s3.cc:2855:      ldout(s->cct, 5) << s->err.message << dendl;
./rgw/rgw_rest_s3.cc:2860:      ldout(s->cct, 5) << s->err.message << dendl;
./rgw/rgw_rest_s3.cc:2872:      ldout(s->cct, 5) << s->err.message << dendl;
./rgw/rgw_rest_s3.cc:2888:      ldout(s->cct, 5) << s->err.message << dendl;
./rgw/rgw_rest_s3.cc:3258:    ldout(store->ctx(), 5) << "NOTICE: invalid mfa string provided: " << mfa_str << dendl;
./rgw/rgw_rest_s3.cc:3267:    ldout(store->ctx(), 5) << "NOTICE: user does not have mfa device with serial=" << serial << dendl;
./rgw/rgw_rest_s3.cc:3273:    ldout(store->ctx(), 20) << "NOTICE: failed to check MFA, serial=" << serial << dendl;
./rgw/rgw_rest_s3.cc:3360:      ldout(s->cct, 0) << "failed to parse copy location" << dendl;
./rgw/rgw_rest_s3.cc:3487:  ldout(s->cct, 20) << __func__ << " handler=" << typeid(*handler).name()
./rgw/rgw_rest_s3.cc:3530:  ldout(s->cct, 10) << __func__ << " Starting retarget" << dendl;
./rgw/rgw_rest_s3.cc:3550:  ldout(s->cct, 10) << "retarget get_effective_key " << s->object << " -> "
./rgw/rgw_rest_s3.cc:3567:    ldout(s->cct, 10) << "retarget redirect code=" << redirect_code
./rgw/rgw_rest_s3.cc:3611:    ldout(s->cct, 20) << "serve_errordoc failed, init_permissions ret=" << ret << dendl;
./rgw/rgw_rest_s3.cc:3617:    ldout(s->cct, 20) << "serve_errordoc failed, read_permissions ret=" << ret << dendl;
./rgw/rgw_rest_s3.cc:3627:    ldout(s->cct, 20) << "serve_errordoc failed, init_processing ret=" << ret << dendl;
./rgw/rgw_rest_s3.cc:3633:    ldout(s->cct, 20) << "serve_errordoc failed, verify_op_mask ret=" << ret << dendl;
./rgw/rgw_rest_s3.cc:3639:    ldout(s->cct, 20) << "serve_errordoc failed, verify_permission ret=" << ret << dendl;
./rgw/rgw_rest_s3.cc:3645:    ldout(s->cct, 20) << "serve_errordoc failed, verify_params ret=" << ret << dendl;
./rgw/rgw_rest_s3.cc:3673:  ldout(s->cct, 10) << "RGWHandler_REST_S3Website::error_handler err_no=" << err_no << " http_ret=" << http_error_code << dendl;
./rgw/rgw_rest_s3.cc:3690:    ldout(s->cct, 10) << "error handler redirect code=" << redirect_code
./rgw/rgw_rest_s3.cc:3707:    ldout(s->cct, 20) << "No special error handling today!" << dendl;
./rgw/rgw_rest_s3.cc:3811:    ldout(s->cct, 10) << "canonical headers format = " << *canonical_headers
./rgw/rgw_rest_s3.cc:3877:      ldout(s->cct, 10) << "delaying v4 auth" << dendl;
./rgw/rgw_rest_s3.cc:4014:    ldout(cct, 10) << "failed to create the canonized auth header\n"
./rgw/rgw_rest_s3.cc:4019:  ldout(cct, 10) << "string_to_sign:\n"
./rgw/rgw_rest_s3.cc:4081:    ldout(s->cct, 0) << "Signature verification algorithm AWS v4"
./rgw/rgw_rest_s3.cc:4085:    ldout(s->cct, 0) << "Signature verification algorithm AWS v2" << dendl;
./rgw/rgw_rest_s3.cc:4190:      ldout(cct, 10) << "ERROR: User id of type: " << user_info.type << " is already present" << dendl;
./rgw/rgw_rest_s3.cc:4226:      ldout(cct, 5) << "error reading user info, uid=" << access_key_id
./rgw/rgw_rest_s3.cc:4233:      ldout(cct, 10) << "ERROR: User id of type: " << s->user->type
./rgw/rgw_rest_s3.cc:4241:    ldout(cct, 0) << "ERROR: access key not encoded in user info" << dendl;
./rgw/rgw_rest_s3.cc:4250:  ldout(cct, 15) << "string_to_sign="
./rgw/rgw_rest_s3.cc:4253:  ldout(cct, 15) << "server signature=" << server_signature << dendl;
./rgw/rgw_rest_s3.cc:4254:  ldout(cct, 15) << "client signature=" << signature << dendl;
./rgw/rgw_rest_s3.cc:4255:  ldout(cct, 15) << "compare=" << compare << dendl;
./rgw/rgw_realm_reloader.cc:63:    ldout(cct, 4) << "Notification on realm, reconfiguration "
./rgw/rgw_realm_reloader.cc:74:  ldout(cct, 4) << "Notification on realm, reconfiguration scheduled" << dendl;
./rgw/rgw_realm_reloader.cc:80:  ldout(cct, 1) << "Pausing frontends for realm update..." << dendl;
./rgw/rgw_realm_reloader.cc:84:  ldout(cct, 1) << "Frontends paused" << dendl;
./rgw/rgw_realm_reloader.cc:93:  ldout(cct, 1) << "Store closed" << dendl;
./rgw/rgw_realm_reloader.cc:112:    ldout(cct, 1) << "Creating new store" << dendl;
./rgw/rgw_realm_reloader.cc:130:        ldout(cct, 1) << "Woke up with a new configuration, retrying "
./rgw/rgw_realm_reloader.cc:146:      ldout(cct, 4) << "Got another notification, restarting RGWRados "
./rgw/rgw_realm_reloader.cc:160:  ldout(cct, 1) << "Finishing initialization of new store" << dendl;
./rgw/rgw_realm_reloader.cc:162:  ldout(cct, 1) << " - REST subsystem init" << dendl;
./rgw/rgw_realm_reloader.cc:164:  ldout(cct, 1) << " - user subsystem init" << dendl;
./rgw/rgw_realm_reloader.cc:166:  ldout(cct, 1) << " - user subsystem init" << dendl;
./rgw/rgw_realm_reloader.cc:168:  ldout(cct, 1) << " - usage subsystem init" << dendl;
./rgw/rgw_realm_reloader.cc:171:  ldout(cct, 1) << "Resuming frontends with new realm configuration." << dendl;
./rgw/rgw_rest_conn.cc:62:    ldout(cct, 0) << "ERROR: endpoints not configured for upstream zone" << dendl;
./rgw/rgw_rest_conn.cc:76:    ldout(cct, 0) << "WARNING: endpoints not configured for upstream zone" << dendl; /* we'll catch this later */
./rgw/rgw_rest_conn.cc:338:    ldout(cct, 5) << __func__ << ": send_request() resource=" << resource << " returned ret=" << ret << dendl;
./rgw/rgw_rest_conn.cc:383:    ldout(cct, 5) << __func__ << ": send_request() resource=" << resource << " returned ret=" << ret << dendl;
./rgw/rgw_rest_conn.cc:394:    ldout(cct, 5) << __func__ << ": send_request() resource=" << resource << " returned ret=" << ret << dendl;
./rgw/rgw_rest_conn.cc:444:    ldout(cct, 5) << __func__ << ": send_request() resource=" << resource << " returned ret=" << ret << dendl;
./rgw/rgw_rest_conn.cc:458:    ldout(cct, 5) << __func__ << ": send_request() resource=" << resource << " returned ret=" << ret << dendl;
./rgw/rgw_keystone.cc:32:    ldout(cct, 0) << "failed to find " << BEGIN_CMS << " in response" << dendl;
./rgw/rgw_keystone.cc:39:    ldout(cct, 0) << "failed to find " << END_CMS << " in response" << dendl;
./rgw/rgw_keystone.cc:83:    ldout(cct, 0) << "ceph_unarmor() failed, ret=" << ret << dendl;
./rgw/rgw_keystone.cc:92:    ldout(cct, 0) << "ceph_decode_cms returned " << ret << dendl;
./rgw/rgw_keystone.cc:137:  ldout(cct, 20) << "successfully decoded pki token" << dendl;
./rgw/rgw_keystone.cc:190:    ldout(cct, 20) << "found cached admin token" << dendl;
./rgw/rgw_keystone.cc:282:    ldout(cct, 20) << "found cached barbican token" << dendl;
./rgw/rgw_keystone.cc:318:  ldout(cct, 20) << "Requesting secret from barbican url=" << token_url << dendl;
./rgw/rgw_keystone.cc:321:    ldout(cct, 20) << "Barbican process error:" << token_bl.c_str() << dendl;
./rgw/rgw_keystone.cc:360:    ldout(cct, 0) << "Keystone token parse error: malformed json" << dendl;
./rgw/rgw_keystone.cc:401:    ldout(cct, 0) << "Keystone token parse error: " << err.message << dendl;
./rgw/rgw_keystone.cc:511:  ldout(cct, 20) << "invalidating revoked token id=" << token_id << dendl;
./rgw/rgw_keystone.cc:553:  ldout(cct, 10) << "request returned " << bl.c_str() << dendl;
./rgw/rgw_keystone.cc:558:    ldout(cct, 0) << "malformed json" << dendl;
./rgw/rgw_keystone.cc:564:    ldout(cct, 0) << "revoked tokens response is missing signed section" << dendl;
./rgw/rgw_keystone.cc:571:  ldout(cct, 10) << "signed=" << signed_str << dendl;
./rgw/rgw_keystone.cc:579:  ldout(cct, 10) << "content=" << signed_b64 << dendl;
./rgw/rgw_keystone.cc:587:  ldout(cct, 10) << "ceph_decode_cms: decoded: " << json.c_str() << dendl;
./rgw/rgw_keystone.cc:591:    ldout(cct, 0) << "malformed json" << dendl;
./rgw/rgw_keystone.cc:597:    ldout(cct, 0) << "no revoked section in json" << dendl;
./rgw/rgw_keystone.cc:609:      ldout(cct, 0) << "bad token in array, missing id" << dendl;
./rgw/rgw_keystone.cc:628:    ldout(cct, 2) << "keystone revoke thread: start" << dendl;
./rgw/rgw_keystone.cc:631:      ldout(cct, 0) << "ERROR: keystone revocation processing returned error r="
./rgw/rgw_rest_client.cc:34:      ldout(cct, 0) << "ERROR: failed converting content length (" << val << ") to int " << dendl;
./rgw/rgw_rest_client.cc:52:  ldout(cct, 10) << "receive_http_header" << dendl;
./rgw/rgw_rest_client.cc:61:      ldout(cct, 10) << "received header:" << line << dendl;
./rgw/rgw_rest_client.cc:156:  ldout(cct, 15) << "generated auth header: " << auth_hdr << dendl;
./rgw/rgw_rest_client.cc:246:      ldout(cct, 20) << "> " << i.first << " -> " << rgw::crypt_sanitize::x_meta_map{i.first, i.second} << dendl;
./rgw/rgw_rest_client.cc:252:    ldout(cct, 0) << "failed to create canonical s3 header" << dendl;
./rgw/rgw_rest_client.cc:256:  ldout(cct, 10) << "generated canonical header: " << canonical_header << dendl;
./rgw/rgw_rest_client.cc:266:  ldout(cct, 15) << "generated auth header: " << auth_hdr << dendl;
./rgw/rgw_rest_client.cc:287:    ldout(cct, 0) << "ERROR: failed to sign request" << dendl;
./rgw/rgw_rest_client.cc:502:    ldout(cct, 0) << "ERROR: couldn't get policy ret=" << ret << dendl;
./rgw/rgw_rest_client.cc:553:    ldout(cct, 0) << "ERROR: failed to sign request" << dendl;
./rgw/rgw_rest_client.cc:650:    ldout(cct, 0) << "ERROR: failed converting mtime (" << s << ") to real_time " << dendl;
./rgw/rgw_rest_client.cc:657:      ldout(cct, 0) << "ERROR: failed converting mtime (" << s << ") to real_time " << dendl;
./rgw/rgw_rest_client.cc:751:      ldout(cct, 0) << "ERROR: failed to sign request" << dendl;
./rgw/rgw_rest_client.cc:833:        ldout(cct, 0) << "ERROR: failed parsing embedded metadata object size (" << size_str << ") to int " << dendl;
./rgw/rgw_rest_client.cc:872:      ldout(cct, 0) << "ERROR: failed converting embedded metadata len (" << val << ") to int " << dendl;
./rgw/librgw.cc:624:      ldout(get_state()->cct, 10) << "read_permissions (bucket policy) on "
./rgw/librgw.cc:636:	ldout(get_state()->cct, 10) << "read_permissions (object policy) on"
./rgw/rgw_swift_auth.cc:54:  ldout(s->cct, 20) << "finished applying changes to req_state for TempURL: "
./rgw/rgw_swift_auth.cc:116:  ldout(cct, 20) << "temp url user (bucket owner): " << bucket_info.owner
./rgw/rgw_swift_auth.cc:273:    ldout(cct, 5) << "cannot get user_info of account's owner" << dendl;
./rgw/rgw_swift_auth.cc:278:    ldout(cct, 5) << "user does not have temp url key set, aborting" << dendl;
./rgw/rgw_swift_auth.cc:283:    ldout(cct, 5) << "temp url link expired" << dendl;
./rgw/rgw_swift_auth.cc:334:        ldout(s->cct, 20) << "temp url signature [" << temp_url_key_num
./rgw/rgw_swift_auth.cc:342:          ldout(s->cct,  5) << "temp url signature mismatch: " << local_sig
./rgw/rgw_swift_auth.cc:384:  ldout(cct, 10) << "rgw_swift_validate_token url=" << url_buf << dendl;
./rgw/rgw_swift_auth.cc:411:  ldout(cct, 10) << "swift user=" << swift_user << dendl;
./rgw/rgw_swift_auth.cc:416:    ldout(cct, 0) << "NOTICE: couldn't map swift user" << dendl;
./rgw/rgw_swift_auth.cc:491:    ldout(cct, 0) << "NOTICE: failed to verify token: odd token length="
./rgw/rgw_swift_auth.cc:517:    ldout(cct, 0) << "NOTICE: failed to decode token" << dendl;
./rgw/rgw_swift_auth.cc:523:    ldout(cct, 0) << "NOTICE: old timed out token was used now=" << now
./rgw/rgw_swift_auth.cc:535:  ldout(cct, 10) << "swift_user=" << swift_user << dendl;
./rgw/rgw_swift_auth.cc:551:    ldout(cct, 0) << "NOTICE: tokens length mismatch:"
./rgw/rgw_swift_auth.cc:565:    ldout(cct, 0) << "NOTICE: tokens mismatch tok=" << buf << dendl;
./rgw/rgw_sync_module_aws.cc:267:      ldout(cct, 0) << "ERROR: could not parse configurable value for cloud sync module: " << key << ": " << sval << dendl;
./rgw/rgw_sync_module_aws.cc:394:        ldout(cct, 0) << "ERROR: ambiguous profile connection configuration, connection_id=" << profile.connection_id << dendl;
./rgw/rgw_sync_module_aws.cc:398:        ldout(cct, 0) << "ERROR: profile configuration reference non-existent connection_id=" << profile.connection_id << dendl;
./rgw/rgw_sync_module_aws.cc:411:      ldout(cct, 0) << "ERROR: remote connection undefined for sync profile" << dendl;
./rgw/rgw_sync_module_aws.cc:431:        ldout(cct, 0) << "ERROR: profile configuration reference non-existent acls id=" << profile.acls_id << dendl;
./rgw/rgw_sync_module_aws.cc:465:      ldout(cct, 0) << "WARNING: duplicate target configuration in sync module" << dendl;
./rgw/rgw_sync_module_aws.cc:552:    ldout(cct, 5) << "sync module config (parsed representation):\n" << ss.str() << dendl;
./rgw/rgw_sync_module_aws.cc:571:    ldout(sync_env->cct, 20) << "updated target: (root) -> " << root_profile->target_path << dendl;
./rgw/rgw_sync_module_aws.cc:574:      ldout(sync_env->cct, 20) << "updated target: " << t.first << " -> " << t.second->target_path << dendl;
./rgw/rgw_sync_module_aws.cc:698:      ldout(cct, 0) << "ERROR: failed to decode policy off attrs" << dendl;
./rgw/rgw_sync_module_aws.cc:702:    ldout(cct, 0) << "WARNING: acl attrs not provided" << dendl;
./rgw/rgw_sync_module_aws.cc:750:      ldout(sync_env->cct, 0) << "ERROR: " << __func__ << "(): conn->get_obj() returned ret=" << ret << dendl;
./rgw/rgw_sync_module_aws.cc:762:    ldout(sync_env->cct, 20) << __func__ << ":" << " headers=" << headers << " extra_data.length()=" << extra_data.length() << dendl;
./rgw/rgw_sync_module_aws.cc:767:        ldout(sync_env->cct, 0) << "ERROR: failed to parse response extra data. len=" << extra_data.length() << " data=" << extra_data.c_str() << dendl;
./rgw/rgw_sync_module_aws.cc:859:          ldout(cct, 20) << "acl_mappings: Could not find " << orig_grantee << " .. ignoring" << dendl;
./rgw/rgw_sync_module_aws.cc:929:      ldout(cct, 20) << "acl_mappings: set acl: " << header_str << "=" << s << dendl;
./rgw/rgw_sync_module_aws.cc:1092:        ldout(sync_env->cct, 0) << "ERROR: failed to get etag from PUT request" << dendl;
./rgw/rgw_sync_module_aws.cc:1131:        ldout(sync_env->cct, 0) << "ERROR: failed to abort multipart upload for dest object=" << dest_obj << " (retcode=" << retcode << ")" << dendl;
./rgw/rgw_sync_module_aws.cc:1191:        ldout(sync_env->cct, 0) << "ERROR: failed to initialize multipart upload for dest object=" << dest_obj << dendl;
./rgw/rgw_sync_module_aws.cc:1202:          ldout(sync_env->cct, 0) << "ERROR: failed to initialize xml parser for parsing multipart init response from server" << dendl;
./rgw/rgw_sync_module_aws.cc:1208:          ldout(sync_env->cct, 5) << "ERROR: failed to parse xml: " << str << dendl;
./rgw/rgw_sync_module_aws.cc:1216:          ldout(sync_env->cct, 5) << "ERROR: unexpected xml: " << str << dendl;
./rgw/rgw_sync_module_aws.cc:1221:      ldout(sync_env->cct, 20) << "init multipart result: bucket=" << result.bucket << " key=" << result.key << " upload_id=" << result.upload_id << dendl;
./rgw/rgw_sync_module_aws.cc:1302:        ldout(sync_env->cct, 0) << "ERROR: failed to initialize multipart upload for dest object=" << dest_obj << dendl;
./rgw/rgw_sync_module_aws.cc:1313:          ldout(sync_env->cct, 0) << "ERROR: failed to initialize xml parser for parsing multipart init response from server" << dendl;
./rgw/rgw_sync_module_aws.cc:1319:          ldout(sync_env->cct, 5) << "ERROR: failed to parse xml: " << str << dendl;
./rgw/rgw_sync_module_aws.cc:1327:          ldout(sync_env->cct, 5) << "ERROR: unexpected xml: " << str << dendl;
./rgw/rgw_sync_module_aws.cc:1332:      ldout(sync_env->cct, 20) << "complete multipart result: location=" << result.location << " bucket=" << result.bucket << " key=" << result.key << " etag=" << result.etag << dendl;
./rgw/rgw_sync_module_aws.cc:1366:        ldout(sync_env->cct, 0) << "ERROR: failed to abort multipart upload dest obj=" << dest_obj << " upload_id=" << upload_id << " retcode=" << retcode << dendl;
./rgw/rgw_sync_module_aws.cc:1371:        ldout(sync_env->cct, 0) << "ERROR: failed to remove sync status obj obj=" << status_obj << " retcode=" << retcode << dendl;
./rgw/rgw_sync_module_aws.cc:1434:        ldout(sync_env->cct, 0) << "ERROR: failed to read sync status of object " << src_obj << " retcode=" << retcode << dendl;
./rgw/rgw_sync_module_aws.cc:1487:          ldout(sync_env->cct, 0) << "ERROR: failed to sync obj=" << src_obj << ", sync via multipart upload, upload_id=" << status.upload_id << " part number " << status.cur_part << " (error: " << cpp_strerror(-retcode) << ")" << dendl;
./rgw/rgw_sync_module_aws.cc:1495:          ldout(sync_env->cct, 0) << "ERROR: failed to store multipart upload state, retcode=" << retcode << dendl;
./rgw/rgw_sync_module_aws.cc:1498:        ldout(sync_env->cct, 20) << "sync of object=" << src_obj << " via multipart upload, finished sending part #" << status.cur_part << " etag=" << pcur_part_info->etag << dendl;
./rgw/rgw_sync_module_aws.cc:1503:        ldout(sync_env->cct, 0) << "ERROR: failed to complete multipart upload of obj=" << src_obj << " (error: " << cpp_strerror(-retcode) << ")" << dendl;
./rgw/rgw_sync_module_aws.cc:1512:        ldout(sync_env->cct, 0) << "ERROR: failed to abort multipart upload obj=" << src_obj << " upload_id=" << status.upload_id << " part number " << status.cur_part << " (" << cpp_strerror(-retcode) << ")" << dendl;
./rgw/rgw_sync_module_aws.cc:1587:        ldout(sync_env->cct, 0) << "ERROR: failed to decode pg ver attr, ignoring" << dendl;
./rgw/rgw_sync_module_aws.cc:1591:          ldout(sync_env->cct, 0) << "ERROR: failed to decode source zone short_id attr, ignoring" << dendl;
./rgw/rgw_sync_module_aws.cc:1595:      ldout(sync_env->cct, 0) << "AWS: download begin: z=" << sync_env->source_zone
./rgw/rgw_sync_module_aws.cc:1604:        ldout(sync_env->cct, 0) << "ERROR: cannot find http connection to zone " << sync_env->source_zone << dendl;
./rgw/rgw_sync_module_aws.cc:1613:          ldout(sync_env->cct,0) << "AWS: creating bucket " << target_bucket_name << dendl;
./rgw/rgw_sync_module_aws.cc:1622:            ldout(sync_env->cct, 0) << "ERROR: failed to initialize xml parser for parsing multipart init response from server" << dendl;
./rgw/rgw_sync_module_aws.cc:1628:            ldout(sync_env->cct, 5) << "ERROR: failed to parse xml: " << str << dendl;
./rgw/rgw_sync_module_aws.cc:1636:            ldout(sync_env->cct, 5) << "ERROR: unexpected xml: " << str << dendl;
./rgw/rgw_sync_module_aws.cc:1674:            ldout(sync_env->cct, 0) << "ERROR: failed to decode rest obj out of headers=" << headers << ", attrs=" << attrs << dendl;
./rgw/rgw_sync_module_aws.cc:1725:      ldout(sync_env->cct, 0) << ": remove remote obj: z=" << sync_env->source_zone
./rgw/rgw_sync_module_aws.cc:1730:        ldout(sync_env->cct, 0) << "AWS: removing aws object at" << path << dendl;
./rgw/rgw_sync_module_aws.cc:1764:    ldout(sync_env->cct, 0) << instance.id << ": sync_object: b=" << bucket_info.bucket << " k=" << key << " versioned_epoch=" << versioned_epoch << dendl;
./rgw/rgw_sync_module_aws.cc:1769:    ldout(sync_env->cct, 0) <<"rm_object: b=" << bucket_info.bucket << " k=" << key << " mtime=" << mtime << " versioned=" << versioned << " versioned_epoch=" << versioned_epoch << dendl;
./rgw/rgw_sync_module_aws.cc:1775:    ldout(sync_env->cct, 0) <<"AWS Not implemented: create_delete_marker: b=" << bucket_info.bucket << " k=" << key << " mtime=" << mtime
./rgw/rgw_bucket.cc:146:      ldout(store->ctx(), 0) << "ERROR: could not get stats for buckets" << dendl;
./rgw/rgw_bucket.cc:168:    ldout(store->ctx(), 0) << "ERROR: could not fetch bucket info: ret=" << ret << dendl;
./rgw/rgw_bucket.cc:174:    ldout(store->ctx(), 0) << "ERROR: could not sync user stats for bucket " << bucket_name << ": ret=" << ret << dendl;
./rgw/rgw_bucket.cc:209:      ldout(store->ctx(), 0) << "ERROR: store->get_bucket_entrypoint_info() returned: "
./rgw/rgw_bucket.cc:220:    ldout(store->ctx(), 0) << "ERROR: error adding bucket to directory: "
./rgw/rgw_bucket.cc:239:    ldout(store->ctx(), 0) << "ERROR: failed unlinking bucket on error cleanup: "
./rgw/rgw_bucket.cc:257:    ldout(store->ctx(), 0) << "ERROR: error removing bucket from directory: "
./rgw/rgw_bucket.cc:278:    ldout(store->ctx(), 0) << "bucket entry point user mismatch, can't unlink bucket: " << ep.owner << " != " << user_id << dendl;
./rgw/rgw_bucket.cc:391:    ldout(cct, 0) << "ERROR: failed to parse bucket shard '"
./rgw/rgw_bucket.cc:413:      ldout(store->ctx(), 0) << "ERROR: failed converting old bucket info: " << ret << dendl;
./rgw/rgw_bucket.cc:451:      ldout(store->ctx(), 0) << "failed to read user buckets: "
./rgw/rgw_bucket.cc:470:        ldout(store->ctx(), 0) << "could not get bucket info for bucket=" << bucket << dendl;
./rgw/rgw_bucket.cc:786:      ldout(store->ctx(), 0) << "could not get bucket info for bucket=" << bucket_name << dendl;
./rgw/rgw_bucket.cc:859:      ldout(store->ctx(), 0) << "WARNING: user " << user_info.user_id << " has no display name set" << dendl;
./rgw/rgw_bucket.cc:1036:    ldout(store->ctx(), 0) << "ERROR: " << __func__ << "(): get_bucket_instance_info(bucket=" << bucket << ") returned r=" << r << dendl;
./rgw/rgw_bucket.cc:1216:    ldout(store->ctx(), 0) << "ERROR: caught buffer::error, could not decode policy" << dendl;
./rgw/rgw_bucket.cc:1789:  ldout(cct, 20) << "RGWDataChangesLog::update_renewd() bucket_name=" << bs.bucket.name << " shard_id=" << bs.shard_id << " expiration=" << expiration << dendl;
./rgw/rgw_bucket.cc:1819:  ldout(cct, 20) << "RGWDataChangesLog::add_entry() bucket.name=" << bucket.name << " shard_id=" << shard_id << " now=" << now << " cur_expiration=" << status->cur_expiration << dendl;
./rgw/rgw_bucket.cc:1871:    ldout(cct, 20) << "RGWDataChangesLog::add_entry() sending update with now=" << now << " cur_expiration=" << expiration << dendl;
./rgw/rgw_bucket.cc:2304:        ldout(store->ctx(), 0) << "ERROR: select_bucket_placement() returned " << ret << dendl;
./rgw/rgw_client_io.cc:27:      ldout(cct, 20) << iter.first << "=" << (x) << dendl;
./rgw/rgw_cr_rest.cc:156:          ldout(cct, 0) << "ERROR: " << __func__ << " decode_rest_obj() returned ret=" << ret << dendl;
./rgw/rgw_cr_rest.cc:286:          ldout(cct, 20) << __func__ << ": in_crf->read() retcode=" << retcode << dendl;
./rgw/rgw_cr_rest.cc:291:      ldout(cct, 20) << "read " << bl.length() << " bytes" << dendl;
./rgw/rgw_cr_rest.cc:319:          ldout(cct, 20) << "writing " << bl.length() << " bytes" << dendl;
./rgw/rgw_cr_rest.cc:327:          ldout(cct, 20) << __func__ << ": out_crf->write() retcode=" << retcode << dendl;
./rgw/rgw_sync_module.cc:35:      ldout(sync_env->cct, 0) << "RGWStatRemoteObjCR() returned " << retcode << dendl;
./rgw/rgw_sync_module.cc:38:    ldout(sync_env->cct, 20) << "stat of remote obj: z=" << sync_env->source_zone
./rgw/rgw_sync_module.cc:49:      ldout(sync_env->cct, 0) << "RGWStatRemoteObjCR() callback returned " << retcode << dendl;
./rgw/rgw_crypt.cc:115:      ldout(cct, 5) << "Failed to perform AES-CTR encryption: " << PR_GetError() << dendl;
./rgw/rgw_crypt.cc:270:      ldout(cct, 5) << "Failed to perform AES-CBC encryption: " << PR_GetError() << dendl;
./rgw/rgw_crypt.cc:362:      ldout(cct, 25) << "Encrypted " << size << " bytes"<< dendl;
./rgw/rgw_crypt.cc:366:      ldout(cct, 5) << "Failed to encrypt" << dendl;
./rgw/rgw_crypt.cc:417:      ldout(cct, 25) << "Decrypted " << size << " bytes"<< dendl;
./rgw/rgw_crypt.cc:421:      ldout(cct, 5) << "Failed to decrypt" << dendl;
./rgw/rgw_crypt.cc:505:      ldout(cct, 5) << "Failed to perform AES-ECB encryption: " << PR_GetError() << dendl;
./rgw/rgw_crypt.cc:508:    ldout(cct, 5) << "Key size must be 256 bits long" << dendl;
./rgw/rgw_crypt.cc:543:      ldout(cct, 0) << "ERROR: couldn't decode manifest" << dendl;
./rgw/rgw_crypt.cc:555:        ldout(cct, 20) << "Manifest part " << i << ", size=" << parts_len[i] << dendl;
./rgw/rgw_crypt.cc:602:  ldout(cct, 20) << "fixup_range [" << inp_ofs << "," << inp_end
./rgw/rgw_crypt.cc:610:  ldout(cct, 25) << "Decrypt " << bl_len << " bytes" << dendl;
./rgw/rgw_crypt.cc:684:  ldout(cct, 25) << "Encrypt " << bl.length() << " bytes" << dendl;
./rgw/rgw_crypt.cc:692:      ldout(cct, 20) << "*again==true" << dendl;
./rgw/rgw_crypt.cc:739:    ldout(cct, 0) << "ERROR: conf rgw_barbican_url is not set" << dendl;
./rgw/rgw_crypt.cc:800:  ldout(cct, 20) << "Getting KMS encryption key for key=" << key_id << dendl;
./rgw/rgw_crypt.cc:810:      ldout(cct, 5) << "ERROR: get_actual_key_from_kms invalid encryption key id "
./rgw/rgw_crypt.cc:828:      ldout(cct, 20) << "Wrong size for key=" << key_id << dendl;
./rgw/rgw_crypt.cc:834:      ldout(cct, 5) << "Failed to retrieve token for barbican" << dendl;
./rgw/rgw_crypt.cc:841:      ldout(cct, 5) << "Failed to retrieve secret from barbican:" << key_id << dendl;
./rgw/rgw_crypt.cc:932:        ldout(s->cct, 5) << "ERROR: Invalid value for header "
./rgw/rgw_crypt.cc:940:        ldout(s->cct, 5) << "ERROR: Insecure request, rgw_crypt_require_ssl is set" << dendl;
./rgw/rgw_crypt.cc:949:        ldout(s->cct, 5) << "ERROR: rgw_s3_prepare_encrypt invalid encryption "
./rgw/rgw_crypt.cc:958:        ldout(s->cct, 5) << "ERROR: invalid encryption key size" << dendl;
./rgw/rgw_crypt.cc:971:        ldout(s->cct, 5) << "ERROR: rgw_s3_prepare_encrypt invalid encryption key "
./rgw/rgw_crypt.cc:980:        ldout(s->cct, 5) << "ERROR: Invalid key md5 size" << dendl;
./rgw/rgw_crypt.cc:992:        ldout(s->cct, 5) << "ERROR: Invalid key md5 hash" << dendl;
./rgw/rgw_crypt.cc:1013:        ldout(s->cct, 5) << "ERROR: SSE-C encryption request is missing the header "
./rgw/rgw_crypt.cc:1024:        ldout(s->cct, 5) << "ERROR: SSE-C encryption request is missing the header "
./rgw/rgw_crypt.cc:1038:        ldout(s->cct, 5) << "ERROR: Invalid value for header x-amz-server-side-encryption"
./rgw/rgw_crypt.cc:1046:        ldout(s->cct, 5) << "ERROR: insecure request, rgw_crypt_require_ssl is set" << dendl;
./rgw/rgw_crypt.cc:1052:        ldout(s->cct, 5) << "ERROR: not provide a valid key id" << dendl;
./rgw/rgw_crypt.cc:1062:        ldout(s->cct, 5) << "ERROR: failed to retrieve actual key from key_id: " << key_id << dendl;
./rgw/rgw_crypt.cc:1067:        ldout(s->cct, 5) << "ERROR: key obtained from key_id:" <<
./rgw/rgw_crypt.cc:1090:        ldout(s->cct, 5) << "ERROR: SSE-KMS encryption request is missing the header "
./rgw/rgw_crypt.cc:1105:        ldout(s->cct, 5) << "ERROR: rgw_s3_prepare_encrypt invalid default encryption key "
./rgw/rgw_crypt.cc:1114:        ldout(s->cct, 0) << "ERROR: failed to decode 'rgw crypt default encryption key' to 256 bit string" << dendl;
./rgw/rgw_crypt.cc:1152:  ldout(s->cct, 15) << "Encryption mode: " << stored_mode << dendl;
./rgw/rgw_crypt.cc:1162:      ldout(s->cct, 5) << "ERROR: Insecure request, rgw_crypt_require_ssl is set" << dendl;
./rgw/rgw_crypt.cc:1169:      ldout(s->cct, 5) << "ERROR: Request for SSE-C encrypted object missing "
./rgw/rgw_crypt.cc:1176:      ldout(s->cct, 5) << "ERROR: The requested encryption algorithm is not valid, must be AES256." << dendl;
./rgw/rgw_crypt.cc:1185:      ldout(s->cct, 5) << "ERROR: rgw_s3_prepare_decrypt invalid encryption key "
./rgw/rgw_crypt.cc:1194:      ldout(s->cct, 5) << "ERROR: Invalid encryption key size" << dendl;
./rgw/rgw_crypt.cc:1206:      ldout(s->cct, 5) << "ERROR: rgw_s3_prepare_decrypt invalid encryption key md5 "
./rgw/rgw_crypt.cc:1216:      ldout(s->cct, 5) << "ERROR: Invalid key md5 size " << dendl;
./rgw/rgw_crypt.cc:1244:      ldout(s->cct, 5) << "ERROR: Insecure request, rgw_crypt_require_ssl is set" << dendl;
./rgw/rgw_crypt.cc:1253:      ldout(s->cct, 10) << "ERROR: failed to retrieve actual key from key_id: " << key_id << dendl;
./rgw/rgw_crypt.cc:1258:      ldout(s->cct, 0) << "ERROR: key obtained from key_id:" <<
./rgw/rgw_crypt.cc:1279:      ldout(s->cct, 5) << "ERROR: rgw_s3_prepare_decrypt invalid default encryption key "
./rgw/rgw_crypt.cc:1287:      ldout(s->cct, 0) << "ERROR: failed to decode 'rgw crypt default encryption key' to 256 bit string" << dendl;
./rgw/rgw_crypt.cc:1292:      ldout(s->cct, 0) << "ERROR: missing or invalid " RGW_ATTR_CRYPT_KEYSEL << dendl;
./rgw/rgw_gc.cc:197:        ldout(cct, 0) << "WARNING: gc cleanup of tags on gc shard index=" << io.index << " returned error, ret=" << ret << dendl;
./rgw/rgw_gc.cc:203:      ldout(cct, 0) << "WARNING: could not remove oid=" << io.oid << ", ret=" << ret << dendl;
./rgw/rgw_gc.cc:242:      ldout(cct, 0) << "WARNING: failed to remove tags on gc shard index=" << index << " ret=" << ret << dendl;
./rgw/rgw_gc.cc:332:          ldout(store->ctx(), 0) << "WARNING: failed to schedule deletion for oid=" << oid << dendl;
./rgw/rgw_multi.cc:127:      ldout(cct, 0) << "ERROR: could not part info, caught buffer::error" << dendl;
./rgw/rgw_multi.cc:231:    ldout(cct, 5) << "gc->send_chain() returned " << ret << dendl;
./rgw/rgw_multi.cc:294:        ldout(store->ctx(),0) << "WARNING : aborted " << num_deleted << " incomplete multipart uploads" << dendl;
./rgw/rgw_admin.cc:1350:    ldout(store->ctx(), 0) << "ERROR: failed to decode manifest" << dendl;
./rgw/rgw_admin.cc:2561:        ldout(cct, 20) << "found at time=" << start_time - time_ofs << " time_ofs=" << time_ofs << dendl;
./rgw/rgw_admin.cc:5870:        ldout(store->ctx(), 0) << "WARNING: check_min_obj_stripe_size failed, r=" << ret << dendl;
./rgw/rgw_admin.cc:5880:      ldout(store->ctx(), 20) << "skipped object" << dendl;
./rgw/rgw_admin.cc:5970:              ldout(store->ctx(), 0) << "WARNING: check_min_obj_stripe_size failed, r=" << r << dendl;
./rgw/rgw_torrent.cc:62:  ldout(s->cct, 20) << "NOTICE: head obj oid= " << oid << dendl;
./rgw/rgw_torrent.cc:68:    ldout(s->cct, 0) << "ERROR: omap_get_vals_by_keys failed: " << r << dendl;
./rgw/rgw_torrent.cc:72:    ldout(s->cct, 0) << "ERROR: omap key " RGW_OBJ_TORRENT " not found" << dendl;
./rgw/rgw_torrent.cc:112:    ldout(s->cct, 0) << "ERROR: failed to save_torrent_file() ret= "<< ret << dendl;
./rgw/rgw_torrent.cc:195:    ldout(s->cct, 5) << "NOTICE: announce_list is empty " << dendl;    
./rgw/rgw_torrent.cc:248:    ldout(s->cct, 0) << "ERROR: failed to omap_set() op_ret = " << op_ret << dendl;
./rgw/rgw_cache.cc:23:    ldout(cct, 10) << "cache get: name=" << name << " : miss" << dendl;
./rgw/rgw_cache.cc:32:    ldout(cct, 20) << "cache get: touching lru, lru_counter=" << lru_counter
./rgw/rgw_cache.cc:40:      ldout(cct, 10) << "lost race! cache get: name=" << name << " : miss" << dendl;
./rgw/rgw_cache.cc:54:    ldout(cct, 10) << "cache get: name=" << name << " : type miss (requested=0x"
./rgw/rgw_cache.cc:60:  ldout(cct, 10) << "cache get: name=" << name << " : hit (requested=0x"
./rgw/rgw_cache.cc:87:    ldout(cct, 10) << "chain_cache_entry: cache_locator="
./rgw/rgw_cache.cc:91:      ldout(cct, 20) << "chain_cache_entry: couldn't find cache locator" << dendl;
./rgw/rgw_cache.cc:98:      ldout(cct, 20) << "chain_cache_entry: entry.gen (" << entry->gen
./rgw/rgw_cache.cc:125:  ldout(cct, 10) << "cache put: name=" << name << " info.flags=0x"
./rgw/rgw_cache.cc:169:      ldout(cct, 10) << "updating xattr: name=" << iter->first << " bl.length()=" << iter->second.length() << dendl;
./rgw/rgw_cache.cc:174:      ldout(cct, 10) << "removing xattr: name=" << iter->first << dendl;
./rgw/rgw_cache.cc:178:      ldout(cct, 10) << "appending xattr: name=" << iter->first << " bl.length()=" << iter->second.length() << dendl;
./rgw/rgw_cache.cc:202:  ldout(cct, 10) << "removing " << name << " from cache" << dendl;
./rgw/rgw_cache.cc:227:    ldout(cct, 10) << "removing entry: name=" << *iter << " from cache LRU" << dendl;
./rgw/rgw_cache.cc:241:    ldout(cct, 10) << "adding " << name << " to cache LRU end" << dendl;
./rgw/rgw_cache.cc:243:    ldout(cct, 10) << "moving " << name << " to cache LRU end" << dendl;
./rgw/rgw_log.cc:224:  ldout(s->cct, 30) << "log_usage: bucket_name=" << bucket_name
./rgw/rgw_log.cc:326:    ldout(s->cct, 5) << "nothing to log for operation" << dendl;
./rgw/rgw_log.cc:331:      ldout(s->cct, 5) << "bucket " << s->bucket << " doesn't exist, not logging" << dendl;
./rgw/rgw_log.cc:341:    ldout(s->cct, 5) << "not logging op on bucket with non-utf8 name" << dendl;
./rgw/rgw_log.cc:460:    ldout(s->cct, 0) << "ERROR: failed to log entry" << dendl;
./rgw/rgw_rest_swift.cc:828:      ldout(s->cct, 20) << "neither length nor chunked encoding" << dendl;
./rgw/rgw_rest_swift.cc:838:    ldout(s->cct, 5) << "content type wasn't provided, trying to guess" << dendl;
./rgw/rgw_rest_swift.cc:856:    ldout(s->cct, 5) << "ERROR: failed to get Delete-At param" << dendl;
./rgw/rgw_rest_swift.cc:872:      ldout(s->cct, 5) << "invalid multipart-manifest http param: " << multipart_manifest << dendl;
./rgw/rgw_rest_swift.cc:883:      ldout(s->cct, 5) << "failed to read input for slo r=" << r << dendl;
./rgw/rgw_rest_swift.cc:888:      ldout(s->cct, 5) << "too many entries in slo request: " << slo_info->entries.size() << dendl;
./rgw/rgw_rest_swift.cc:899:      ldout(s->cct, 20) << "slo_part: " << entry.path
./rgw/rgw_rest_swift.cc:1054:    ldout(s->cct, 5) << "ERROR: failed to get Delete-At param" << dendl;
./rgw/rgw_rest_swift.cc:1263:      ldout(s->cct, 0) << "ERROR: cannot decode object's " RGW_ATTR_DELETE_AT
./rgw/rgw_rest_swift.cc:1300:    ldout(s->cct, 5) << "ERROR: failed to get Delete-At param" << dendl;
./rgw/rgw_rest_swift.cc:1506:    ldout(s->cct, 20) << "extracted Bulk Delete entry: " << path_str << dendl;
./rgw/rgw_rest_swift.cc:1580:      ldout(s->cct, 20) << "bulk_upload: get_at_most max_to_read="
./rgw/rgw_rest_swift.cc:1598:      ldout(s->cct, 20) << "bulk_upload: get_exactly want=" << want << dendl;
./rgw/rgw_rest_swift.cc:1602:      ldout(s->cct, 20) << "bulk_upload: get_exactly ret=" << ret << dendl;
./rgw/rgw_rest_swift.cc:1617:    ldout(s->cct, 20) << "bulk upload: create_stream for length="
./rgw/rgw_rest_swift.cc:1857:    ldout(cct, 5) << "failed to parse siginfo_expires: " << err << dendl;
./rgw/rgw_rest_swift.cc:1862:    ldout(cct, 5) << "siginfo expired: " << expiration << " <= " << now.sec() << dendl;
./rgw/rgw_rest_swift.cc:1889:    ldout(s->cct, 5) << "failed to parse FormPost's max_file_size: " << err
./rgw/rgw_rest_swift.cc:1928:    ldout(s->cct, 5) << "cannot get user_info of account's owner" << dendl;
./rgw/rgw_rest_swift.cc:1950:    ldout(s->cct, 20) << "FormPost signature [" << temp_url_key_num << "]"
./rgw/rgw_rest_swift.cc:1956:      ldout(s->cct, 5) << "FormPost's signature mismatch: "
./rgw/rgw_rest_swift.cc:2008:  ldout(s->cct, 20) << "temp url user (bucket owner): " << bucket_info.owner
./rgw/rgw_rest_swift.cc:2036:      ldout(s->cct, 20) << "read part header -- part.name="
./rgw/rgw_rest_swift.cc:2040:        ldout(s->cct, 20) << "field.name=" << pair.first << dendl;
./rgw/rgw_rest_swift.cc:2041:        ldout(s->cct, 20) << "field.val=" << pair.second.val << dendl;
./rgw/rgw_rest_swift.cc:2042:        ldout(s->cct, 20) << "field.params:" << dendl;
./rgw/rgw_rest_swift.cc:2045:          ldout(s->cct, 20) << " " << param_pair.first
./rgw/rgw_rest_swift.cc:2492:  ldout(s->cct, 10) << "Starting retarget" << dendl;
./rgw/rgw_rest_swift.cc:2526:  ldout(s->cct, 10) << "Starting object retarget" << dendl;
./rgw/rgw_rest_swift.cc:2958:    ldout(s->cct, 10) << "init_from_header returned err=" << ret <<  dendl;
./rgw/rgw_auth_s3.cc:646:  ldout(cct, 10) << "payload request hash = " << request_payload_hash << dendl;
./rgw/rgw_auth_s3.cc:658:  ldout(cct, 10) << "canonical request = " << canonical_req << dendl;
./rgw/rgw_auth_s3.cc:659:  ldout(cct, 10) << "canonical request hash = "
./rgw/rgw_auth_s3.cc:687:  ldout(cct, 10) << "string to sign = "
./rgw/rgw_auth_s3.cc:759:  ldout(cct, 10) << "date_k    = " << buf_to_hex(date_k).data() << dendl;
./rgw/rgw_auth_s3.cc:760:  ldout(cct, 10) << "region_k  = " << buf_to_hex(region_k).data() << dendl;
./rgw/rgw_auth_s3.cc:761:  ldout(cct, 10) << "service_k = " << buf_to_hex(service_k).data() << dendl;
./rgw/rgw_auth_s3.cc:762:  ldout(cct, 10) << "signing_k = " << buf_to_hex(signing_key).data() << dendl;
./rgw/rgw_auth_s3.cc:794:  ldout(cct, 10) << "generated signature = " << signature << dendl;
./rgw/rgw_auth_s3.cc:817:    ldout(cct, 10) << "ceph_armor failed" << dendl;
./rgw/rgw_auth_s3.cc:853:    ldout(cct, 20) << "AWSv4ComplMulti cannot find the ';' separator"
./rgw/rgw_auth_s3.cc:862:    ldout(cct, 20) << "AWSv4ComplMulti: cannot parse the data size"
./rgw/rgw_auth_s3.cc:871:    ldout(cct, 20) << "AWSv4ComplMulti: cannot find the '=' separator"
./rgw/rgw_auth_s3.cc:879:    ldout(cct, 20) << "AWSv4ComplMulti: no new line at signature end"
./rgw/rgw_auth_s3.cc:887:    ldout(cct, 20) << "AWSv4ComplMulti: signature.length() != 64"
./rgw/rgw_auth_s3.cc:896:  ldout(cct, 20) << "parsed new chunk; signature=" << signature
./rgw/rgw_auth_s3.cc:918:  ldout(cct, 20) << "AWSv4ComplMulti: string_to_sign=\n" << string_to_sign
./rgw/rgw_auth_s3.cc:937:    ldout(cct, 20) << "AWSv4ComplMulti: ERROR: chunk signature mismatch"
./rgw/rgw_auth_s3.cc:939:    ldout(cct, 20) << "AWSv4ComplMulti: declared signature="
./rgw/rgw_auth_s3.cc:941:    ldout(cct, 20) << "AWSv4ComplMulti: calculated signature="
./rgw/rgw_auth_s3.cc:1051:      ldout(cct, 10) << "negative AWSv4's content length, aborting" << dendl;
./rgw/rgw_auth_s3.cc:1065:    ldout(cct, 10) << "ERROR: signature of last chunk does not match"
./rgw/rgw_auth_s3.cc:1123:    ldout(cct, 10) << "ERROR: x-amz-content-sha256 does not match"
./rgw/rgw_auth_s3.cc:1125:    ldout(cct, 10) << "ERROR:   grab_aws4_sha256_hash()="
./rgw/rgw_auth_s3.cc:1127:    ldout(cct, 10) << "ERROR:   expected_request_payload_hash="
./rgw/rgw_iam_policy.cc:770:  ldout(cct, 0) << "Supplied principal is discarded: " << s << dendl;
./rgw/rgw_iam_policy.cc:819:      ldout(cct, 0) << "Supplied resource is discarded: " << string(s, l)
./rgw/rgw_lc.cc:151:      ldout(cct, 2) << "life cycle: start" << dendl;
./rgw/rgw_lc.cc:154:        ldout(cct, 0) << "ERROR: do life cycle process() returned error r=" << r << dendl;
./rgw/rgw_lc.cc:156:      ldout(cct, 2) << "life cycle: stop" << dendl;
./rgw/rgw_lc.cc:166:    ldout(cct, 5) << "schedule life cycle next start time: " << rgw_to_asctime(next) << dendl;
./rgw/rgw_lc.cc:243:        ldout(cct, 0) << "RGWLC::bucket_lc_prepare() failed to set entry on "
./rgw/rgw_lc.cc:311:          ldout(cct, 0) << "ERROR: store->list_objects():" <<dendl;
./rgw/rgw_lc.cc:324:            ldout(cct, 0) << "ERROR: abort_multipart_upload failed, ret=" << ret << ", meta:" << obj_iter->key << dendl;
./rgw/rgw_lc.cc:326:            ldout(cct, 5) << "ERROR: abort_multipart_upload failed, ret=" << ret << ", meta:" << obj_iter->key << dendl;
./rgw/rgw_lc.cc:362:    ldout(cct, 0) << "LC:get_bucket_info for " << bucket_name << " failed" << dendl;
./rgw/rgw_lc.cc:368:    ldout(cct, 0) << "LC:old bucket id found. " << bucket_name << " should be deleted" << dendl;
./rgw/rgw_lc.cc:383:      ldout(cct, 0) << __func__ <<  "() decode life cycle config failed" << dendl;
./rgw/rgw_lc.cc:408:          ldout(cct, 0) << "ERROR: store->list_objects():" <<dendl;
./rgw/rgw_lc.cc:423:                ldout(cct, 5) << "ERROR: read_obj_tags returned r=" << ret << dendl;
./rgw/rgw_lc.cc:431:               ldout(cct,0) << "ERROR: caught buffer::error, couldn't decode TagSet" << dendl;
./rgw/rgw_lc.cc:439:              ldout(cct, 20) << __func__ << "() skipping obj " << key << " as tags do not match" << dendl;
./rgw/rgw_lc.cc:460:              ldout(cct, 20) << __func__ << "() skipping removal: state->mtime " << state->mtime << " obj->mtime " << obj_iter->meta.mtime << dendl;
./rgw/rgw_lc.cc:465:              ldout(cct, 0) << "ERROR: remove_expired_obj " << dendl;
./rgw/rgw_lc.cc:467:              ldout(cct, 2) << "DELETED:" << bucket_name << ":" << key << dendl;
./rgw/rgw_lc.cc:504:          ldout(cct, 0) << "ERROR: store->list_objects():" <<dendl;
./rgw/rgw_lc.cc:570:              ldout(cct, 0) << "ERROR: remove_expired_obj " << dendl;
./rgw/rgw_lc.cc:572:              ldout(cct, 2) << "DELETED:" << bucket_name << ":" << obj_iter->key << dendl;
./rgw/rgw_lc.cc:599:      ldout(cct, 0) << "RGWLC::bucket_lc_post() failed to acquire lock on "
./rgw/rgw_lc.cc:606:    ldout(cct, 20) << "RGWLC::bucket_lc_post() lock " << obj_names[index] << dendl;
./rgw/rgw_lc.cc:610:        ldout(cct, 0) << "RGWLC::bucket_lc_post() failed to remove entry "
./rgw/rgw_lc.cc:622:      ldout(cct, 0) << "RGWLC::process() failed to set entry on "
./rgw/rgw_lc.cc:627:    ldout(cct, 20) << "RGWLC::bucket_lc_post() unlock " << obj_names[index] << dendl;
./rgw/rgw_lc.cc:641:        ldout(cct, 10) << __func__ << "() ignoring unfound lc object="
./rgw/rgw_lc.cc:686:      ldout(cct, 0) << "RGWLC::process() failed to acquire lock on "
./rgw/rgw_lc.cc:697:      ldout(cct, 0) << "RGWLC::process() failed to get obj head "
./rgw/rgw_lc.cc:707:      ldout(cct, 0) << "RGWLC::process() failed to update lc object "
./rgw/rgw_lc.cc:715:      ldout(cct, 0) << "RGWLC::process() failed to get obj entry "
./rgw/rgw_lc.cc:726:      ldout(cct, 0) << "RGWLC::process() failed to set obj entry " << obj_names[index]
./rgw/rgw_lc.cc:734:      ldout(cct, 0) << "RGWLC::process() failed to put head " << obj_names[index] << dendl;
./rgw/rgw_rest_role.cc:32:  ldout(s->cct, 0) << "INFO: verify_permissions ret" << ret << dendl;
./rgw/rgw_rest_role.cc:53:    ldout(s->cct, 20) << "ERROR: one of role name or assume role policy document is empty"
./rgw/rgw_rest_role.cc:59:    ldout(s->cct, 20) << "ERROR: failed to parse assume role policy doc" << dendl;
./rgw/rgw_rest_role.cc:90:    ldout(s->cct, 20) << "ERROR: Role name is empty"<< dendl;
./rgw/rgw_rest_role.cc:116:    ldout(s->cct, 20) << "ERROR: Role name is empty"<< dendl;
./rgw/rgw_rest_role.cc:149:    ldout(s->cct, 20) << "ERROR: One of role name or trust policy is empty"<< dendl;
./rgw/rgw_rest_role.cc:154:    ldout(s->cct, 20) << "ERROR: failed to parse assume role policy doc" << dendl;
./rgw/rgw_rest_role.cc:213:    ldout(s->cct, 20) << "ERROR: One of role name, policy name or perm policy is empty"<< dendl;
./rgw/rgw_rest_role.cc:218:    ldout(s->cct, 20) << "ERROR: failed to parse perm role policy doc" << dendl;
./rgw/rgw_rest_role.cc:246:    ldout(s->cct, 20) << "ERROR: One of role name or policy name is empty"<< dendl;
./rgw/rgw_rest_role.cc:285:    ldout(s->cct, 20) << "ERROR: Role name is empty"<< dendl;
./rgw/rgw_rest_role.cc:321:    ldout(s->cct, 20) << "ERROR: One of role name or policy name is empty"<< dendl;
./rgw/rgw_user.cc:57:      ldout(cct, 0) << "failed to read user buckets: ret=" << ret << dendl;
./rgw/rgw_user.cc:71:        ldout(cct, 0) << "ERROR: could not read bucket info: bucket=" << bucket_ent.bucket << " ret=" << ret << dendl;
./rgw/rgw_user.cc:76:        ldout(cct, 0) << "ERROR: could not sync bucket stats: ret=" << ret << dendl;
./rgw/rgw_user.cc:82:	ldout(cct, 0) << "ERROR in check_bucket_shards: " << cpp_strerror(-ret)<< dendl;
./rgw/rgw_user.cc:110:      ldout(cct, 0) << "failed to read user buckets: ret=" << ret << dendl;
./rgw/rgw_user.cc:121:        ldout(cct, 0) << "ERROR: could not get bucket stats: ret=" << ret << dendl;
./rgw/rgw_user.cc:169:      ldout(store->ctx(), 0) << "WARNING: can't store user info, swift id (" << k.id
./rgw/rgw_user.cc:185:        ldout(store->ctx(), 0) << "WARNING: can't store user info, access key already mapped to another user" << dendl;
./rgw/rgw_user.cc:290:    ldout(store->ctx(), 0) << "ERROR: failed to decode user info, caught buffer::error" << dendl;
./rgw/rgw_user.cc:338:    ldout(store->ctx(), 0) << "ERROR: failed to decode user info, caught buffer::error" << dendl;
./rgw/rgw_user.cc:449:    ldout(store->ctx(), 10) << "removing key index: " << kiter->first << dendl;
./rgw/rgw_user.cc:452:      ldout(store->ctx(), 0) << "ERROR: could not remove " << kiter->first << " (access key object), should be fixed (err=" << ret << ")" << dendl;
./rgw/rgw_user.cc:460:    ldout(store->ctx(), 10) << "removing swift subuser index: " << k.id << dendl;
./rgw/rgw_user.cc:464:      ldout(store->ctx(), 0) << "ERROR: could not remove " << k.id << " (swift name object), should be fixed (err=" << ret << ")" << dendl;
./rgw/rgw_user.cc:469:  ldout(store->ctx(), 10) << "removing email index: " << info.user_email << dendl;
./rgw/rgw_user.cc:472:    ldout(store->ctx(), 0) << "ERROR: could not remove email index object for "
./rgw/rgw_user.cc:480:  ldout(store->ctx(), 10) << "removing user buckets index" << dendl;
./rgw/rgw_user.cc:483:    ldout(store->ctx(), 0) << "ERROR: could not remove " << info.user_id << ":" << uid_bucks << ", should be fixed (err=" << ret << ")" << dendl;
./rgw/rgw_user.cc:491:  ldout(store->ctx(), 10) << "removing user index: " << info.user_id << dendl;
./rgw/rgw_user.cc:494:    ldout(store->ctx(), 0) << "ERROR: could not remove " << info.user_id << ":" << uid_obj << ", should be fixed (err=" << ret << ")" << dendl;
./rgw/rgw_user.cc:613:      ldout(store->ctx(), 0) << "ERROR: tenant mismatch: " << old_info.user_id.tenant << " != " << new_info.user_id.tenant << dendl;
./rgw/rgw_user.cc:2177:    ldout(store->ctx(), 10) << "removing email index: " << user_info.user_email << dendl;
./rgw/rgw_user.cc:2180:      ldout(store->ctx(), 0) << "ERROR: could not remove " << user_info.user_id << " index (err=" << ret << ")" << dendl;
./rgw/rgw_sync.cc:106:        ldout(cct, 0) << "ERROR: RGWBackoffControlCR called coroutine returned " << retcode << dendl;
./rgw/rgw_sync.cc:120:      ldout(cct, 0) << "ERROR: call to finisher_cr() failed: retcode=" << retcode << dendl;
./rgw/rgw_sync.cc:161:            ldout(cct, 10) << __func__ << ": failed to fetch log status, ret=" << child_ret << dendl;
./rgw/rgw_sync.cc:173:          ldout(cct, 10) << __func__ << ": failed to fetch log status, ret=" << child_ret << dendl;
./rgw/rgw_sync.cc:243:    ldout(store->ctx(), 0) << "ERROR: failed to fetch mdlog info" << dendl;
./rgw/rgw_sync.cc:247:  ldout(store->ctx(), 20) << "remote mdlog, num_shards=" << log_info->num_shards << dendl;
./rgw/rgw_sync.cc:282:    ldout(store->ctx(), 0) << "failed in http_manager.start() ret=" << ret << dendl;
./rgw/rgw_sync.cc:496:          ldout(store->ctx(), 0) << "ERROR: failed to read from " << p << dendl;
./rgw/rgw_sync.cc:560:      ldout(store->ctx(), 0) << "ERROR: failed to read from " << p << dendl;
./rgw/rgw_sync.cc:573:      ldout(sync_env->store->ctx(), 0) << "ERROR: failed to list remote mdlog shard, ret=" << ret << dendl;
./rgw/rgw_sync.cc:634:          ldout(cct, 5) << "lease cr failed, done early " << dendl;
./rgw/rgw_sync.cc:651:        ldout(cct, 0) << "ERROR: failed to write sync status, retcode=" << retcode << dendl;
./rgw/rgw_sync.cc:758:      ldout(sync_env->cct, 4) << "failed to read sync status info with "
./rgw/rgw_sync.cc:767:      ldout(sync_env->cct, 4) << "failed to read sync status markers with "
./rgw/rgw_sync.cc:873:          ldout(cct, 5) << "lease cr failed, done early " << dendl;
./rgw/rgw_sync.cc:888:        ldout(cct, 0) << "ERROR: failed to fetch metadata sections" << dendl;
./rgw/rgw_sync.cc:1038:          ldout(sync_env->cct, 0) << "ERROR: failed to fetch mdlog data" << dendl;
./rgw/rgw_sync.cc:1067:      ldout(store->ctx(), 0) << "ERROR: can't store key: " << raw_key << " ret=" << ret << dendl;
./rgw/rgw_sync.cc:1119:      ldout(store->ctx(), 0) << "ERROR: can't remove key: " << raw_key << " ret=" << ret << dendl;
./rgw/rgw_sync.cc:1210:    ldout(sync_env->cct, 20) << __func__ << "(): updating marker marker_oid=" << marker_oid << " marker=" << new_marker << " realm_epoch=" << sync_marker.realm_epoch << dendl;
./rgw/rgw_sync.cc:1247:      ldout(sync_env->cct, 0) << __FILE__ << ":" << __LINE__ << ": injecting meta sync error on key=" << raw_key << dendl;
./rgw/rgw_sync.cc:1277:        ldout(sync_env->cct, 20) << *this << ": failed to fetch remote metadata: " << section << ":" << key << ", will retry" << dendl;
./rgw/rgw_sync.cc:1302:        ldout(sync_env->cct, 20) << *this << ": failed to store metadata: " << section << ":" << key << ", got retcode=" << retcode << dendl;
./rgw/rgw_sync.cc:1460:          ldout(sync_env->cct, 10) << "sync: full_sync: shard_id=" << shard_id << " r=" << r << dendl;
./rgw/rgw_sync.cc:1467:          ldout(sync_env->cct, 10) << "sync: incremental_sync: shard_id=" << shard_id << " r=" << r << dendl;
./rgw/rgw_sync.cc:1491:        ldout(sync_env->cct, 0) << *this << ": child operation stack=" << child << " entry=" << pos << " returned " << child_ret << dendl;
./rgw/rgw_sync.cc:1520:      ldout(sync_env->cct, 4) << *this << ": adjusting marker pos=" << sync_marker.marker << dendl;
./rgw/rgw_sync.cc:1577:          ldout(sync_env->cct, 0) << "ERROR: " << __func__ << "(): RGWRadosGetOmapKeysCR() returned ret=" << retcode << dendl;
./rgw/rgw_sync.cc:1624:	  ldout(sync_env->cct, 4) << *this << ": saving marker pos=" << temp_marker->marker << " realm_epoch=" << realm_epoch << dendl;
./rgw/rgw_sync.cc:1633:          ldout(sync_env->cct, 0) << "ERROR: failed to set sync marker: retcode=" << retcode << dendl;
./rgw/rgw_sync.cc:1701:        ldout(sync_env->cct, 4) << "clearing marker=" << sync_marker.marker
./rgw/rgw_sync.cc:1728:        ldout(sync_env->cct, 20) << __func__ << ":" << __LINE__ << ": shard_id=" << shard_id << " mdlog_marker=" << mdlog_marker << " sync_marker.marker=" << sync_marker.marker << " period_marker=" << period_marker << dendl;
./rgw/rgw_sync.cc:1736:          ldout(sync_env->cct, 20) << __func__ << ":" << __LINE__ << ": shard_id=" << shard_id << " syncing mdlog for shard_id=" << shard_id << dendl;
./rgw/rgw_sync.cc:1771:              ldout(cct, 10) << "found key at period_marker=" << period_marker << dendl;
./rgw/rgw_sync.cc:1780:              ldout(sync_env->cct, 0) << "ERROR: cannot start syncing " << log_iter->id << ". Duplicate entry?" << dendl;
./rgw/rgw_sync.cc:1795:	ldout(sync_env->cct, 20) << __func__ << ":" << __LINE__ << ": shard_id=" << shard_id << " mdlog_marker=" << mdlog_marker << " max_marker=" << max_marker << " sync_marker.marker=" << sync_marker.marker << " period_marker=" << period_marker << dendl;
./rgw/rgw_sync.cc:1919:            ldout(cct, 10) << "RGWMetaSyncCR on current period="
./rgw/rgw_sync.cc:1922:            ldout(cct, 10) << "RGWMetaSyncCR with no period" << dendl;
./rgw/rgw_sync.cc:1927:          ldout(cct, 10) << "RGWMetaSyncCR on period="
./rgw/rgw_sync.cc:1954:                ldout(cct, 10) << "RGWMetaSyncCR: skipping shard " << shard_id
./rgw/rgw_sync.cc:2028:    ldout(store->ctx(), 0) << "failed in http_manager.start() ret=" << ret << dendl;
./rgw/rgw_sync.cc:2124:      ldout(store->ctx(), 1) << __func__ << "(): going down" << dendl;
./rgw/rgw_sync.cc:2130:      ldout(store->ctx(), 10) << __func__ << "(): waiting for master.." << dendl;
./rgw/rgw_sync.cc:2145:      ldout(store->ctx(), 1) << __func__ << "(): going down" << dendl;
./rgw/rgw_sync.cc:2150:      ldout(store->ctx(), 0) << "ERROR: failed to fetch sync status r=" << r << dendl;
./rgw/rgw_sync.cc:2168:        ldout(store->ctx(), 1) << "epoch=" << sync_status.sync_info.realm_epoch
./rgw/rgw_sync.cc:2175:      ldout(store->ctx(), 20) << __func__ << "(): init" << dendl;
./rgw/rgw_sync.cc:2190:        ldout(store->ctx(), 0) << "ERROR: failed to init sync status r=" << r << dendl;
./rgw/rgw_sync.cc:2268:        ldout(cct, 20) << __func__ << ": shard_id=" << shard_id << ": init request" << dendl;
./rgw/rgw_sync.cc:2272:        ldout(cct, 20) << __func__ << ": shard_id=" << shard_id << ": reading shard status" << dendl;
./rgw/rgw_sync.cc:2276:        ldout(cct, 20) << __func__ << ": shard_id=" << shard_id << ": reading shard status complete" << dendl;
./rgw/rgw_sync.cc:2280:        ldout(cct, 20) << __func__ << ": shard_id=" << shard_id << ": sending rest request" << dendl;
./rgw/rgw_sync.cc:2284:        ldout(cct, 20) << __func__ << ": shard_id=" << shard_id << ": receiving rest response" << dendl;
./rgw/rgw_sync.cc:2288:        ldout(cct, 20) << __func__ << ": shard_id=" << shard_id << ": storing mdlog entries" << dendl;
./rgw/rgw_sync.cc:2293:      ldout(cct, 20) << __func__ << ": shard_id=" << shard_id << ": storing mdlog entries complete" << dendl;
./rgw/rgw_sync.cc:2315:        ldout(cct, 1) << "ERROR: failed to read mdlog info with "
./rgw/rgw_sync.cc:2327:    ldout(cct, 0) << "ERROR: mdlog->get_info_async() returned ret=" << ret << dendl;
./rgw/rgw_sync.cc:2338:  ldout(cct, 20) << "shard_id=" << shard_id << " marker=" << shard_info.marker << " last_update=" << shard_info.last_update << dendl;
./rgw/rgw_sync.cc:2370:    ldout(cct, 0) << "ERROR: failed to fetch mdlog data" << dendl;
./rgw/rgw_sync.cc:2385:    ldout(cct, 5) << "failed to wait for op, ret=" << ret << dendl;
./rgw/rgw_sync.cc:2393:  ldout(cct, 20) << "remote mdlog, shard_id=" << shard_id << " num of shard entries: " << data.entries.size() << dendl;
./rgw/rgw_sync.cc:2419:    ldout(cct, 20) << "entry: name=" << entry.name << dendl;
./rgw/rgw_sync.cc:2439:    ldout(cct, 10) << "failed to store md log entries shard_id=" << shard_id << " ret=" << ret << dendl;
./rgw/rgw_sync.cc:2511:    ldout(cct, 20) << "oldest log realm_epoch=" << cursor.get_epoch()
./rgw/rgw_sync.cc:2516:      ldout(cct, 4) << "purging log shards for realm_epoch=" << cursor.get_epoch()
./rgw/rgw_sync.cc:2525:        ldout(cct, 1) << "failed to remove log shards: "
./rgw/rgw_sync.cc:2529:      ldout(cct, 10) << "removed log shards for realm_epoch=" << cursor.get_epoch()
./rgw/rgw_sync.cc:2537:        ldout(cct, 10) << "already removed log shards for realm_epoch=" << cursor.get_epoch()
./rgw/rgw_sync.cc:2541:        ldout(cct, 1) << "failed to remove log shards for realm_epoch="
./rgw/rgw_sync.cc:2607:      ldout(cct, 1) << "take_min_status got peer status with "
./rgw/rgw_sync.cc:2714:      ldout(cct, 20) << "skipping log shard " << shard_id
./rgw/rgw_sync.cc:2724:    ldout(cct, 10) << "trimming log shard " << shard_id
./rgw/rgw_sync.cc:2758:    ldout(cct, 20) << "query sync status from " << c->first << dendl;
./rgw/rgw_sync.cc:2787:      ldout(cct, 4) << "no peers, exiting" << dendl;
./rgw/rgw_sync.cc:2791:    ldout(cct, 10) << "fetching sync status for zone " << env.zone << dendl;
./rgw/rgw_sync.cc:2797:      ldout(cct, 4) << "failed to fetch sync status from all peers" << dendl;
./rgw/rgw_sync.cc:2805:      ldout(cct, 4) << "failed to calculate min sync status from peers" << dendl;
./rgw/rgw_sync.cc:2811:      ldout(cct, 4) << "realm epoch min=" << epoch
./rgw/rgw_sync.cc:2817:        ldout(cct, 10) << "mdlogs already purged up to realm_epoch "
./rgw/rgw_sync.cc:2863:      ldout(cct, 5) << "failed to read first entry from master's mdlog shard "
./rgw/rgw_sync.cc:2874:      ldout(cct, 10) << "empty master mdlog shard " << shard_id
./rgw/rgw_sync.cc:2880:        ldout(cct, 5) << "failed to read info from master's mdlog shard "
./rgw/rgw_sync.cc:2888:      ldout(cct, 10) << "got mdlog shard info with last update="
./rgw/rgw_sync.cc:2894:        ldout(cct, 5) << "failed to read first entry from master's mdlog shard "
./rgw/rgw_sync.cc:2915:      ldout(cct, 10) << "skipping log shard " << shard_id
./rgw/rgw_sync.cc:2921:    ldout(cct, 10) << "trimming log shard " << shard_id
./rgw/rgw_sync.cc:2930:      ldout(cct, 1) << "failed to trim mdlog shard " << shard_id
./rgw/rgw_sync.cc:2987:    ldout(cct, 10) << "fetching master mdlog info" << dendl;
./rgw/rgw_sync.cc:3000:      ldout(cct, 4) << "failed to read mdlog info from master" << dendl;
./rgw/rgw_sync.cc:3011:      ldout(cct, 10) << "mdlogs already purged through realm_epoch "
./rgw/rgw_sync.cc:3062:        ldout(cct, 4) << "failed to lock: " << cpp_strerror(retcode) << dendl;
./rgw/rgw_sync_trace.cc:78:    ldout(store->ctx(), 0) << "ERROR: update_service_map() returned ret=" << ret << dendl;
./rgw/rgw_sync_trace.cc:116:    ldout(cct, 5) << "NOTICE: sync trace: bad expression: bad regex search term" << dendl;
./rgw/rgw_rest.cc:207:  ldout(cct, 20) << "RGW hostnames: " << hostnames_set << dendl;
./rgw/rgw_rest.cc:221:  ldout(cct, 20) << "RGW S3website hostnames: " << hostnames_s3website_set << dendl;
./rgw/rgw_rest.cc:277:    ldout(s->cct, 0) << "ERROR: s->cio->send_status() returned err="
./rgw/rgw_rest.cc:333:    ldout(s->cct, 0) << "ERROR: s->cio->send_header() returned err="
./rgw/rgw_rest.cc:392:    ldout(s->cct, 0) << "ERROR: s->cio->send_content_length() returned err="
./rgw/rgw_rest.cc:403:    ldout(s->cct, 0) << "ERROR: RESTFUL_IO(s)->send_chunked_transfer_encoding()"
./rgw/rgw_rest.cc:638:    ldout(s->cct, 0) << "ERROR: RESTFUL_IO(s)->complete_header() returned err="
./rgw/rgw_rest.cc:676:    ldout(s->cct, 20) << "op->ERRORHANDLER: err_no=" << err_no
./rgw/rgw_rest.cc:682:    ldout(s->cct, 20) << "handler->ERRORHANDLER: err_no=" << err_no
./rgw/rgw_rest.cc:739:    ldout(s->cct, 0) << "ERROR: RESTFUL_IO(s)->send_100_continue() returned err="
./rgw/rgw_rest.cc:1033:    ldout(s->cct, 5) << "NOTICE:  open produce torrent file " << dendl;
./rgw/rgw_rest.cc:1425:    ldout(s->cct, 20) << "request content_type_str="
./rgw/rgw_rest.cc:1427:    ldout(s->cct, 20) << "request content_type params:" << dendl;
./rgw/rgw_rest.cc:1430:      ldout(s->cct, 20) << " " << pair.first << " -> " << pair.second
./rgw/rgw_rest.cc:1584:      ldout(s->cct, 20) << "bad marker: "  << marker << dendl;
./rgw/rgw_rest.cc:2001:  ldout(s->cct, 10) << "rgw api priority: s3=" << api_priority_s3 << " s3website=" << api_priority_s3website << dendl;
./rgw/rgw_rest.cc:2009:    ldout(s->cct, 10) << "host=" << info.host << dendl;
./rgw/rgw_rest.cc:2027:    ldout(s->cct, 20)
./rgw/rgw_rest.cc:2041:	ldout(s->cct, 0)
./rgw/rgw_rest.cc:2047:	ldout(s->cct, 5) << "resolved host cname " << info.host << " -> "
./rgw/rgw_rest.cc:2066:        ldout(s->cct, 20)
./rgw/rgw_rest.cc:2115:    ldout(s->cct, 20)
./rgw/rgw_rest.cc:2195:	ldout(s->cct, 10) << "bad content length, aborting" << dendl;
./rgw/rgw_rest.cc:2202:    ldout(s->cct, 10) << "negative content length, aborting" << dendl;
./rgw/rgw_realm_watcher.cc:20:    ldout(cct, 4) << "No realm, disabling dynamic reconfiguration." << dendl;
./rgw/rgw_realm_watcher.cc:77:    ldout(cct, 4) << "Disconnected watch on " << watch_oid << dendl;
./rgw/rgw_realm_watcher.cc:119:  ldout(cct, 10) << "Watching " << oid << dendl;
./rgw/rgw_sync_module_es_rest.cc:211:    ldout(s->cct, 10) << "invalid query, failed generating request json" << dendl;
./rgw/rgw_sync_module_es_rest.cc:238:  ldout(s->cct, 20) << "sending request to elasticsearch, payload=" << string(in.c_str(), in.length()) << dendl;
./rgw/rgw_sync_module_es_rest.cc:241:    ldout(s->cct, 0) << "ERROR: failed to fetch resource (r=" << resource << ", ret=" << op_ret << ")" << dendl;
./rgw/rgw_sync_module_es_rest.cc:245:  ldout(s->cct, 20) << "response: " << string(out.c_str(), out.length()) << dendl;
./rgw/rgw_sync_module_es_rest.cc:249:    ldout(s->cct, 0) << "ERROR: failed to parse elasticsearch response" << dendl;
./rgw/rgw_sync_module_es_rest.cc:257:    ldout(s->cct, 0) << "ERROR: failed to decode JSON input: " << e.message << dendl;
./rgw/rgw_sync_module_es_rest.cc:408:  ldout(s->cct, 20) << __func__ << " handler=" << typeid(*handler).name()
./rgw/rgw_quota.cc:114:      ldout(store->ctx(), 20) << "quota: can't use cached stats, exceeded soft threshold (size): "
./rgw/rgw_quota.cc:126:      ldout(store->ctx(), 20) << "quota: can't use cached stats, exceeded soft threshold (num objs): "
./rgw/rgw_quota.cc:163:  ldout(store->ctx(), 20) << "async stats refresh response for bucket=" << bucket << dendl;
./rgw/rgw_quota.cc:171:  ldout(store->ctx(), 20) << "async stats refresh response for bucket=" << bucket << dendl;
./rgw/rgw_quota.cc:202:        ldout(store->ctx(), 0) << "ERROR: quota async refresh returned ret=" << r << dendl;
./rgw/rgw_quota.cc:298:    ldout(store->ctx(), 0) << "could not get bucket info for bucket=" << bucket << " r=" << r << dendl;
./rgw/rgw_quota.cc:302:  ldout(store->ctx(), 20) << "initiating async quota refresh for bucket=" << bucket << dendl;
./rgw/rgw_quota.cc:306:    ldout(store->ctx(), 0) << "could not get bucket info for bucket=" << bucket.name << dendl;
./rgw/rgw_quota.cc:318:    ldout(store->ctx(), 20) << "AsyncRefreshHandler::handle_response() r=" << r << dendl;
./rgw/rgw_quota.cc:369:    ldout(store->ctx(), 0) << "could not get bucket info for bucket=" << bucket << " r=" << r << dendl;
./rgw/rgw_quota.cc:380:    ldout(store->ctx(), 0) << "could not get bucket stats for bucket="
./rgw/rgw_quota.cc:415:  ldout(store->ctx(), 20) << "initiating async quota refresh for user=" << user << dendl;
./rgw/rgw_quota.cc:418:    ldout(store->ctx(), 0) << "could not get bucket info for user=" << user << dendl;
./rgw/rgw_quota.cc:430:    ldout(store->ctx(), 20) << "AsyncRefreshHandler::handle_response() r=" << r << dendl;
./rgw/rgw_quota.cc:455:      ldout(cct, 20) << "BucketsSyncThread: start" << dendl;
./rgw/rgw_quota.cc:464:          ldout(cct, 20) << "BucketsSyncThread: sync user=" << user << " bucket=" << bucket << dendl;
./rgw/rgw_quota.cc:467:            ldout(cct, 0) << "WARNING: sync_bucket() returned r=" << r << dendl;
./rgw/rgw_quota.cc:478:      ldout(cct, 20) << "BucketsSyncThread: done" << dendl;
./rgw/rgw_quota.cc:507:      ldout(cct, 20) << "UserSyncThread: start" << dendl;
./rgw/rgw_quota.cc:511:          ldout(cct, 5) << "ERROR: sync_all_users() returned ret=" << ret << dendl;
./rgw/rgw_quota.cc:521:      ldout(cct, 20) << "UserSyncThread: done" << dendl;
./rgw/rgw_quota.cc:617:    ldout(store->ctx(), 0) << "could not get user stats for user=" << user << dendl;
./rgw/rgw_quota.cc:632:    ldout(store->ctx(), 0) << "could not get bucket info for bucket=" << bucket << " r=" << r << dendl;
./rgw/rgw_quota.cc:638:    ldout(store->ctx(), 0) << "ERROR: rgw_bucket_sync_user_stats() for user=" << user << ", bucket=" << bucket << " returned " << r << dendl;
./rgw/rgw_quota.cc:651:    ldout(store->ctx(), 5) << "ERROR: can't read user header: ret=" << ret << dendl;
./rgw/rgw_quota.cc:657:    ldout(store->ctx(), 20) << "user is idle, not doing a full sync (user=" << user << ")" << dendl;
./rgw/rgw_quota.cc:669:    ldout(store->ctx(), 0) << "ERROR: failed user stats sync, ret=" << ret << dendl;
./rgw/rgw_quota.cc:683:    ldout(store->ctx(), 10) << "ERROR: can't get key: ret=" << ret << dendl;
./rgw/rgw_quota.cc:694:      ldout(store->ctx(), 0) << "ERROR: lists_keys_next(): ret=" << ret << dendl;
./rgw/rgw_quota.cc:701:      ldout(store->ctx(), 20) << "RGWUserStatsCache: sync user=" << user << dendl;
./rgw/rgw_quota.cc:704:        ldout(store->ctx(), 5) << "ERROR: sync_user() failed, user=" << user << " ret=" << ret << dendl;
./rgw/rgw_quota.cc:897:    ldout(store->ctx(), 20) << entity
./rgw/rgw_quota.cc:910:    ldout(store->ctx(), 20) << entity << " quota OK:"
./rgw/rgw_quota.cc:982:      ldout(store->ctx(), 0) << __func__ << ": resharding needed: stats.num_objects=" << bucket_stats.num_objects
./rgw/rgw_ldap.cc:22:    ldout(ctx, 10)
./rgw/rgw_ldap.cc:77:    ldout(g_ceph_context, 12)
./rgw/rgw_ldap.cc:95:	  ldout(g_ceph_context, 10)
./rgw/rgw_ldap.cc:102:	ldout(g_ceph_context, 12)
./rgw/rgw_ldap.cc:109:      ldout(g_ceph_context, 5)
./rgw/rgw_sync_module_es.cc:291:          ldout(cct, 0) << "ERROR: failed to decode acl for " << bucket_info.bucket << "/" << key << dendl;
./rgw/rgw_sync_module_es.cc:349:          ldout(cct, 20) << "custom meta entry key=" << i.first << " not found in bucket mdsearch config: " << bucket_info.mdsearch_config << dendl;
./rgw/rgw_sync_module_es.cc:395:          ldout(cct, 20) << __func__ << "(): failed to parse time (" << i.second << "), skipping encoding of custom date attribute" << dendl;
./rgw/rgw_sync_module_es.cc:434:      ldout(sync_env->cct, 0) << ": init elasticsearch config zone=" << sync_env->source_zone << dendl;
./rgw/rgw_sync_module_es.cc:468:      ldout(sync_env->cct, 10) << ": stat of remote obj: z=" << sync_env->source_zone
./rgw/rgw_sync_module_es.cc:521:      ldout(sync_env->cct, 10) << ": remove remote obj: z=" << sync_env->source_zone
./rgw/rgw_sync_module_es.cc:553:    ldout(sync_env->cct, 5) << conf->id << ": init" << dendl;
./rgw/rgw_sync_module_es.cc:557:    ldout(sync_env->cct, 10) << conf->id << ": sync_object: b=" << bucket_info.bucket << " k=" << key << " versioned_epoch=" << versioned_epoch << dendl;
./rgw/rgw_sync_module_es.cc:559:      ldout(sync_env->cct, 10) << conf->id << ": skipping operation (bucket not approved)" << dendl;
./rgw/rgw_sync_module_es.cc:566:    ldout(sync_env->cct, 10) << conf->id << ": rm_object: b=" << bucket_info.bucket << " k=" << key << " mtime=" << mtime << " versioned=" << versioned << " versioned_epoch=" << versioned_epoch << dendl;
./rgw/rgw_sync_module_es.cc:568:      ldout(sync_env->cct, 10) << conf->id << ": skipping operation (bucket not approved)" << dendl;
./rgw/rgw_sync_module_es.cc:575:    ldout(sync_env->cct, 10) << conf->id << ": create_delete_marker: b=" << bucket_info.bucket << " k=" << key << " mtime=" << mtime
./rgw/rgw_sync_module_es.cc:577:    ldout(sync_env->cct, 10) << conf->id << ": skipping operation (not handled)" << dendl;
./rgw/rgw_rados.cc:280:    ldout(cct, 0) << "create_default: error initializing zone params: " << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:286:    ldout(cct, 0) << "create_default: error in create_default  zone params: " << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:289:    ldout(cct, 10) << "zone_params::create_default() returned -EEXIST, we raced with another default zone_params creation" << dendl;
./rgw/rgw_rados.cc:293:      ldout(cct, 0) << "create_default: error in init existing zone params: " << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:296:    ldout(cct, 20) << "zone_params::create_default() " << zone_params.get_name() << " id " << zone_params.get_id()
./rgw/rgw_rados.cc:307:    ldout(cct, 0) << "error storing zone group info: " << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:312:    ldout(cct, 10) << "create_default() returned -EEXIST, we raced with another zonegroup creation" << dendl;
./rgw/rgw_rados.cc:386:        ldout(cct, 0) << "ERROR: found existing zone name " << zone_name
./rgw/rgw_rados.cc:396:        ldout(cct, 0) << "NOTICE: overriding master zone: " << master_zone << dendl;
./rgw/rgw_rados.cc:416:      ldout(cct, 0) << "ERROR: could not found sync module: " << *ptier_type 
./rgw/rgw_rados.cc:472:      ldout(cct, 0) << "WARNING: could not read zone params for zone id=" << zone.id << " name=" << zone.name << dendl;
./rgw/rgw_rados.cc:496:    ldout(cct, 0) << "zone id " << zone_id << " is not a part of zonegroup "
./rgw/rgw_rados.cc:531:      ldout(cct, 10) << "could not read realm id: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:566:          ldout(cct, 0) << "error in read_id for object name: " << name << " : " << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:590:    ldout(cct, 0) << "error decoding data from " << pool << ":" << oid << dendl;
./rgw/rgw_rados.cc:656:    ldout(cct, 0) << "ERROR: failed to decode obj from " << pool << ":" << oid << dendl;
./rgw/rgw_rados.cc:677:      ldout(cct, 0) << "Error delete default obj name  " << name << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:686:      ldout(cct, 0) << "Error delete obj name  " << name << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:701:    ldout(cct, 0) << "Error delete object id " << id << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:729:    ldout(cct, 0) << "Error read_id " << new_name << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:736:    ldout(cct, 0) << "Error storing new obj info " << new_name << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:741:    ldout(cct, 0) << "Error storing new name " << new_name << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:750:    ldout(cct, 0) << "Error delete old obj name  " << old_name << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:768:    ldout(cct, 0) << "failed reading obj info from " << pool << ":" << oid << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:777:    ldout(cct, 0) << "ERROR: failed to decode obj from " << pool << ":" << oid << dendl;
./rgw/rgw_rados.cc:801:    ldout(cct, 10) << "ERROR: name " << name << " already in use for obj id " << id << dendl;
./rgw/rgw_rados.cc:804:    ldout(cct, 0) << "failed reading obj id  " << id << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:819:    ldout(cct, 0) << "ERROR:  storing info for " << id << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:842:    ldout(cct, 20) << __func__ << "(): store_info() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:847:    ldout(cct, 20) << __func__ << "(): store_name() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:862:    ldout(cct, 0) << "ERROR creating new realm object " << name << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:868:    ldout(cct, 0) << "ERROR creating control for new realm " << name << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:880:      ldout(cct, 0) << "ERROR: creating new period for realm " << name << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:887:      ldout(cct, 0) << "ERROR: failed to init period " << current_period << dendl;
./rgw/rgw_rados.cc:893:    ldout(cct, 0) << "ERROR: failed set current period " << current_period << dendl;
./rgw/rgw_rados.cc:900:    ldout(cct, 0) << "WARNING: failed to set realm as default realm, ret=" << ret << dendl;
./rgw/rgw_rados.cc:961:    ldout(cct, 0) << "ERROR: set_current_period with old realm epoch "
./rgw/rgw_rados.cc:966:    ldout(cct, 0) << "ERROR: set_current_period with same realm epoch "
./rgw/rgw_rados.cc:977:    ldout(cct, 0) << "ERROR: period update: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:983:    ldout(cct, 0) << "ERROR: period.reflect(): " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:1002:    ldout(cct, 0) << "Failed to open pool " << pool << dendl;
./rgw/rgw_rados.cc:1008:    ldout(cct, 0) << "Realm notify failed with " << r << dendl;
./rgw/rgw_rados.cc:1103:      ldout(cct, 0) << "RGWPeriod::init failed to init realm " << realm_name  << " id " << realm_id << " : " <<
./rgw/rgw_rados.cc:1114:      ldout(cct, 0) << "failed to use_latest_epoch period id " << id << " realm " << realm_name  << " id " << realm_id
./rgw/rgw_rados.cc:1147:    ldout(cct, 0) << "ERROR: cannot find entry for redirect zone: " << zone_public_config.redirect_zone << dendl;
./rgw/rgw_rados.cc:1155:    ldout(cct, 0) << "ERROR: redirect zone, conn->get_endpoint() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:1200:    ldout(cct, 1) << "error read_lastest_epoch " << pool << ":" << oid << dendl;
./rgw/rgw_rados.cc:1208:    ldout(cct, 0) << "error decoding data from " << pool << ":" << oid << dendl;
./rgw/rgw_rados.cc:1274:      ldout(cct, 20) << "creating initial latest_epoch=" << epoch
./rgw/rgw_rados.cc:1277:      ldout(cct, 0) << "ERROR: failed to read latest_epoch" << dendl;
./rgw/rgw_rados.cc:1281:      ldout(cct, 1) << "found existing latest_epoch " << info.epoch
./rgw/rgw_rados.cc:1285:      ldout(cct, 20) << "updating latest_epoch from " << info.epoch
./rgw/rgw_rados.cc:1296:      ldout(cct, 0) << "ERROR: failed to write latest_epoch" << dendl;
./rgw/rgw_rados.cc:1315:      ldout(cct, 0) << "WARNING: failed to delete period object " << oid
./rgw/rgw_rados.cc:1324:    ldout(cct, 0) << "WARNING: failed to delete period object " << oid
./rgw/rgw_rados.cc:1339:    ldout(cct, 0) << "failed reading obj info from " << pool << ":" << get_period_oid() << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:1348:    ldout(cct, 0) << "ERROR: failed to decode obj from " << pool << ":" << get_period_oid() << dendl;
./rgw/rgw_rados.cc:1372:    ldout(cct, 0) << "ERROR:  storing info for " << id << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:1378:    ldout(cct, 0) << "ERROR: setting latest epoch " << id << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:1412:    ldout(cct, 0) << "ERROR: updating period map: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:1421:  ldout(cct, 20) << __func__ << " realm " << realm_id << " period " << get_id() << dendl;
./rgw/rgw_rados.cc:1425:    ldout(cct, 0) << "ERROR: failed to list zonegroups: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:1437:      ldout(cct, 0) << "WARNING: zg.init() failed: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:1442:      ldout(cct, 20) << "skipping zonegroup " << zg.get_name() << " zone realm id " << zg.realm_id << ", not on our realm " << realm_id << dendl;
./rgw/rgw_rados.cc:1447:      ldout(cct, 0) << "ERROR: zonegroup " << zg.get_name() << " should have a master zone " << dendl;
./rgw/rgw_rados.cc:1464:    ldout(cct, 0) << "ERROR: failed to read period config: "
./rgw/rgw_rados.cc:1478:      ldout(cct, 0) << "ERROR: failed to store zonegroup info for zonegroup=" << iter.first << ": " << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:1485:        ldout(cct, 1) << "Set the period's master zonegroup " << zg.get_id()
./rgw/rgw_rados.cc:1493:    ldout(cct, 0) << "ERROR: failed to store period config: "
./rgw/rgw_rados.cc:1502:  ldout(cct, 20) << __func__ << " realm " << realm_id << " period " << id << dendl;
./rgw/rgw_rados.cc:1529:    ldout(cct, 0) << "period failed to read sync status: "
./rgw/rgw_rados.cc:1574:  ldout(cct, 20) << __func__ << " realm " << realm.get_id() << " period " << current_period.get_id() << dendl;
./rgw/rgw_rados.cc:1604:      ldout(cct, 0) << "failed to update metadata sync status: "
./rgw/rgw_rados.cc:1611:      ldout(cct, 0) << "failed to create new period: " << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:1617:      ldout(cct, 0) << "failed to update realm's current period: "
./rgw/rgw_rados.cc:1621:    ldout(cct, 4) << "Promoted to master zone and committed new period "
./rgw/rgw_rados.cc:1642:    ldout(cct, 0) << "failed to store period: " << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:1652:    ldout(cct, 0) << "failed to set latest epoch: " << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:1657:    ldout(cct, 0) << "failed to update local objects: " << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:1660:  ldout(cct, 4) << "Committed new epoch " << epoch
./rgw/rgw_rados.cc:1693:      ldout(cct, 0) << "Error: init zone " << iter << ":" << cpp_strerror(-r) << dendl;
./rgw/rgw_rados.cc:1756:    ldout(cct, 10) << "WARNING: store->list_zones() returned r=" << r << dendl;
./rgw/rgw_rados.cc:1762:    ldout(cct, 0) << "Error: get_zones_pool_names" << r << dendl;
./rgw/rgw_rados.cc:1802:    ldout(store->ctx(), 10) << "couldn't find old data placement pools config, setting up new ones for the zone" << dendl;
./rgw/rgw_rados.cc:1813:    ldout(cct, 0) << "ERROR: fix_pool_names returned r=" << r << dendl;
./rgw/rgw_rados.cc:1826:    ldout(cct, 10) << "WARNING: failed to set zone as default, r=" << r << dendl;
./rgw/rgw_rados.cc:1897:      ldout(cct, 10) << "could not read realm id: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:1963:    ldout(cct,0) << "Error updating periodmap, multiple master zonegroups configured "<< dendl;
./rgw/rgw_rados.cc:1964:    ldout(cct,0) << "master zonegroup: " << master_zonegroup << " and  " << zonegroup.get_id() <<dendl;
./rgw/rgw_rados.cc:1997:        ldout(cct, 0) << "New zone '" << zone.name << "' (" << zone.id
./rgw/rgw_rados.cc:2520:      ldout(store->ctx(), 5) << "NOTE: we should not process the head object (" << obj << ") here" << dendl;
./rgw/rgw_rados.cc:2527:      ldout(store->ctx(), 5) << "WARNING: failed to remove obj (" << obj << "), leaked" << dendl;
./rgw/rgw_rados.cc:2532:    ldout(store->ctx(), 5) << "NOTE: we are going to process the head obj (" << raw_head << ")" << dendl;
./rgw/rgw_rados.cc:2535:      ldout(store->ctx(), 0) << "WARNING: failed to remove obj (" << raw_head << "), leaked" << dendl;
./rgw/rgw_rados.cc:2792:      ldout(store->ctx(), 0) << "ERROR: write_data() returned " << r << dendl;
./rgw/rgw_rados.cc:2798:      ldout(store->ctx(), 0) << "ERROR: throttle_data() returned " << r << dendl;
./rgw/rgw_rados.cc:2805:        ldout(store->ctx(), 0) << "ERROR: prepare_next_part() returned " << r << dendl;
./rgw/rgw_rados.cc:2878:    ldout(cct, 0) << "ERROR: rados->unwatch2() returned r=" << r << dendl;
./rgw/rgw_rados.cc:2883:    ldout(cct, 0) << "ERROR: rados->watch_flush() returned r=" << r << dendl;
./rgw/rgw_rados.cc:2891:  ldout(cct, 20) << "add_watcher() i=" << i << dendl;
./rgw/rgw_rados.cc:2895:    ldout(cct, 2) << "all " << num_watchers << " watchers are set, enabling cache" << dendl;
./rgw/rgw_rados.cc:2902:  ldout(cct, 20) << "remove_watcher() i=" << i << dendl;
./rgw/rgw_rados.cc:2908:    ldout(cct, 2) << "removed watcher, disabling cache" << dendl;
./rgw/rgw_rados.cc:2933:    ldout(rados->ctx(), 10) << "RGWWatcher::handle_notify() "
./rgw/rgw_rados.cc:2953:      ldout(rados->ctx(), 0) << "ERROR: unregister_watch() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:2958:      ldout(rados->ctx(), 0) << "ERROR: register_watch() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:3121:    ldout(cct, 20) << __func__ << "(): notifying mdlog change, shard_id=" << *iter << dendl;
./rgw/rgw_rados.cc:3156:    ldout(cct, 20) << __func__ << "(): notifying datalog change, shard_id=" << iter->first << ": " << iter->second << dendl;
./rgw/rgw_rados.cc:3197:      ldout(store->ctx(), 0) << "ERROR: sync.init() returned " << ret << dendl;
./rgw/rgw_rados.cc:3318:  ldout(ctx(), 20) << __func__ << ": source_zone=" << source_zone << ", shard_ids=" << shard_ids << dendl;
./rgw/rgw_rados.cc:3322:    ldout(ctx(), 10) << __func__ << ": couldn't find sync thread for zone " << source_zone << ", skipping async data sync processing" << dendl;
./rgw/rgw_rados.cc:3355:    ldout(cct, 0) << "ERROR: open_pool_ctx() returned " << r << dendl;
./rgw/rgw_rados.cc:3362:    ldout(cct, 0) << "ERROR: ioctx.pool_requires_alignment2() returned " 
./rgw/rgw_rados.cc:3375:    ldout(cct, 0) << "ERROR: ioctx.pool_required_alignment2() returned " 
./rgw/rgw_rados.cc:3380:    ldout(cct, 20) << "required alignment=" << align << dendl;
./rgw/rgw_rados.cc:3408:  ldout(cct, 20) << "max_chunk_size=" << *max_chunk_size << dendl;
./rgw/rgw_rados.cc:3417:    ldout(cct, 0) << "ERROR: failed to get data pool for object " << obj << dendl;
./rgw/rgw_rados.cc:3490:    ldout(store->ctx(), 20) << __func__ << "(): handling completion for key=" << c->key << dendl;
./rgw/rgw_rados.cc:3496:      ldout(cct, 0) << "ERROR: " << __func__ << "(): failed to initialize BucketShard, obj=" << c->obj << " r=" << r << dendl;
./rgw/rgw_rados.cc:3510:      ldout(cct, 0) << "ERROR: " << __func__ << "(): bucket index completion failed, obj=" << c->obj << " r=" << r << dendl;
./rgw/rgw_rados.cc:3858:    ldout(cct, 0) << "ERROR: service_daemon_register() returned ret=" << ret << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:3869:    ldout(cct, 0) << "ERROR: service_daemon_update_status() returned ret=" << ret << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:3919:    ldout(cct, 0) << "error decoding regionmap from " << pool << ":" << oid << dendl;
./rgw/rgw_rados.cc:3929:      ldout(cct, 0) << "Error could not update zonegroup " << zonegroup.get_name() << ": " <<
./rgw/rgw_rados.cc:3935:	ldout(cct, 0) << "Error could not create " << zonegroup.get_name() << ": " <<
./rgw/rgw_rados.cc:3949:    ldout(cct, 0) << "Error could not remove " << obj
./rgw/rgw_rados.cc:3980:    ldout(cct, 0) << __func__ << " failed to read converted: ret "<< ret << " " << cpp_strerror(-ret)
./rgw/rgw_rados.cc:3984:    ldout(cct, 20) << "System already converted " << dendl;
./rgw/rgw_rados.cc:3991:    ldout(cct, 0) <<  __func__ << " failed init default region: ret "<< ret << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:3996:    ldout(cct, 0) <<  __func__ << " failed reading old default region: ret "<< ret << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4004:    ldout(cct, 0) <<  __func__ << " failed to list regions: ret "<< ret << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4010:      ldout(cct, 0) << __func__ << ": error initializing default zone params: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4017:      ldout(cct, 0) << __func__ << ": error in initializing default zonegroup: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4033:	  ldout(cct, 0) <<  __func__ << " failed init region "<< *iter << ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4058:      ldout(cct, 0) <<  __func__ << " Error initing new realm: " << cpp_strerror(-ret)  << dendl;
./rgw/rgw_rados.cc:4063:      ldout(cct, 0) <<  __func__ << " Error creating new realm: " << cpp_strerror(-ret)  << dendl;
./rgw/rgw_rados.cc:4068:      ldout(cct, 0) << __func__ << " Error setting realm as default: " << cpp_strerror(-ret)  << dendl;
./rgw/rgw_rados.cc:4073:      ldout(cct, 0) << __func__ << " Error initing realm: " << cpp_strerror(-ret)  << dendl;
./rgw/rgw_rados.cc:4078:      ldout(cct, 0) << __func__ << " Error initing current period: " << cpp_strerror(-ret)  << dendl;
./rgw/rgw_rados.cc:4087:    ldout(cct, 0) << __func__ << " Converting  " << *iter << dendl;
./rgw/rgw_rados.cc:4092:      ldout(cct, 0) << __func__ << " zonegroup  "<< *iter << " already exists id " << new_zonegroup.get_id () <<
./rgw/rgw_rados.cc:4100:      ldout(cct, 0) << __func__ << " failed init zonegroup: ret "<< ret << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4106:      ldout(cct, 0) << __func__ << " Setting default zone as master for default region" << dendl;
./rgw/rgw_rados.cc:4111:      ldout(cct, 0) << __func__ << " failed to update zonegroup " << *iter << ": ret "<< ret << " " << cpp_strerror(-ret)
./rgw/rgw_rados.cc:4117:      ldout(cct, 0) << __func__ << " failed to update_name for zonegroup " << *iter << ": ret "<< ret << " " << cpp_strerror(-ret)
./rgw/rgw_rados.cc:4124:        ldout(cct, 0) << __func__ << " failed to set_as_default " << *iter << ": ret "<< ret << " " << cpp_strerror(-ret)
./rgw/rgw_rados.cc:4131:      ldout(cct, 0) << __func__ << " Converting zone" << iter->first << dendl;
./rgw/rgw_rados.cc:4137:        ldout(cct, 0) << __func__ << " failed to init zoneparams  " << iter->first <<  ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4140:        ldout(cct, 0) << __func__ << " zone is part of another cluster " << iter->first <<  " skipping " << dendl;
./rgw/rgw_rados.cc:4146:        ldout(cct, 0) << __func__ << " failed to update zoneparams " << iter->first <<  ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4151:        ldout(cct, 0) << __func__ << " failed to init zoneparams " << iter->first <<  ": " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4159:        ldout(cct, 0) << __func__ << " failed to add zonegroup to current_period: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4168:      ldout(cct, 0) << __func__ << " failed to update new period: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4173:      ldout(cct, 0) << __func__ << " failed to store new period: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4178:      ldout(cct, 0) << __func__ << " failed to update local objects: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4187:      ldout(cct, 0) << __func__ << " failed init zonegroup" << iter << ": ret "<< ret << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4192:      ldout(cct, 0) << __func__ << " failed to delete region " << iter << ": ret "<< ret << " " << cpp_strerror(-ret)
./rgw/rgw_rados.cc:4202:    ldout(cct, 0) << __func__ << " failed to mark cluster as converted: ret "<< ret << " " << cpp_strerror(-ret)
./rgw/rgw_rados.cc:4219:  ldout(cct, 20) << "period zonegroup init ret " << ret << dendl;
./rgw/rgw_rados.cc:4224:    ldout(cct, 0) << "failed reading zonegroup info: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4227:  ldout(cct, 20) << "period zonegroup name " << zonegroup.get_name() << dendl;
./rgw/rgw_rados.cc:4233:    ldout(cct, 20) << "using current period zonegroup " << zonegroup.get_name() << dendl;
./rgw/rgw_rados.cc:4237:      ldout(cct, 0) << "failed init zonegroup: " << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4242:      ldout(cct, 0) << "failed reading zone params info: " << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4245:      ldout(cct, 10) << " Using default name "<< default_zone_name << dendl;
./rgw/rgw_rados.cc:4249:       ldout(cct, 0) << "failed reading zone params info: " << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4263:	ldout(cct, 0) << "zonegroup " << zg.get_name() << " missing master_zone, setting zone " <<
./rgw/rgw_rados.cc:4269:	    ldout(cct, 0) << "error updating zonegroup : " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4276:	    ldout(cct, 0) << "error initializing zonegroup : " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4282:	    ldout(cct, 0) << "error initializing zonegroup : " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4287:	ldout(cct, 0) << "zonegroup " << zg.get_name() << " missing zone for master_zone=" <<
./rgw/rgw_rados.cc:4309:    ldout(cct, 0) << "failed reading zonegroup info: ret "<< ret << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4313:    ldout(cct, 10) << "Creating default zonegroup " << dendl;
./rgw/rgw_rados.cc:4316:      ldout(cct, 0) << "failure in zonegroup create_default: ret "<< ret << " " << cpp_strerror(-ret)
./rgw/rgw_rados.cc:4322:      ldout(cct, 0) << "failure in zonegroup create_default: ret "<< ret << " " << cpp_strerror(-ret)
./rgw/rgw_rados.cc:4327:  ldout(cct, 20) << "zonegroup " << zonegroup.get_name() << dendl;
./rgw/rgw_rados.cc:4335:	ldout(cct, 0) << "zonegroup " << zonegroup.get_name() << " missing master_zone, setting zone " <<
./rgw/rgw_rados.cc:4340:	  ldout(cct, 0) << "error initializing zonegroup : " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4344:	ldout(cct, 0) << "zonegroup " << zonegroup.get_name() << " missing zone for "
./rgw/rgw_rados.cc:4371:    ldout(cct, 0) << "failed reading realm info: ret "<< ret << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4374:    ldout(cct, 20) << "realm  " << realm.get_name() << " " << realm.get_id() << dendl;
./rgw/rgw_rados.cc:4377:      ldout(cct, 0) << "failed reading current period info: " << " " << cpp_strerror(-ret) << dendl;
./rgw/rgw_rados.cc:4380:    ldout(cct, 20) << "current period " << current_period.get_id() << dendl;  
./rgw/rgw_rados.cc:4407:    ldout(cct, 10) << " cannot find current period zonegroup using local zonegroup" << dendl;
./rgw/rgw_rados.cc:4416:      ldout(cct, 0) << "ERROR: failed to read period config: "
./rgw/rgw_rados.cc:4422:  ldout(cct, 10) << "Cannot find current period zone using local zone" << dendl;
./rgw/rgw_rados.cc:4424:    ldout(cct, 10) << " Using default name "<< default_zone_name << dendl;
./rgw/rgw_rados.cc:4439:    ldout(cct, 1) << "Cannot find zone id=" << zone_params.get_id() << " (name=" << zone_params.get_name() << "), switching to local zonegroup configuration" << dendl;
./rgw/rgw_rados.cc:4448:    ldout(cct, 20) << "zone " << zone_params.get_name() << dendl;
./rgw/rgw_rados.cc:4498:    ldout(cct, 0) << "WARNING: could not find zone config in zonegroup for local zone (" << zone_id() << "), will use defaults" << dendl;
./rgw/rgw_rados.cc:4508:      ldout(cct, 0) << "WARNING: can't generate connection for zone " << z.id << " id " << z.name << ": no endpoints defined" << dendl;
./rgw/rgw_rados.cc:4511:    ldout(cct, 20) << "generating connection object for zone " << z.name << " id " << z.id << dendl;
./rgw/rgw_rados.cc:4523:      ldout(cct, 20) << "NOTICE: not syncing to/from zone " << z.name << " id " << z.id << dendl;
./rgw/rgw_rados.cc:4600:      ldout(cct, 0) << "ERROR: failed to initialize meta sync thread" << dendl;
./rgw/rgw_rados.cc:4612:      ldout(cct, 0) << "ERROR: failed to start bucket trim manager" << dendl;
./rgw/rgw_rados.cc:4618:      ldout(cct, 5) << "starting data sync thread for zone " << iter.first << dendl;
./rgw/rgw_rados.cc:4623:        ldout(cct, 0) << "ERROR: failed to initialize data sync thread" << dendl;
./rgw/rgw_rados.cc:4634:        ldout(cct, 0) << "ERROR: failed to initialize sync log trim thread" << dendl;
./rgw/rgw_rados.cc:4655:    ldout(cct, 1) << __func__ << " bucket index max shards is too large, reset to value: "
./rgw/rgw_rados.cc:4658:  ldout(cct, 20) << __func__ << " bucket index max shards: " << bucket_index_max_shards << dendl;
./rgw/rgw_rados.cc:4918:    ldout(cct, 0) << "could not find placement rule " << *rule << " within zonegroup " << dendl;
./rgw/rgw_rados.cc:5048:  ldout(cct, 10) << "log_show_next pos " << state->pos << " bl " << state->bl.length()
./rgw/rgw_rados.cc:5072:    ldout(cct, 10) << " read " << r << dendl;
./rgw/rgw_rados.cc:5132:      ldout(cct, 0) << "WARNING: RGWRados::log_usage(): user name empty (bucket=" << ub.bucket << "), skipping" << dendl;
./rgw/rgw_rados.cc:5232:      ldout(cct,0) << "usage clear on oid="<< oid << "failed with ret=" << ret << dendl;
./rgw/rgw_rados.cc:5497:    ldout(cct, 0) << "ERROR: couldn't decode avail_pools" << dendl;
./rgw/rgw_rados.cc:5560:    ldout(cct, 0) << "ERROR: could not decode policy, caught buffer::error" << dendl;
./rgw/rgw_rados.cc:5578:    ldout(cct, 0) << "ERROR: could not decode policy, caught buffer::error" << dendl;
./rgw/rgw_rados.cc:5583:    ldout(cct, 15) << __func__ << " Read AccessControlPolicy";
./rgw/rgw_rados.cc:5659:      ldout(cct,0) << "ERROR: encode_utf8() failed" << dendl;
./rgw/rgw_rados.cc:5679:      ldout(cct, 20) << "setting cur_marker=" << cur_marker.name << "[" << cur_marker.instance << "]" << dendl;
./rgw/rgw_rados.cc:5708:        ldout(cct, 0) << "ERROR: could not parse object name: " << obj.name << dendl;
./rgw/rgw_rados.cc:5764:            ldout(cct, 20) << "skip_after_delim=" << skip_after_delim << dendl;
./rgw/rgw_rados.cc:5874:        ldout(cct, 0) << "ERROR: could not parse object name: " <<
./rgw/rgw_rados.cc:6048:        ldout(cct, 0) << "get_bucket_info returned " << r << dendl;
./rgw/rgw_rados.cc:6072:  ldout(cct, 0) << "ERROR: could not create bucket, continuously raced with bucket creation and removal" << dendl;
./rgw/rgw_rados.cc:6084:    ldout(cct, 0) << "could not find zonegroup " << zonegroup_id << " in current period" << dendl;
./rgw/rgw_rados.cc:6094:      ldout(cct, 0) << "could not find requested placement id " << request_rule 
./rgw/rgw_rados.cc:6101:      ldout(cct, 0) << "could not find user default placement id " << user_info.default_placement
./rgw/rgw_rados.cc:6107:      ldout(cct, 0) << "misconfiguration, zonegroup default placement id should not be empty." << dendl;
./rgw/rgw_rados.cc:6112:        ldout(cct, 0) << "could not find zonegroup default placement id " << zonegroup.default_placement
./rgw/rgw_rados.cc:6122:    ldout(cct, 0) << "user not permitted to use placement rule " << titer->first  << dendl;
./rgw/rgw_rados.cc:6210:    ldout(cct, 0) << "ERROR: couldn't decode avail_pools" << dendl;
./rgw/rgw_rados.cc:6241:      ldout(cct, 0) << "WARNING: could not save avail pools map info ret=" << ret << dendl;
./rgw/rgw_rados.cc:6286:    ldout(cct, 0) << "WARNING: could not save avail pools map info ret=" << ret << dendl;
./rgw/rgw_rados.cc:6365:        ldout(cct, 0) << "WARNING: async pool_create returned " << r << dendl;
./rgw/rgw_rados.cc:6382:      ldout(cct, 0) << "WARNING: ioctx_create returned " << ret << dendl;
./rgw/rgw_rados.cc:6408:      ldout(cct, 0) << "WARNING: async application_enable returned " << ret
./rgw/rgw_rados.cc:6425:    ldout(cct, 0) << "ERROR: cannot get data pool for obj=" << obj << ", probably misconfiguration" << dendl;
./rgw/rgw_rados.cc:6445:    ldout(cct, 0) << "ERROR: cannot get data pool for obj=" << obj << ", probably misconfiguration" << dendl;
./rgw/rgw_rados.cc:6501:    ldout(cct, 20) << "object does not have a locator, nothing to fix" << dendl;
./rgw/rgw_rados.cc:6686:      ldout(cct, 20) << __func__ << ": key=" << key << " oid=" << oid << " locator=" << locator << dendl;
./rgw/rgw_rados.cc:6706:      ldout(cct, 20) << __func__ << ": found bad object part: " << loc << dendl;
./rgw/rgw_rados.cc:6736:    ldout(store->ctx(), 0) << "ERROR: open_bucket_index_shard() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:6739:  ldout(store->ctx(), 20) << " bucket index object: " << bucket_obj << dendl;
./rgw/rgw_rados.cc:6759:    ldout(store->ctx(), 0) << "ERROR: open_bucket_index_shard() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:6762:  ldout(store->ctx(), 20) << " bucket index object: " << bucket_obj << dendl;
./rgw/rgw_rados.cc:6774:    ldout(store->ctx(), 0) << "ERROR: open_bucket_index_shard() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:6777:  ldout(store->ctx(), 20) << " bucket index object: " << bucket_obj << dendl;
./rgw/rgw_rados.cc:6797:  ldout(cct, 20) << "iterating listing for bucket=" << bucket_info.bucket.name
./rgw/rgw_rados.cc:6863:    ldout(cct, 10) << "failed to read dest bucket info: r=" << r << dendl;
./rgw/rgw_rados.cc:7049:    ldout(store->ctx(), 0) << "ERROR: " << __func__ << "(): cannot write object with empty name" << dendl;
./rgw/rgw_rados.cc:7187:    ldout(store->ctx(), 0) << "ERROR: complete_atomic_modification returned r=" << r << dendl;
./rgw/rgw_rados.cc:7220:      ldout(store->ctx(), 0) << "ERROR: objexp_hint_add() returned r=" << r << ", object will not get removed" << dendl;
./rgw/rgw_rados.cc:7240:    ldout(store->ctx(), 0) << "ERROR: index_op.cancel()() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:7531:        ldout(cct, 0) << "failed to parse response extra data. len=" << extra_data_bl.length() << " data=" << extra_data_bl.c_str() << dendl;
./rgw/rgw_rados.cc:7601:          ldout(cct, 0) << "ERROR: RGWRadosPutObj::handle_data(): failed to renew op state ret=" << ret << dendl;
./rgw/rgw_rados.cc:7604:            ldout(cct, 0) << "ERROR: RGWRadosPutObj::handle_data(): processor->throttle_data() returned " << r << dendl;
./rgw/rgw_rados.cc:7839:        ldout(cct, 0) << "could not find zonegroup connection to zonegroup: " << source_zone << dendl;
./rgw/rgw_rados.cc:7847:      ldout(cct, 0) << "could not find zone connection to zone: " << source_zone << dendl;
./rgw/rgw_rados.cc:7884:      ldout(cct, 0) << "failed to parse response extra data. len=" << extra_data_bl.length() << " data=" << extra_data_bl.c_str() << dendl;
./rgw/rgw_rados.cc:7975:        ldout(cct, 0) << "could not find zonegroup connection to zonegroup: " << source_zone << dendl;
./rgw/rgw_rados.cc:7983:      ldout(cct, 0) << "could not find zone connection to zone: " << source_zone << dendl;
./rgw/rgw_rados.cc:7998:      ldout(cct, 0) << "ERROR: failed to set opstate ret=" << ret << dendl;
./rgw/rgw_rados.cc:8012:      ldout(cct, 1) << "Cannot load plugin for compression type "
./rgw/rgw_rados.cc:8081:        ldout(cct, 0) << "ERROR: failed to decode delete_at field in intra zone copy" << dendl;
./rgw/rgw_rados.cc:8111:        ldout(ctx(), 0) << "ERROR: failed to decode pg ver attribute, ignoring" << dendl;
./rgw/rgw_rados.cc:8125:      ldout(cct, 20) << "raced with another write of obj: " << dest_obj << dendl;
./rgw/rgw_rados.cc:8129:        ldout(cct, 0) << "ERROR: " << __func__ << ": get_err_state() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:8136:        ldout(cct, 20) << "retrying writing object mtime=" << set_mtime << " dest_state->mtime=" << dest_state->mtime << " dest_state->exists=" << dest_state->exists << dendl;
./rgw/rgw_rados.cc:8139:        ldout(cct, 20) << "not retrying writing object mtime=" << set_mtime << " dest_state->mtime=" << dest_state->mtime << " dest_state->exists=" << dest_state->exists << dendl;
./rgw/rgw_rados.cc:8146:    ldout(cct, 0) << "ERROR: retried object completion too many times, something is wrong!" << dendl;
./rgw/rgw_rados.cc:8154:      ldout(cct, 0) << "ERROR: failed to set opstate ret=" << ret << dendl;
./rgw/rgw_rados.cc:8173:      ldout(cct, 0) << "ERROR: failed to set opstate r=" << ret << dendl;
./rgw/rgw_rados.cc:8269:    ldout(cct, 0) << "ERROR: can't copy object when both src and dest buckets are remote" << dendl;
./rgw/rgw_rados.cc:8273:  ldout(cct, 5) << "Copy object " << src_obj.bucket << ":" << src_obj.get_oid() << " => " << dest_obj.bucket << ":" << dest_obj.get_oid() << dendl;
./rgw/rgw_rados.cc:8305:    ldout(cct, 0) << "ERROR: copy op for encrypted object " << src_obj
./rgw/rgw_rados.cc:8339:    ldout(cct, 0) << "ERROR: failed to get max_chunk_size() for bucket " << dest_obj.bucket << dendl;
./rgw/rgw_rados.cc:8346:    ldout(cct, 0) << "ERROR: failed to locate data pool for " << src_obj << dendl;
./rgw/rgw_rados.cc:8350:    ldout(cct, 0) << "ERROR: failed to locate data pool for " << dest_obj << dendl;
./rgw/rgw_rados.cc:8408:  ldout(cct, 20) << "dest_obj=" << dest_obj << " src_obj=" << src_obj << " copy_itself=" << (int)copy_itself << dendl;
./rgw/rgw_rados.cc:8495:        ldout(cct, 0) << "ERROR: cleanup after error failed to drop reference on obj=" << *riter << dendl;
./rgw/rgw_rados.cc:8535:      ldout(cct, 0) << "ERROR: fail to read object data, ret = " << ret << dendl;
./rgw/rgw_rados.cc:8574:      ldout(cct, 0) << "ERROR: failed to read compression info" << dendl;
./rgw/rgw_rados.cc:8711:    ldout(cct, 0) << "NOTICE: get_bucket_info on bucket=" << bucket.name << " returned err=" << r << dendl;
./rgw/rgw_rados.cc:8719:    ldout(cct, 0) << "NOTICE: put_bucket_info on bucket=" << bucket.name << " returned err=" << r << dendl;
./rgw/rgw_rados.cc:8736:      ldout(cct, 20) << "enabling bucket name=" << bucket.name << dendl;
./rgw/rgw_rados.cc:8738:      ldout(cct, 20) << "disabling bucket name=" << bucket.name << dendl;
./rgw/rgw_rados.cc:8745:      ldout(cct, 0) << "NOTICE: get_bucket_info on bucket=" << bucket.name << " returned err=" << r << ", skipping bucket" << dendl;
./rgw/rgw_rados.cc:8757:      ldout(cct, 0) << "NOTICE: put_bucket_info on bucket=" << bucket.name << " returned err=" << r << ", skipping bucket" << dendl;
./rgw/rgw_rados.cc:8823:    ldout(cct, 0) << "ERROR: empty bucket id for bucket operation" << dendl;
./rgw/rgw_rados.cc:8842:    ldout(cct, 0) << "ERROR: empty bucket_id for bucket operation" << dendl;
./rgw/rgw_rados.cc:8900:    ldout(cct, 10) << "get_bucket_index_object() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:9009:    ldout(cct, 20) << "state for obj=" << obj << " is not atomic, not deferring gc operation" << dendl;
./rgw/rgw_rados.cc:9020:    ldout(cct, 20) << "state->obj_tag is empty, not deferring gc operation" << dendl;
./rgw/rgw_rados.cc:9024:  ldout(cct, 0) << "defer chain tag=" << tag << dendl;
./rgw/rgw_rados.cc:9114:      ldout(store->ctx(), 5) << "failed to get BucketShard object: r=" << r << dendl;
./rgw/rgw_rados.cc:9150:    ldout(store->ctx(), 10) << "If-UnModified-Since: " << params.unmod_since << " Last-Modified: " << ctime << dendl;
./rgw/rgw_rados.cc:9169:        ldout(store->ctx(), 0) << "ERROR: couldn't decode RGW_ATTR_DELETE_AT" << dendl;
./rgw/rgw_rados.cc:9219:      ldout(store->ctx(), 0) << "ERROR: complete_atomic_modification returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:9225:      ldout(store->ctx(), 0) << "ERROR: index_op.cancel() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:9283:    ldout(cct, 1) << "delete_system_obj got empty object name "
./rgw/rgw_rados.cc:9317:    ldout(cct, 0) << "ERROR: " << __func__ << "() get_bucket_instance_info(bucket=" << obj.bucket << ") returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:9357:  ldout(store->ctx(), 10) << "generate_fake_tag new tag=" << tag << dendl;
./rgw/rgw_rados.cc:9399:  ldout(cct, 20) << "get_system_obj_state: rctx=" << (void *)rctx << " obj=" << obj << " state=" << (void *)s << " s->prefetch_data=" << s->prefetch_data << dendl;
./rgw/rgw_rados.cc:9422:    ldout(cct, 20) << "get_system_obj_state: setting s->obj_tag to "
./rgw/rgw_rados.cc:9425:    ldout(cct, 20) << "get_system_obj_state: s->obj_tag was set empty" << dendl;
./rgw/rgw_rados.cc:9451:  ldout(cct, 20) << "get_obj_state: rctx=" << (void *)rctx << " obj=" << obj << " state=" << (void *)s << " s->prefetch_data=" << s->prefetch_data << dendl;
./rgw/rgw_rados.cc:9479:      ldout(cct, 20) << __func__ << "(): found obj in tombstone cache: obj=" << obj
./rgw/rgw_rados.cc:9544:      ldout(cct, 0) << "ERROR: couldn't decode manifest" << dendl;
./rgw/rgw_rados.cc:9547:    ldout(cct, 10) << "manifest: total_size = " << s->manifest.get_obj_size() << dendl;
./rgw/rgw_rados.cc:9552:        ldout(cct, 20) << "manifest: ofs=" << mi.get_ofs() << " loc=" << mi.get_location().get_raw_obj(this) << dendl;
./rgw/rgw_rados.cc:9573:        ldout(cct, 0) << "ERROR: couldn't decode pg ver attr for object " << s->obj << ", non-critical error, ignoring" << dendl;
./rgw/rgw_rados.cc:9585:        ldout(cct, 0) << "ERROR: couldn't decode zone short id attr for object " << s->obj << ", non-critical error, ignoring" << dendl;
./rgw/rgw_rados.cc:9590:    ldout(cct, 20) << "get_obj_state: setting s->obj_tag to " << s->obj_tag.c_str() << dendl;
./rgw/rgw_rados.cc:9592:    ldout(cct, 20) << "get_obj_state: s->obj_tag was set empty" << dendl;
./rgw/rgw_rados.cc:9605:    ldout(cct, 20) << __func__ << ": setting s->olh_tag to " << string(s->olh_tag.c_str(), s->olh_tag.length()) << dendl;
./rgw/rgw_rados.cc:9689:    ldout(store->ctx(), 5) << __func__
./rgw/rgw_rados.cc:9726:      ldout(store->ctx(), 0) << "ERROR: " << __func__ << ": failed to decode manifest"  << dendl;
./rgw/rgw_rados.cc:9776:    ldout(cct, 20) << "state for obj=" << obj << " is not atomic, not appending atomic test" << dendl;
./rgw/rgw_rados.cc:9783:    ldout(cct, 20) << "state->obj_tag is empty, not appending atomic test" << dendl;
./rgw/rgw_rados.cc:9816:    ldout(store->ctx(), 20) << "prepare_atomic_modification: state is not atomic. state=" << (void *)state << dendl;
./rgw/rgw_rados.cc:9886:  ldout(store->ctx(), 10) << "setting object write_tag=" << state->write_tag << dendl;
./rgw/rgw_rados.cc:10012:	ldout(cct, 0) << "ERROR: failed to decode " RGW_ATTR_DELETE_AT << " attr" << dendl;
./rgw/rgw_rados.cc:10059:        ldout(cct, 0) << "ERROR: complete_update_index_cancel() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:10112:        ldout(cct, 20) << "Read xattr: " << iter->first << dendl;
./rgw/rgw_rados.cc:10128:      ldout(cct, 10) << "If-Modified-Since: " << dest_weight << " Last-Modified: " << src_weight << dendl;
./rgw/rgw_rados.cc:10136:      ldout(cct, 10) << "If-UnModified-Since: " << dest_weight << " Last-Modified: " << src_weight << dendl;
./rgw/rgw_rados.cc:10151:      ldout(cct, 10) << "ETag: " << string(etag.c_str(), etag.length()) << " " << " If-Match: " << if_match_str << dendl;
./rgw/rgw_rados.cc:10159:      ldout(cct, 10) << "ETag: " << string(etag.c_str(), etag.length()) << " " << " If-NoMatch: " << if_nomatch_str << dendl;
./rgw/rgw_rados.cc:10219:        ldout(cct, 20) << "Read xattr: " << iter->first << dendl;
./rgw/rgw_rados.cc:10243:      ldout(store->ctx(), 5) << "failed to get BucketShard object: ret=" << ret << dendl;
./rgw/rgw_rados.cc:10250:    ldout(store->ctx(), 0) << "NOTICE: resharding operation on bucket index detected, blocking" << dendl;
./rgw/rgw_rados.cc:10259:    ldout(store->ctx(), 20) << "reshard completion identified, new_bucket_id=" << new_bucket_id << dendl;
./rgw/rgw_rados.cc:10263:      ldout(store->ctx(), 0) << "ERROR: update_bucket_id() new_bucket_id=" << new_bucket_id << " returned r=" << r << dendl;
./rgw/rgw_rados.cc:10332:    ldout(store->ctx(), 5) << "failed to get BucketShard object: ret=" << ret << dendl;
./rgw/rgw_rados.cc:10349:      ldout(store->ctx(), 0) << "WARNING: could not decode policy ret=" << ret << dendl;
./rgw/rgw_rados.cc:10380:    ldout(store->ctx(), 5) << "failed to get BucketShard object: ret=" << ret << dendl;
./rgw/rgw_rados.cc:10465:    ldout(cct, 0) << "ERROR: failed to get max_chunk_size() for pool " << read_obj.pool << dendl;
./rgw/rgw_rados.cc:10503:  ldout(cct, 20) << "rados->read obj-ofs=" << ofs << " read_ofs=" << read_ofs << " read_len=" << read_len << dendl;
./rgw/rgw_rados.cc:10507:  ldout(cct, 20) << "rados->read r=" << r << " bl.length=" << bl.length() << dendl;
./rgw/rgw_rados.cc:10553:  ldout(cct, 20) << "rados->read ofs=" << ofs << " len=" << len << dendl;
./rgw/rgw_rados.cc:10563:    ldout(cct, 20) << "read_state.get_ref() on obj=" << obj << " returned " << r << dendl;
./rgw/rgw_rados.cc:10568:    ldout(cct, 20) << "rados->read r=" << r << " bl.length=" << bl.length() << dendl;
./rgw/rgw_rados.cc:10571:  ldout(cct, 20) << "rados->read r=" << r << " bl.length=" << bl.length() << dendl;
./rgw/rgw_rados.cc:10577:    ldout(cct, 5) << "raced with an object write, abort" << dendl;
./rgw/rgw_rados.cc:10718:    ldout(cct, 20) << "get_obj_data::cancel_io() ofs=" << ofs << dendl;
./rgw/rgw_rados.cc:10735:    ldout(cct, 20) << "get_obj_data::cancel_all_io()" << dendl;
./rgw/rgw_rados.cc:10817:  ldout(cct, 20) << "get_obj_aio_completion_cb: io completion ofs=" << ofs << " len=" << len << dendl;
./rgw/rgw_rados.cc:10822:    ldout(cct, 0) << "ERROR: got unexpected error when trying to read object: " << r << dendl;
./rgw/rgw_rados.cc:10931:  ldout(cct, 20) << "rados->get_obj_iterate_cb oid=" << read_obj.oid << " obj-ofs=" << obj_ofs << " read_ofs=" << read_ofs << " len=" << len << dendl;
./rgw/rgw_rados.cc:10939:    ldout(cct, 0) << "rados->aio_operate r=" << r << dendl;
./rgw/rgw_rados.cc:10951:  ldout(cct, 20) << "cancelling io r=" << r << " obj_ofs=" << obj_ofs << dendl;
./rgw/rgw_rados.cc:11210:      ldout(cct, 5) << "bs.init() returned ret=" << r << dendl;
./rgw/rgw_rados.cc:11217:    ldout(cct, 0) << "NOTICE: resharding operation on bucket index detected, blocking" << dendl;
./rgw/rgw_rados.cc:11226:    ldout(cct, 20) << "reshard completion identified, new_bucket_id=" << new_bucket_id << dendl;
./rgw/rgw_rados.cc:11280:    ldout(cct, 20) << "cls_rgw_bucket_link_olh() returned r=" << r << dendl;
./rgw/rgw_rados.cc:11289:  ldout(cct, 20) << __func__ << "(): olh_state.olh_tag=" << string(olh_state.olh_tag.c_str(), olh_state.olh_tag.length()) << dendl;
./rgw/rgw_rados.cc:11318:    ldout(cct, 20) << "cls_rgw_bucket_link_olh() returned r=" << r << dendl;
./rgw/rgw_rados.cc:11339:    ldout(cct, 5) << "bs.init() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:11354:    ldout(cct, 20) << "cls_rgw_get_olh_log() returned r=" << r << dendl;
./rgw/rgw_rados.cc:11372:    ldout(cct, 5) << "bs.init() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:11387:    ldout(cct, 20) << "cls_rgw_trim_olh_log() returned r=" << ret << dendl;
./rgw/rgw_rados.cc:11414:    ldout(cct, 5) << "cls_rgw_clear_olh() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:11453:      ldout(cct, 20) << "olh_log_entry: op=" << (int)entry.op
./rgw/rgw_rados.cc:11471:        ldout(cct, 0) << "ERROR: apply_olh_log: invalid op: " << (int)entry.op << dendl;
./rgw/rgw_rados.cc:11505:      ldout(cct, 0) << "ERROR: delete_obj() returned " << ret << " obj_instance=" << obj_instance << dendl;
./rgw/rgw_rados.cc:11516:    ldout(cct, 0) << "ERROR: could not apply olh update, r=" << r << dendl;
./rgw/rgw_rados.cc:11522:    ldout(cct, 0) << "ERROR: could not trim olh log, r=" << r << dendl;
./rgw/rgw_rados.cc:11543:        ldout(cct, 0) << "ERROR: could not clear bucket index olh entries r=" << r << dendl;
./rgw/rgw_rados.cc:11601:      ldout(cct, 20) << "olh_init_modification() target_obj=" << target_obj << " delete_marker=" << (int)delete_marker << " returned " << ret << dendl;
./rgw/rgw_rados.cc:11609:      ldout(cct, 20) << "bucket_index_link_olh() target_obj=" << target_obj << " delete_marker=" << (int)delete_marker << " returned " << ret << dendl;
./rgw/rgw_rados.cc:11619:    ldout(cct, 0) << "ERROR: exceeded max ECANCELED retries, aborting (EIO)" << dendl;
./rgw/rgw_rados.cc:11628:    ldout(cct, 20) << "update_olh() target_obj=" << target_obj << " returned " << ret << dendl;
./rgw/rgw_rados.cc:11659:      ldout(cct, 20) << "olh_init_modification() target_obj=" << target_obj << " returned " << ret << dendl;
./rgw/rgw_rados.cc:11670:      ldout(cct, 20) << "bucket_index_unlink_instance() target_obj=" << target_obj << " returned " << ret << dendl;
./rgw/rgw_rados.cc:11680:    ldout(cct, 0) << "ERROR: exceeded max ECANCELED retries, aborting (EIO)" << dendl;
./rgw/rgw_rados.cc:11689:    ldout(cct, 20) << "update_olh() target_obj=" << target_obj << " returned " << ret << dendl;
./rgw/rgw_rados.cc:11746:    ldout(cct, 0) << "ERROR: failed to decode olh info" << dendl;
./rgw/rgw_rados.cc:11767:      ldout(cct, 0) << "ERROR: failed to decode pending entry " << iter->first << dendl;
./rgw/rgw_rados.cc:11807:    ldout(cct, 0) << "ERROR: could not apply olh update, r=" << r << dendl;
./rgw/rgw_rados.cc:11825:      ldout(cct, 20) << "ERROR: rm_pending_entries returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:11830:    ldout(cct, 20) << __func__ << "(): found pending entries, need to update_olh() on bucket=" << olh_obj.bucket << dendl;
./rgw/rgw_rados.cc:11845:    ldout(cct, 0) << "ERROR: failed to decode olh info" << dendl;
./rgw/rgw_rados.cc:12130:  ldout(cct, 20) << "reading from " << get_zone_params().domain_root << ":" << oid << dendl;
./rgw/rgw_rados.cc:12145:    ldout(cct, 0) << "ERROR: could not decode buffer info, caught buffer::error" << dendl;
./rgw/rgw_rados.cc:12177:    ldout(cct, 0) << "ERROR: could not decode buffer info, caught buffer::error" << dendl;
./rgw/rgw_rados.cc:12193:  ldout(cct, 10) << "RGWRados::convert_old_bucket_info(): bucket=" << bucket_name << dendl;
./rgw/rgw_rados.cc:12197:    ldout(cct, 0) << "ERROR: get_bucket_entrypoint_info() returned " << ret << " bucket=" << bucket_name << dendl;
./rgw/rgw_rados.cc:12214:    ldout(cct, 0) << "ERROR: failed to put_linked_bucket_info(): " << ret << dendl;
./rgw/rgw_rados.cc:12270:    ldout(cct, 20) << "rgw_get_bucket_info: old bucket info, bucket=" << info.bucket << " owner " << info.owner << dendl;
./rgw/rgw_rados.cc:12281:  ldout(cct, 20) << "rgw_get_bucket_info: bucket instance: " << entry_point.bucket << dendl;
./rgw/rgw_rados.cc:12310:    ldout(cct, 20) << "couldn't put binfo cache entry, might have raced with data changes" << dendl;
./rgw/rgw_rados.cc:12462:  ldout(cct, 15) << "omap_set obj=" << obj << " key=" << key << dendl;
./rgw/rgw_rados.cc:12577:  ldout(cct, 10) << "distributing notification oid=" << notify_oid << " bl.length()=" << bl.length() << dendl;
./rgw/rgw_rados.cc:12606:    ldout(cct, 10) << "failed to parse cursor: " << cursor << dendl;
./rgw/rgw_rados.cc:12635:    ldout(cct, 20) << "RGWRados::pool_iterate: got " << oid << dendl;
./rgw/rgw_rados.cc:12664:      ldout(cct, 10) << "failed to list objects pool_iterate_begin() returned r=" << r << dendl;
./rgw/rgw_rados.cc:12684:      ldout(cct, 10) << "failed to list objects pool_iterate returned r=" << r << dendl;
./rgw/rgw_rados.cc:12718:  ldout(cct, 20) << __func__ << ": " << bucket_info.bucket << " marker " << marker << " shard_id=" << shard_id << " max " << max << dendl;
./rgw/rgw_rados.cc:12873:    ldout(cct, 0) << "ERROR: bi_get() returned r=" << r << dendl;
./rgw/rgw_rados.cc:12882:    ldout(cct, 0) << "ERROR: failed to decode bi_entry()" << dendl;
./rgw/rgw_rados.cc:12894:    ldout(cct, 5) << "bs.init() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:12926:    ldout(cct, 5) << "bs.init() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:12939:    ldout(cct, 5) << "bs.init() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:12969:    ldout(cct, 5) << "bs.index_ctx.remove(" << bs.bucket_obj << ") returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:12981:    ldout(cct, 5) << "bs.init() returned ret=" << ret << dendl;
./rgw/rgw_rados.cc:13139:  ldout(cct, 10) << "cls_bucket_list_ordered " << bucket_info.bucket <<
./rgw/rgw_rados.cc:13211:      ldout(cct, 10) << "RGWRados::cls_bucket_list_ordered: got " <<
./rgw/rgw_rados.cc:13262:  ldout(cct, 10) << "cls_bucket_list_unordered " << bucket_info.bucket <<
./rgw/rgw_rados.cc:13326:	ldout(cct, 10) << "RGWRados::cls_bucket_list_unordered: got " <<
./rgw/rgw_rados.cc:13487:    ldout(cct, 0) << "WARNING: generated locator (" << loc << ") is different from listed locator (" << list_state.locator << ")" << dendl;
./rgw/rgw_rados.cc:13687:    ldout(cct, 20) << "cls_bucket_header() returned " << r << dendl;
./rgw/rgw_rados.cc:13709:    ldout(cct, 20) << "cls_user_update_buckets() returned " << r << dendl;
./rgw/rgw_rados.cc:13728:    ldout(cct, 20) << "cls_bucket_header() returned " << ret << dendl;
./rgw/rgw_rados.cc:13860:    ldout(cct, 20) << __func__ << " bucket " << bucket.name << " need resharding " <<
./rgw/rgw_rados.cc:13877:    ldout(cct, 20) << "not resharding bucket name=" << bucket_info.bucket.name << ", orig_num=" << num_source_shards << ", new_num_shards=" << new_num_shards << dendl;
./rgw/rgw_rados.cc:14044:    ldout(store->ctx(), 0) << "client_id / op_id / object is empty" << dendl;
./rgw/rgw_rados.cc:14074:    ldout(store->ctx(), 0) << "client_id / op_id / object is empty" << dendl;
./rgw/rgw_rados.cc:14139:      ldout(store->ctx(), 0) << "cls_statelog_list returned " << r << dendl;
./rgw/rgw_rados.cc:14542:  ldout(cct, 20) << "OTP check, otp_id=" << otp_id << " result=" << (int)result.result << dendl;
./rgw/rgw_rados.cc:14586:    ldout(cct, 20) << "OTP create, otp_id=" << config.id << " result=" << (int)r << dendl;
./rgw/rgw_rados.cc:14609:    ldout(cct, 20) << "OTP remove, otp_id=" << id << " result=" << (int)r << dendl;
./rgw/rgw_rados.cc:14688:    ldout(cct, 20) << "OTP set entries.size()=" << entries.size() << " result=" << (int)r << dendl;
./rgw/rgw_data_sync.cc:84:  ldout(cct, 5) << prefix << ":" << state << dendl;
./rgw/rgw_data_sync.cc:90:  ldout(cct, 5) << prefix << ":" << "finish r=" << status << dendl;
./rgw/rgw_data_sync.cc:214:      ldout(sync_env->cct, 4) << "failed to read sync status info with "
./rgw/rgw_data_sync.cc:223:      ldout(sync_env->cct, 4) << "failed to read sync status markers with "
./rgw/rgw_data_sync.cc:273:          ldout(sync_env->cct, 0) << "ERROR: failed to read from " << p << dendl;
./rgw/rgw_data_sync.cc:353:          ldout(sync_env->cct, 0) << "ERROR: failed to read from " << p << dendl;
./rgw/rgw_data_sync.cc:444:      ldout(store->ctx(), 0) << "ERROR: failed to read from " << p << dendl;
./rgw/rgw_data_sync.cc:457:      ldout(sync_env->store->ctx(), 0) << "ERROR: failed to list remote datalog shard, ret=" << ret << dendl;
./rgw/rgw_data_sync.cc:632:    ldout(store->ctx(), 0) << "ERROR: failed to fetch datalog info" << dendl;
./rgw/rgw_data_sync.cc:636:  ldout(store->ctx(), 20) << "remote datalog, num_shards=" << log_info->num_shards << dendl;
./rgw/rgw_data_sync.cc:673:    ldout(store->ctx(), 0) << "failed in http_manager.start() ret=" << ret << dendl;
./rgw/rgw_data_sync.cc:700:    ldout(store->ctx(), 0) << "failed in http_manager.start() ret=" << ret << dendl;
./rgw/rgw_data_sync.cc:717:    ldout(store->ctx(), 0) << "failed in http_manager.start() ret=" << ret << dendl;
./rgw/rgw_data_sync.cc:747:    ldout(store->ctx(), 0) << "failed in http_manager.start() ret=" << ret << dendl;
./rgw/rgw_data_sync.cc:829:        ldout(sync_env->cct, 0) << "ERROR: failed to fetch metadata for section bucket.instance" << dendl;
./rgw/rgw_data_sync.cc:837:        ldout(sync_env->cct, 20) << "list metadata: section=bucket.instance key=" << *iter << dendl;
./rgw/rgw_data_sync.cc:1504:                ldout(sync_env->cct, 0) << "ERROR: a sync operation returned error" << dendl;
./rgw/rgw_data_sync.cc:1825:    ldout(store->ctx(), 0) << "ERROR: failed to run sync" << dendl;
./rgw/rgw_data_sync.cc:1835:    ldout(store->ctx(), 0) << "ERROR: failed to find zone config info for zone=" << source_zone << dendl;
./rgw/rgw_data_sync.cc:1853:    ldout(store->ctx(), 0) << "connection object to zone " << source_zone << " does not exist" << dendl;
./rgw/rgw_data_sync.cc:1869:    ldout(store->ctx(), 5) << "ERROR: master.read_log_info() returned r=" << r << dendl;
./rgw/rgw_data_sync.cc:1979:        ldout(cct, 0) << "ERROR: failed to fetch bucket index status" << dendl;
./rgw/rgw_data_sync.cc:2020:    ldout(cct, 0) << "ERROR: failed to decode attribute: " << attr_name << dendl;
./rgw/rgw_data_sync.cc:2083:      ldout(sync_env->cct, 0) << "ERROR: failed to call fetch bucket shard info oid=" << oid << " ret=" << retcode << dendl;
./rgw/rgw_data_sync.cc:2135:        ldout(sync_env->cct, 0) << "failed to read recovering bucket shards with " 
./rgw/rgw_data_sync.cc:2196:      ldout(sync_env->cct,0) << "failed to read sync status marker with " 
./rgw/rgw_data_sync.cc:2212:        ldout(sync_env->cct,0) << "failed to read remote data log info with " 
./rgw/rgw_data_sync.cc:2240:    ldout(store->ctx(), 0) << "failed in http_manager.start() ret=" << ret << dendl;
./rgw/rgw_data_sync.cc:2918:          ldout(sync_env->cct, 20) << " syncstop on " << e.timestamp << dendl;
./rgw/rgw_data_sync.cc:2924:          ldout(sync_env->cct, 20) << " resync on " << e.timestamp << dendl;
./rgw/rgw_data_sync.cc:2962:          ldout(sync_env->cct, 20) << "detected syncstop or resync  on " << entries_iter->timestamp << " , skipping entry" << dendl;
./rgw/rgw_data_sync.cc:3241:    ldout(store->ctx(), 0) << "connection object to zone " << source_zone << " does not exist" << dendl;
./rgw/rgw_data_sync.cc:3247:    ldout(store->ctx(), 0) << "failed in http_manager.start() ret=" << ret << dendl;
./rgw/rgw_data_sync.cc:3262:    ldout(store->ctx(), 0) << "ERROR: failed to fetch bucket metadata info from zone=" << source_zone << " path=" << path << " key=" << key << " ret=" << ret << dendl;
./rgw/rgw_data_sync.cc:3281:      ldout(store->ctx(), 0) << "ERROR: failed to initialize RGWRemoteBucketLog object" << dendl;
./rgw/rgw_data_sync.cc:3319:    ldout(store->ctx(), 0) << "ERROR: failed to read sync status for "
./rgw/rgw_data_sync.cc:3341:    ldout(store->ctx(), 0) << "ERROR: failed to read sync status for "
./rgw/rgw_data_sync.cc:3487:    ldout(cct, 10) << "fetching sync status for zone " << zone_id << dendl;
./rgw/rgw_data_sync.cc:3500:        ldout(cct, 20) << "query sync status from " << c.first << dendl;
./rgw/rgw_data_sync.cc:3517:      ldout(cct, 4) << "failed to fetch sync status from all peers" << dendl;
./rgw/rgw_data_sync.cc:3521:    ldout(cct, 10) << "trimming log shards" << dendl;
./rgw/rgw_data_sync.cc:3534:        ldout(cct, 10) << "trimming log shard " << i
./rgw/rgw_data_sync.cc:3586:        ldout(cct, 4) << "failed to lock " << lock_oid << ", trying again in "
./rgw/rgw_reshard.cc:153:        ldout(store->ctx(), 20) << __func__ << ": shard->wait_all_aio() returned ret=" << ret << dendl;
./rgw/rgw_reshard.cc:211:    ldout(store->ctx(), 0) << "RGWReshard::add failed to acquire lock on " << reshard_oid << " ret=" << ret << dendl;
./rgw/rgw_reshard.cc:221:    ldout(store->ctx(), 0) << "WARNING: RGWReshard::add failed to drop lock on " << reshard_oid << " ret=" << ret << dendl;
./rgw/rgw_reshard.cc:228:    ldout(store->ctx(), 0) << __func__ << " missing new bucket instance id" << dendl;
./rgw/rgw_reshard.cc:237:    ldout(store->ctx(), 0) << "RGWReshard::" << __func__ << " ERROR: error setting bucket resharding flag on bucket index: "
./rgw/rgw_reshard.cc:250:    ldout(store->ctx(), 0) << "RGWReshard::" << __func__ << " ERROR: error setting bucket resharding flag on bucket index: "
./rgw/rgw_reshard.cc:320:      ldout(store->ctx(), 0) << "ERROR: failed to write bucket info, ret=" << ret << dendl;
./rgw/rgw_reshard.cc:384:    ldout(store->ctx(), 0) << __func__ << ": can't reshard, negative max_entries" << dendl;
./rgw/rgw_reshard.cc:392:    ldout(store->ctx(), 0) << __func__ << ": failed to update bucket info ret=" << ret << dendl;
./rgw/rgw_reshard.cc:493:    ldout(store->ctx(), 0) << __func__ << ": failed to update bucket info ret=" << ret << dendl;
./rgw/rgw_reshard.cc:604:    ldout(store->ctx(), 20) << __func__ << " Resharding is disabled"  << dendl;
./rgw/rgw_reshard.cc:639:    ldout(store->ctx(), 0) << __func__ << ":Error in updating entry bucket " << entry.bucket_name << ": " <<
./rgw/rgw_reshard.cc:741:      ldout(store->ctx(), 0) << __func__ << " ERROR: failed to get bucket resharding :"  <<
./rgw/rgw_reshard.cc:749:    ldout(store->ctx(), 20) << "NOTICE: reshard still in progress; " << (i < num_retries - 1 ? "retrying" : "too many retries") << dendl;
./rgw/rgw_reshard.cc:758:      ldout(store->ctx(), 0) << __func__ << " ERROR: bucket is still resharding, please retry" << dendl;
./rgw/rgw_reshard.cc:762:  ldout(store->ctx(), 0) << __func__ << " ERROR: bucket is still resharding, please retry" << dendl;
./rgw/rgw_reshard.cc:791:    ldout(store->ctx(), 5) << __func__ << "(): failed to acquire lock on " << logshard_oid << dendl;
./rgw/rgw_reshard.cc:801:      ldout(cct, 10) << "cannot list all reshards in logshard oid=" << logshard_oid << dendl;
./rgw/rgw_reshard.cc:808:	ldout(store->ctx(), 20) << __func__ << " resharding " << entry.bucket_name  << dendl;
./rgw/rgw_reshard.cc:818:	  ldout(cct, 0) <<  __func__ << ": Error in get_bucket_info: " << cpp_strerror(-ret) << dendl;
./rgw/rgw_reshard.cc:828:	  ldout (store->ctx(), 0) <<  __func__ << "ERROR in reshard_bucket " << entry.bucket_name << ":" <<
./rgw/rgw_reshard.cc:833:	ldout (store->ctx(), 20) <<  " removing entry" << entry.bucket_name<< dendl;
./rgw/rgw_reshard.cc:837:	  ldout(cct, 0)<< __func__ << ":Error removing bucket " << entry.bucket_name << " for resharding queue: "
./rgw/rgw_reshard.cc:848:          ldout(store->ctx(), 5) << __func__ << "(): failed to acquire lock on " << logshard_oid << dendl;
./rgw/rgw_reshard.cc:874:    ldout(store->ctx(), 20) << __func__ << " Resharding is disabled"  << dendl;
./rgw/rgw_reshard.cc:883:    ldout(store->ctx(), 20) << "proceeding logshard = " << logshard << dendl;
./rgw/rgw_period_pusher.cc:49:        ldout(cct, 10) << "pushing period " << period.get_id()
./rgw/rgw_period_pusher.cc:63:        ldout(cct, 10) << "push to " << zone << " succeeded" << dendl;
./rgw/rgw_period_pusher.cc:77:        ldout(cct, 10) << "waiting " << dur << "s for retry.." << dendl;
./rgw/rgw_period_pusher.cc:114:      ldout(cct, 4) << "sending " << conns.size() << " periods" << dendl;
./rgw/rgw_period_pusher.cc:205:    ldout(cct, 10) << "period's realm epoch " << period.get_realm_epoch()
./rgw/rgw_period_pusher.cc:212:    ldout(cct, 10) << "period epoch " << period.get_epoch() << " is not newer "
./rgw/rgw_period_pusher.cc:267:    ldout(cct, 4) << "No zones to update" << dendl;
./rgw/rgw_period_pusher.cc:274:  ldout(cct, 4) << "Zone master pushing period " << period.get_id()
./rgw/rgw_period_pusher.cc:284:  ldout(cct, 4) << "paused for realm update" << dendl;
./rgw/rgw_period_pusher.cc:294:  ldout(cct, 4) << "resume with " << pending_periods.size()
./rgw/rgw_object_expirer_core.cc:67:    ldout(store->ctx(), 15) << "NOTICE: cannot find bucket = " \
./rgw/rgw_object_expirer_core.cc:71:    ldout(store->ctx(),  1) << "ERROR: could not init bucket = " \
./rgw/rgw_object_expirer_core.cc:101:    ldout(store->ctx(), 15) << "got removal hint for: " << iter->key_ts.sec() \
./rgw/rgw_object_expirer_core.cc:106:      ldout(store->ctx(), 1) << "cannot parse removal hint for " << hint.obj_key << dendl;
./rgw/rgw_object_expirer_core.cc:114:      ldout(store->ctx(), 15) << "not actual hint for object: " << hint.obj_key << dendl;
./rgw/rgw_object_expirer_core.cc:116:      ldout(store->ctx(), 1) << "cannot remove expired object: " << hint.obj_key << dendl;
./rgw/rgw_object_expirer_core.cc:131:  ldout(store->ctx(), 20) << "trying to trim removal hints to=" << to
./rgw/rgw_object_expirer_core.cc:140:    ldout(store->ctx(), 0) << "ERROR during trim: " << ret << dendl;
./rgw/rgw_object_expirer_core.cc:182:      ldout(cct, 10) << "cannot get removal hints from shard: " << shard
./rgw/rgw_object_expirer_core.cc:219:    ldout(store->ctx(), 20) << "proceeding shard = " << shard << dendl;
./rgw/rgw_object_expirer_core.cc:255:    ldout(cct, 2) << "object expiration: start" << dendl;
./rgw/rgw_object_expirer_core.cc:261:    ldout(cct, 2) << "object expiration: stop" << dendl;
./rgw/rgw_rest_realm.cc:34:      ldout(s->cct, 4) << "Request failed with " << http_ret
./rgw/rgw_rest_realm.cc:67:    ldout(store->ctx(), 5) << "failed to read period" << dendl;
./rgw/rgw_rest_realm.cc:131:    ldout(cct, 10) << "master zone rejecting period id="
./rgw/rgw_rest_realm.cc:147:    ldout(cct, 4) << "already have epoch >= " << period.get_epoch()
./rgw/rgw_rest_realm.cc:162:      ldout(cct, 10) << "discarding period " << period.get_id()
./rgw/rgw_rest_realm.cc:190:      ldout(cct, 4) << "attached period " << period.get_id()
./rgw/rgw_rest_realm.cc:200:    ldout(cct, 4) << "period " << period.get_id()
./rgw/rgw_rest_realm.cc:213:  ldout(cct, 4) << "period epoch " << period.get_epoch()
./rgw/rgw_rest_log.cc:88:    ldout(s->cct, 5) << "Missing period id trying to use current" << dendl;
./rgw/rgw_rest_log.cc:91:      ldout(s->cct, 5) << "Missing period id" << dendl;
./rgw/rgw_rest_log.cc:166:    ldout(s->cct, 5) << "Missing period id trying to use current" << dendl;
./rgw/rgw_rest_log.cc:170:      ldout(s->cct, 5) << "Missing period id" << dendl;
./rgw/rgw_rest_log.cc:225:    ldout(s->cct, 5) << "Missing period id trying to use current" << dendl;
./rgw/rgw_rest_log.cc:229:      ldout(s->cct, 5) << "Missing period id" << dendl;
./rgw/rgw_rest_log.cc:252:    ldout(s->cct, 5) << "Missing period id trying to use current" << dendl;
./rgw/rgw_rest_log.cc:300:    ldout(s->cct, 5) << "Missing period id trying to use current" << dendl;
./rgw/rgw_rest_log.cc:335:  ldout(s->cct, 20) << __func__ << "(): read data: " << string(data, len) << dendl;
./rgw/rgw_rest_log.cc:341:    ldout(s->cct, 0) << "ERROR: failed to parse JSON" << dendl;
./rgw/rgw_rest_log.cc:350:    ldout(s->cct, 0) << "ERROR: failed to decode JSON" << dendl;
./rgw/rgw_rest_log.cc:357:      ldout(s->cct, 20) << __func__ << "(): updated shard=" << *iter << dendl;
./rgw/rgw_rest_log.cc:765:  ldout(s->cct, 20) << __func__ << "(): read data: " << string(data, len) << dendl;
./rgw/rgw_rest_log.cc:771:    ldout(s->cct, 0) << "ERROR: failed to parse JSON" << dendl;
./rgw/rgw_rest_log.cc:780:    ldout(s->cct, 0) << "ERROR: failed to decode JSON" << dendl;
./rgw/rgw_rest_log.cc:787:      ldout(s->cct, 20) << __func__ << "(): updated shard=" << iter->first << dendl;
./rgw/rgw_rest_log.cc:790:      ldout(s->cct, 20) << __func__ << "(): modified key=" << *kiter << dendl;
./rgw/rgw_rest_log.cc:856:    ldout(s->cct, 1) << "no sync manager" << dendl;
./rgw/rgw_rest_log.cc:895:    ldout(s->cct, 4) << "no 'bucket' provided" << dendl;
./rgw/rgw_rest_log.cc:904:    ldout(s->cct, 4) << "no 'bucket' provided" << dendl;
./rgw/rgw_rest_log.cc:914:    ldout(s->cct, 4) << "failed to read bucket info: " << cpp_strerror(http_ret) << dendl;
./rgw/rgw_rest_log.cc:952:    ldout(s->cct, 1) << "no sync manager for source-zone " << source_zone << dendl;
./rgw/rgw_rest_user.cc:112:    ldout(s->cct, 0) << "cannot set system flag by non-system user" << dendl;
./rgw/rgw_rest_user.cc:237:    ldout(s->cct, 0) << "cannot set system flag by non-system user" << dendl;
./rgw/rgw_rest_user.cc:819:    ldout(store->ctx(), 20) << "invalid quota type" << dendl;
./rgw/rgw_rest_user.cc:834:    ldout(store->ctx(), 20) << "quota type was not specified, can't set all quotas via http headers" << dendl;
./rgw/rgw_rest_user.cc:844:    ldout(store->ctx(), 20) << "failed initializing user info: " << http_ret << dendl;
./rgw/rgw_rest_user.cc:858:      ldout(store->ctx(), 20) << "failed to retrieve input" << dendl;
./rgw/rgw_rest_user.cc:871:        ldout(store->ctx(), 20) << "failed to retrieve input" << dendl;
./rgw/rgw_rest_user.cc:885:        ldout(store->ctx(), 20) << "failed to get user info: " << http_ret << dendl;
./rgw/rgw_rest_user.cc:913:    ldout(store->ctx(), 20) << "failed updating user info: " << http_ret << ": " << err << dendl;
./rgw/rgw_sync_module_log.cc:15:    ldout(sync_env->cct, 0) << "SYNC_LOG: stat of remote obj: z=" << sync_env->source_zone
./rgw/rgw_sync_module_log.cc:42:    ldout(sync_env->cct, 0) << prefix << ": SYNC_LOG: sync_object: b=" << bucket_info.bucket << " k=" << key << " versioned_epoch=" << versioned_epoch << dendl;
./rgw/rgw_sync_module_log.cc:46:    ldout(sync_env->cct, 0) << prefix << ": SYNC_LOG: rm_object: b=" << bucket_info.bucket << " k=" << key << " mtime=" << mtime << " versioned=" << versioned << " versioned_epoch=" << versioned_epoch << dendl;
./rgw/rgw_sync_module_log.cc:51:    ldout(sync_env->cct, 0) << prefix << ": SYNC_LOG: create_delete_marker: b=" << bucket_info.bucket << " k=" << key << " mtime=" << mtime
./rgw/rgw_metadata.cc:372:      ldout(store->ctx(), 0) << "ERROR: meta history is empty, but cannot remove it (" << cpp_strerror(-ret) << ")" << dendl;
./rgw/rgw_metadata.cc:381:    ldout(store->ctx(), 1) << "failed to decode the mdlog history: "
./rgw/rgw_metadata.cc:427:        ldout(cct, 1) << "failed to read mdlog history: "
./rgw/rgw_metadata.cc:436:      ldout(cct, 10) << "read mdlog history with oldest period id="
./rgw/rgw_metadata.cc:470:        ldout(cct, 1) << "failed to write mdlog history: "
./rgw/rgw_metadata.cc:475:      ldout(cct, 10) << "wrote mdlog history with oldest period id="
./rgw/rgw_metadata.cc:509:        ldout(cct, 4) << "found oldest log epoch=" << existing.get_epoch()
./rgw/rgw_metadata.cc:537:        ldout(cct, 10) << "find_oldest_period returning first "
./rgw/rgw_metadata.cc:551:      ldout(cct, 20) << "find_oldest_period advancing to "
./rgw/rgw_metadata.cc:557:  ldout(cct, 10) << "find_oldest_period returning empty cursor" << dendl;
./rgw/rgw_metadata.cc:572:    ldout(cct, 10) << "initializing mdlog history" << dendl;
./rgw/rgw_metadata.cc:585:      ldout(cct, 1) << "failed to write mdlog history: "
./rgw/rgw_metadata.cc:591:    ldout(cct, 1) << "failed to read mdlog history: "
./rgw/rgw_metadata.cc:605:    ldout(cct, 1) << "failed to read period id=" << state.oldest_period_id
./rgw/rgw_metadata.cc:611:    ldout(cct, 1) << "inconsistent mdlog history: read period id="
./rgw/rgw_metadata.cc:625:    ldout(store->ctx(), 1) << "failed to read mdlog history: "
./rgw/rgw_metadata.cc:630:  ldout(store->ctx(), 10) << "read mdlog history with oldest period id="
./rgw/rgw_metadata.cc:1053:    ldout(store->ctx(), 0) << "ERROR: rgw_put_system_obj() oid=" << oid << " returned ret=" << ret << dendl;
./rgw/rgw_metadata.cc:1076:    ldout(store->ctx(), 0) << "ERROR: store->delete_system_obj() oid=" << oid << " returned ret=" << ret << dendl;
./rgw/rgw_metadata.cc:1099:    ldout(store->ctx(), 0) << "ERROR: " << __func__ << ": store_in_heap() key=" << key << " returned ret=" << ret << dendl;
./rgw/rgw_metadata.cc:1109:      ldout(store->ctx(), 0) << "ERROR: " << __func__ << ": remove_from_heap() key=" << key << " returned ret=" << r << dendl;
./rgw/rgw_http_client.cc:630:    ldout(cct, 0) << "ERROR: " << __func__ << "(): write() returned " << ret << dendl;
./rgw/rgw_http_client.cc:644:    ldout(cct, 0) << "ERROR: curl_multi_wait() returned " << ret << dendl;
./rgw/rgw_http_client.cc:652:    ldout(cct, 0) << "WARNING: detected a version of libcurl which contains a "
./rgw/rgw_http_client.cc:688:    ldout(cct, 0) << "ERROR: curl_multi_wait() returned " << ret << dendl;
./rgw/rgw_http_client.cc:695:      ldout(cct, 0) << "ERROR: " << __func__ << "(): read() returned " << ret << dendl;
./rgw/rgw_http_client.cc:718:    ldout(cct, 0) << "ERROR: curl_multi_fdset returned " << ret << dendl;
./rgw/rgw_http_client.cc:741:    ldout(cct, 0) << "ERROR: select returned " << ret << dendl;
./rgw/rgw_http_client.cc:748:      ldout(cct, 0) << "ERROR: " << __func__ << "(): read() returned " << ret << dendl;
./rgw/rgw_http_client.cc:790:  ldout(cct, 20) << __func__ << " mgr=" << this << " req_data->id=" << req_data->id << ", curl_handle=" << req_data->curl_handle << dendl;
./rgw/rgw_http_client.cc:802:  ldout(cct, 20) << __func__ << " mgr=" << this << " req_data->id=" << req_data->id << ", curl_handle=" << req_data->curl_handle << dendl;
./rgw/rgw_http_client.cc:850:  ldout(cct, 20) << __func__ << " req_data=" << req_data << " req_data->id=" << req_data->id << ", curl_handle=" << req_data->curl_handle << dendl;
./rgw/rgw_http_client.cc:909:      ldout(cct, 0) << "ERROR: failed to link http request" << dendl;
./rgw/rgw_http_client.cc:1047:    ldout(cct, 0) << "ERROR: pipe() returned errno=" << r << dendl;
./rgw/rgw_http_client.cc:1055:    ldout(cct, 0) << "ERROR: fcntl() returned errno=" << r << dendl;
./rgw/rgw_http_client.cc:1099:    ldout(cct, 0) << "ERROR: " << __func__ << ": write() returned ret=" << ret << dendl;
./rgw/rgw_http_client.cc:1110:  ldout(cct, 20) << __func__ << ": start" << dendl;
./rgw/rgw_acl.cc:40:        ldout(cct, 0) << "ERROR: grant->get_id() failed" << dendl;
./rgw/rgw_acl.cc:58:  ldout(cct, 5) << "Searching permissions for identity=" << auth_identity
./rgw/rgw_acl.cc:67:  ldout(cct, 5) << "Searching permissions for group=" << (int)group
./rgw/rgw_acl.cc:72:    ldout(cct, 5) << "Found permission: " << iter->second << dendl;
./rgw/rgw_acl.cc:75:  ldout(cct, 5) << "Permissions for group not found" << dendl;
./rgw/rgw_acl.cc:83:  ldout(cct, 5) << "Searching permissions for referer=" << http_referer
./rgw/rgw_acl.cc:97:  ldout(cct, 5) << "Found referer permission=" << referer_perm << dendl;
./rgw/rgw_acl.cc:105:  ldout(cct, 20) << "-- Getting permissions begin with perm_mask=" << perm_mask
./rgw/rgw_acl.cc:133:  ldout(cct, 5) << "-- Getting permissions done for identity=" << auth_identity
./rgw/rgw_acl.cc:162:  ldout(cct, 10) << " identity=" << auth_identity
./rgw/rgw_role.cc:71:    ldout(cct, 0) << "ERROR: name " << name << " already in use for role id "
./rgw/rgw_role.cc:75:    ldout(cct, 0) << "failed reading role id  " << id << ": "
./rgw/rgw_role.cc:106:    ldout(cct, 0) << "ERROR:  storing role info in pool: " << pool.name << ": "
./rgw/rgw_role.cc:113:    ldout(cct, 0) << "ERROR: storing role name in pool: " << pool.name << ": "
./rgw/rgw_role.cc:120:      ldout(cct, 0) << "ERROR: cleanup of role id from pool: " << pool.name << ": "
./rgw/rgw_role.cc:128:    ldout(cct, 0) << "ERROR: storing role path in pool: " << pool.name << ": "
./rgw/rgw_role.cc:134:      ldout(cct, 0) << "ERROR: cleanup of role id from pool: " << pool.name << ": "
./rgw/rgw_role.cc:141:      ldout(cct, 0) << "ERROR: cleanup of role name from pool: " << pool.name << ": "
./rgw/rgw_role.cc:171:    ldout(cct, 0) << "ERROR: deleting role id from pool: " << pool.name << ": "
./rgw/rgw_role.cc:179:    ldout(cct, 0) << "ERROR: deleting role name from pool: " << pool.name << ": "
./rgw/rgw_role.cc:187:    ldout(cct, 0) << "ERROR: deleting role path from pool: " << pool.name << ": "
./rgw/rgw_role.cc:224:    ldout(cct, 0) << "ERROR:  storing info in pool: " << pool.name << ": "
./rgw/rgw_role.cc:252:    ldout(cct, 0) << "ERROR: Policy name: " << policy_name << " not found" << dendl;
./rgw/rgw_role.cc:264:    ldout(cct, 0) << "ERROR: Policy name: " << policy_name << " not found" << dendl;
./rgw/rgw_role.cc:310:    ldout(cct, 0) << "ERROR: failed to decode role from pool: " << pool.name << ": "
./rgw/rgw_role.cc:327:    ldout(cct, 0) << "ERROR: failed reading role info from pool: " << pool.name <<
./rgw/rgw_role.cc:337:    ldout(cct, 0) << "ERROR: failed to decode role info from pool: " << pool.name <<
./rgw/rgw_role.cc:354:    ldout(cct, 0) << "ERROR: failed reading role name from pool: " << pool.name << ": "
./rgw/rgw_role.cc:365:    ldout(cct, 0) << "ERROR: failed to decode role name from pool: " << pool.name << ": "
./rgw/rgw_role.cc:376:    ldout(cct, 0) << "ERROR: Invalid name length " << dendl;
./rgw/rgw_role.cc:381:    ldout(cct, 0) << "ERROR: Invalid path length " << dendl;
./rgw/rgw_role.cc:387:    ldout(cct, 0) << "ERROR: Invalid chars in name " << dendl;
./rgw/rgw_role.cc:393:    ldout(cct, 0) << "ERROR: Invalid chars in path " << dendl;
./rgw/rgw_role.cc:438:      ldout(cct, 0) << "ERROR: listing filtered objects failed: " << pool.name << ": "
./rgw/rgw_auth_keystone.cc:46:    ldout(cct, 20) << "cannot decode pki token" << dendl;
./rgw/rgw_auth_keystone.cc:49:    ldout(cct, 20) << "successfully decoded pki token" << dendl;
./rgw/rgw_auth_keystone.cc:116:    ldout(cct, 5) << "Failed keystone auth from " << url << " with "
./rgw/rgw_auth_keystone.cc:121:  ldout(cct, 20) << "received response status=" << validate.get_http_status()
./rgw/rgw_auth_keystone.cc:235:  ldout(cct, 20) << "token_id=" << token_id << dendl;
./rgw/rgw_auth_keystone.cc:240:    ldout(cct, 20) << "cached token.project.id=" << t->get_project_id()
./rgw/rgw_auth_keystone.cc:266:    ldout(cct, 0) << "got expired token: " << t->get_project_name()
./rgw/rgw_auth_keystone.cc:275:      ldout(cct, 0) << "validated token: " << t->get_project_name()
./rgw/rgw_auth_keystone.cc:285:  ldout(cct, 0) << "user does not hold a matching role; required roles: "
./rgw/rgw_auth_keystone.cc:318:    ldout(cct, 2) << "s3 keystone: cannot get token for keystone access"
./rgw/rgw_auth_keystone.cc:356:    ldout(cct, 2) << "s3 keystone: token validation ERROR: "
./rgw/rgw_auth_keystone.cc:374:    ldout(cct, 2) << "s3 keystone: token parsing failed, ret=0" << ret
./rgw/rgw_auth_keystone.cc:454:    ldout(cct, 0) << "got expired token: " << t->get_project_name()
./rgw/rgw_auth_keystone.cc:470:    ldout(cct, 5) << "s3 keystone: user does not hold a matching role;"
./rgw/rgw_auth_keystone.cc:476:    ldout(cct, 5) << "s3 keystone: validated token: " << t->get_project_name()
./rgw/rgw_period_puller.cc:65:      ldout(store->ctx(), 1) << "metadata master failed to read period "
./rgw/rgw_period_puller.cc:69:    ldout(store->ctx(), 14) << "pulling period " << period_id
./rgw/rgw_period_puller.cc:104:    ldout(store->ctx(), 14) << "period " << period_id
./rgw/rgw_period_puller.cc:107:    ldout(store->ctx(), 14) << "found period " << period_id
./rgw/rgw_cr_rados.cc:457:        ldout(cct, 0) << "ERROR: failed to store entries in omap" << dendl;
./rgw/rgw_cr_rados.cc:496:    ldout(store->ctx(), 0) << "ERROR: failed to get bucket instance info for "
./rgw/rgw_cr_rados.cc:585:    ldout(store->ctx(), 0) << "store->fetch_remote_obj() returned r=" << r << dendl;
./rgw/rgw_cr_rados.cc:625:    ldout(store->ctx(), 0) << "store->fetch_remote_obj() returned r=" << r << dendl;
./rgw/rgw_cr_rados.cc:637:  ldout(store->ctx(), 0) << __func__ << "(): deleting obj=" << obj << dendl;
./rgw/rgw_cr_rados.cc:645:    ldout(store->ctx(), 20) << __func__ << "(): get_obj_state() obj=" << obj << " returned ret=" << ret << dendl;
./rgw/rgw_cr_rados.cc:651:    ldout(store->ctx(), 20) << __func__ << "(): skipping object removal obj=" << obj << " (obj mtime=" << state->mtime << ", request timestamp=" << timestamp << ")" << dendl;
./rgw/rgw_cr_rados.cc:664:      ldout(store->ctx(), 0) << "ERROR: could not decode policy, caught buffer::error" << dendl;
./rgw/rgw_cr_rados.cc:690:    ldout(store->ctx(), 20) << __func__ << "(): delete_obj() obj=" << obj << " returned ret=" << ret << dendl;
./rgw/rgw_cr_rados.cc:708:        ldout(store->ctx(), 20) << *this << ": couldn't lock " << obj << ":" << lock_name << ": retcode=" << retcode << dendl;
./rgw/rgw_orphan.cc:159:  ldout(store->ctx(), 20) << "storing " << entries.size() << " entries at " << oid << ": " << dendl;
./rgw/rgw_orphan.cc:161:    ldout(store->ctx(), 20) << " > " << iter->first << dendl;
./rgw/rgw_orphan.cc:262:         ldout(store->ctx(), 20) << "adding obj: " << *cur << dendl;
./rgw/rgw_orphan.cc:331:    ldout(store->ctx(), 20) << "oid_fp=" << oid_fp << dendl;
./rgw/rgw_orphan.cc:339:      ldout(store->ctx(), 1) << "iterated through " << total << " objects" << dendl;
./rgw/rgw_orphan.cc:388:      ldout(store->ctx(), 10) << "bucket_instance=" << *iter << " total=" << total << dendl;
./rgw/rgw_orphan.cc:440:    ldout(store->ctx(), 20) << __func__ << ": oid for obj=" << result.obj << ": " << *iter << dendl;
./rgw/rgw_orphan.cc:471:  ldout(store->ctx(), 10) << "building linked oids for bucket instance: " << bucket_instance_id << dendl;
./rgw/rgw_orphan.cc:511:        ldout(store->ctx(), 20) << "obj entry: " << entry.key.name << dendl;
./rgw/rgw_orphan.cc:513:        ldout(store->ctx(), 20) << "obj entry: " << entry.key.name << " [" << entry.key.instance << "]" << dendl;
./rgw/rgw_orphan.cc:516:      ldout(store->ctx(), 20) << __func__ << ": entry.key.name=" << entry.key.name << " entry.key.instance=" << entry.key.instance << dendl;
./rgw/rgw_orphan.cc:567:    ldout(store->ctx(), 0) << "building linked oids index: " << iter->first << "/" << buckets_instance_index.size() << dendl;
./rgw/rgw_orphan.cc:590:        ldout(store->ctx(), 20) << " indexed entry: " << eiter->first << dendl;
./rgw/rgw_orphan.cc:720:        ldout(store->ctx(), 20) << "linked: " << key << dendl;
./rgw/rgw_orphan.cc:733:        ldout(store->ctx(), 20) << "skipping: " << key << " (mtime=" << mtime << " threshold=" << time_threshold << ")" << dendl;
./rgw/rgw_orphan.cc:736:      ldout(store->ctx(), 20) << "leaked: " << key << dendl;
./rgw/rgw_orphan.cc:751:      ldout(store->ctx(), 0) << __func__ << "(): initializing state" << dendl;
./rgw/rgw_orphan.cc:760:      ldout(store->ctx(), 0) << __func__ << "(): building index of all objects in pool" << dendl;
./rgw/rgw_orphan.cc:776:      ldout(store->ctx(), 0) << __func__ << "(): building index of all bucket indexes" << dendl;
./rgw/rgw_orphan.cc:793:      ldout(store->ctx(), 0) << __func__ << "(): building index of all linked objects" << dendl;
./rgw/rgw_orphan.cc:833:        ldout(store->ctx(), 0) << "ERROR: couldn't remove " << iter->second << ": ret=" << r << dendl;
./rgw/rgw_orphan.cc:844:    ldout(store->ctx(), 0) << "ERROR: remove_index(" << all_objs_index << ") returned ret=" << r << dendl;
./rgw/rgw_orphan.cc:848:    ldout(store->ctx(), 0) << "ERROR: remove_index(" << buckets_instance_index << ") returned ret=" << r << dendl;
./rgw/rgw_orphan.cc:852:    ldout(store->ctx(), 0) << "ERROR: remove_index(" << linked_objs_index << ") returned ret=" << r << dendl;
./rgw/rgw_orphan.cc:857:    ldout(store->ctx(), 0) << "ERROR: could not remove job name (" << search_info.job_name << ") ret=" << r << dendl;
./rgw/rgw_coroutine.cc:224:  ldout(cct, 20) << *op << ": operate()" << dendl;
./rgw/rgw_coroutine.cc:227:    ldout(cct, 20) << *op << ": operate() returned r=" << r << dendl;
./rgw/rgw_coroutine.cc:335:    ldout(cct, 15) << "stack " << (void *)this << " end" << dendl;
./rgw/rgw_coroutine.cc:372:        ldout(cct, 20) << "collect(): s=" << (void *)this << " stack=" << (void *)stack << " is still running" << dendl;
./rgw/rgw_coroutine.cc:374:        ldout(cct, 20) << "collect(): s=" << (void *)this << " stack=" << (void *)stack << " explicitly skipping stack" << dendl;
./rgw/rgw_coroutine.cc:382:      ldout(cct, 20) << "collect(): s=" << (void *)this << " stack=" << (void *)stack << " encountered error (r=" << r << "), skipping next stacks" << dendl;
./rgw/rgw_coroutine.cc:388:    ldout(cct, 20) << "collect(): s=" << (void *)this << " stack=" << (void *)stack << " is complete" << dendl;
./rgw/rgw_coroutine.cc:627:      ldout(cct, 20) << "stack->operate() returned ret=" << ret << dendl;
./rgw/rgw_coroutine.cc:637:      ldout(cct, 20) << __func__ << ":" << " stack=" << (void *)stack << " is io blocked" << dendl;
./rgw/rgw_coroutine.cc:646:      ldout(cct, 20) << __func__ << ":" << " stack=" << (void *)stack << " is_blocked_by_stack()=" << stack->is_blocked_by_stack()
./rgw/rgw_coroutine.cc:649:      ldout(cct, 20) << __func__ << ":" << " stack=" << (void *)stack << " is done" << dendl;
./rgw/rgw_coroutine.cc:694:       ldout(cct, 5) << "completion_mgr.get_next() returned ret=" << ret << dendl;
./rgw/rgw_coroutine.cc:705:        ldout(cct, 5) << "completion_mgr.get_next() returned ret=" << ret << dendl;
./rgw/rgw_coroutine.cc:708:	ldout(cct, 5) << __func__ << "(): was stopped, exiting" << dendl;
./rgw/rgw_coroutine.cc:739:    ldout(cct, 20) << "clearing stack on run() exit: stack=" << (void *)stack << " nref=" << stack->get_nref() << dendl;
./rgw/rgw_coroutine.cc:762:    ldout(cct, 20) << "run(stacks) returned r=" << r << dendl;
./rgw/rgw_coroutine.cc:936:          ldout(cct, 10) << "collect() returned ret=" << ret << dendl;
./rgw/rgw_acl_swift.cc:124:    ldout(cct, 10) << "grant user does not exist: " << uid << dendl;
./rgw/rgw_acl_swift.cc:140:    ldout(cct, 20) << "trying to add grant for ACL uid=" << uid << dendl;
./rgw/rgw_acl_swift.cc:192:      ldout(cct, 0) << "ERROR: parse_list for read returned r="
./rgw/rgw_acl_swift.cc:199:      ldout(cct, 0) << "ERROR: add_grants for read returned r="
./rgw/rgw_acl_swift.cc:209:      ldout(cct, 0) << "ERROR: parse_list for write returned r="
./rgw/rgw_acl_swift.cc:216:      ldout(cct, 0) << "ERROR: add_grants for write returned r="
./rgw/rgw_acl_swift.cc:315:        ldout(cct, 10) << "grant user does not exist:" << uid << dendl;
./rgw/rgw_acl_swift.cc:339:    ldout(cct, 0) << "ERROR: JSONParser::parse returned error=" << dendl;
./rgw/rgw_acl_swift.cc:347:    ldout(cct, 0) << "admins: " << admin << dendl;
./rgw/rgw_acl_swift.cc:356:    ldout(cct, 0) << "read-write: " << readwrite << dendl;
./rgw/rgw_acl_swift.cc:365:    ldout(cct, 0) << "read-only: " << readonly << dendl;
./rgw/rgw_asio_frontend.cc:148:      ldout(cct, 1) << "failed to read header: " << ec.message() << dendl;
./rgw/rgw_asio_frontend.cc:156:        ldout(cct, 5) << "failed to write response: " << ec.message() << dendl;
./rgw/rgw_asio_frontend.cc:158:      ldout(cct, 1) << "====== req done http_status=400 ======" << dendl;
./rgw/rgw_asio_frontend.cc:197:        ldout(cct, 5) << "failed to discard unread message: "
./rgw/rgw_asio_frontend.cc:331:    ldout(ctx(), 4) << "frontend listening on " << l.endpoint << dendl;
./rgw/rgw_asio_frontend.cc:446:          ldout(ctx(), 1) << "ssl handshake failed: " << ec.message() << dendl;
./rgw/rgw_asio_frontend.cc:477:  ldout(cct, 4) << "frontend spawning " << thread_count << " threads" << dendl;
./rgw/rgw_asio_frontend.cc:495:  ldout(ctx(), 4) << "frontend initiating shutdown..." << dendl;
./rgw/rgw_asio_frontend.cc:514:  ldout(ctx(), 4) << "frontend joining threads..." << dendl;
./rgw/rgw_asio_frontend.cc:518:  ldout(ctx(), 4) << "frontend done" << dendl;
./rgw/rgw_asio_frontend.cc:523:  ldout(ctx(), 4) << "frontend pausing threads..." << dendl;
./rgw/rgw_asio_frontend.cc:528:  ldout(ctx(), 4) << "frontend paused" << dendl;
./rgw/rgw_asio_frontend.cc:536:  ldout(ctx(), 4) << "frontend unpaused" << dendl;
./rgw/rgw_compression.cc:21:      ldout(cct, 10) << "Compression for rgw is enabled, compress part " << bl.length() << dendl;
./rgw/rgw_compression.cc:30:        ldout(cct, 5) << "Compression failed with exit code " << cr
./rgw/rgw_compression.cc:71:  ldout(cct, 10) << "Compression for rgw is enabled, decompress part "
./rgw/rgw_op.cc:153:    ldout(cct, 0) << "ERROR: could not decode policy, caught buffer::error" << dendl;
./rgw/rgw_op.cc:157:    ldout(cct, 15) << __func__ << " Read AccessControlPolicy";
./rgw/rgw_op.cc:197:    ldout(cct, 0) << "WARNING: couldn't find acl header for bucket, generating default" << dendl;
./rgw/rgw_op.cc:230:    ldout(cct, 0) << "WARNING: couldn't find acl header for object, generating default" << dendl;
./rgw/rgw_op.cc:305:    ldout(s->cct, 0) << "NOTICE: bucket " << bucket_info.bucket.name << " is suspended" << dendl;
./rgw/rgw_op.cc:335:    ldout(s->cct, 0) << "NOTICE: bucket " << bucket_info.bucket.name << " is suspended" << dendl;
./rgw/rgw_op.cc:449:        ldout(s->cct, 0) << "NOTICE: couldn't get bucket from bucket_name (name=" << bucket_log << ")" << dendl;
./rgw/rgw_op.cc:489:      ldout(s->cct, 0) << "NOTICE: request for data in a different zonegroup (" << s->bucket_info.zonegroup << " != " << store->get_zonegroup().get_id() << ")" << dendl;
./rgw/rgw_op.cc:525:      ldout(s->cct, 0) << "NOTICE: couldn't get user attrs for handling ACL (user_id="
./rgw/rgw_op.cc:547:    ldout(s->cct, 20) << "redirect_zone_endpoint=" << s->redirect_zone_endpoint << dendl;
./rgw/rgw_op.cc:596:    ldout(s->cct,0) << "ERROR: caught buffer::error, couldn't decode TagSet" << dendl;
./rgw/rgw_op.cc:772:  ldout(s->cct, 20) << "required_mask= " << required_mask
./rgw/rgw_op.cc:780:    ldout(s->cct, 5) << "NOTICE: modify request to a read-only zone by a non-system user, permission denied"  << dendl;
./rgw/rgw_op.cc:821:    ldout(s->cct, 0) << "ERROR: failed to get obj attrs, obj=" << obj
./rgw/rgw_op.cc:911:  ldout(s->cct, 5) << "NOTICE: call to do_aws4_auth_completion"  << dendl;
./rgw/rgw_op.cc:1017:    ldout(s->cct, 20) << "no CORS configuration attr found" << dendl;
./rgw/rgw_op.cc:1030:    ldout(s->cct, 0) << "ERROR: could not decode policy, caught buffer::error" << dendl;
./rgw/rgw_op.cc:1035:    ldout(s->cct, 15) << "Read RGWCORSConfiguration";
./rgw/rgw_op.cc:1136:  ldout(s->cct, 20) << "user manifest obj=" << ent.key.name << "[" << ent.key.instance << "]" << dendl;
./rgw/rgw_op.cc:1152:  ldout(s->cct, 20) << "reading obj=" << part << " ofs=" << cur_ofs << " end=" << cur_end << dendl;
./rgw/rgw_op.cc:1181:      ldout(s->cct, 0) << "ERROR: expected cs_info.orig_size=" << cs_info.orig_size <<
./rgw/rgw_op.cc:1192:      ldout(s->cct, 0) << "ERROR: expected obj_size=" << obj_size << ", actual read size=" << ent.meta.size << dendl;
./rgw/rgw_op.cc:1204:    ldout(s->cct, 2) << "overriding permissions due to system operation" << dendl;
./rgw/rgw_op.cc:1206:    ldout(s->cct, 2) << "overriding permissions due to admin operation" << dendl;
./rgw/rgw_op.cc:1417:  ldout(s->cct, 2) << "RGWGetObj::handle_user_manifest() prefix="
./rgw/rgw_op.cc:1444:      ldout(s->cct, 0) << "could not get bucket info for bucket="
./rgw/rgw_op.cc:1453:      ldout(s->cct, 0) << "failed to read bucket policy" << dendl;
./rgw/rgw_op.cc:1520:    ldout(s->cct, 0) << "ERROR: failed to decode slo manifest" << dendl;
./rgw/rgw_op.cc:1523:  ldout(s->cct, 2) << "RGWGetObj::handle_slo_manifest()" << dendl;
./rgw/rgw_op.cc:1578:          ldout(s->cct, 0) << "could not get bucket info for bucket="
./rgw/rgw_op.cc:1587:          ldout(s->cct, 0) << "failed to read bucket ACL for bucket "
./rgw/rgw_op.cc:1610:    ldout(s->cct, 20) << "slo_part: ofs=" << ofs
./rgw/rgw_op.cc:1627:  ldout(s->cct, 20) << "s->obj_size=" << s->obj_size << dendl;
./rgw/rgw_op.cc:1765:      ldout(s->cct, 0) << "ERROR: torrents are not supported for objects "
./rgw/rgw_op.cc:1774:      ldout(s->cct, 0) << "ERROR: failed to get_torrent_file ret= " << op_ret
./rgw/rgw_op.cc:1781:      ldout(s->cct, 0) << "ERROR: failed to send_response_data ret= " << op_ret 
./rgw/rgw_op.cc:1804:      ldout(s->cct, 0) << "ERROR: failed to handle user manifest ret="
./rgw/rgw_op.cc:1816:      ldout(s->cct, 0) << "ERROR: failed to handle slo manifest ret=" << op_ret
./rgw/rgw_op.cc:1964:      ldout(s->cct, 10) << "WARNING: failed on rgw_get_user_buckets uid="
./rgw/rgw_op.cc:2029:      ldout(store->ctx(), 0) << "ERROR: failed to parse start date" << dendl;
./rgw/rgw_op.cc:2037:      ldout(store->ctx(), 0) << "ERROR: failed to parse end date" << dendl;
./rgw/rgw_op.cc:2064:    ldout(store->ctx(), 0) << "ERROR: failed to sync user stats" << dendl;
./rgw/rgw_op.cc:2070:    ldout(store->ctx(), 0) << "ERROR: failed to get user's buckets stats" << dendl;
./rgw/rgw_op.cc:2077:    ldout(store->ctx(), 0) << "ERROR: can't read user header"  << dendl;
./rgw/rgw_op.cc:2107:      ldout(s->cct, 10) << "WARNING: failed on rgw_get_user_buckets uid="
./rgw/rgw_op.cc:2187:      ldout(s->cct, 20) << __func__ << " forward_request_to_master returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:2222:    ldout(s->cct, 0) << "NOTICE: put_bucket_info on bucket=" << s->bucket.name
./rgw/rgw_op.cc:2265:      ldout(s->cct, 20) << __func__ << " forward_request_to_master returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:2279:    ldout(s->cct, 0) << "NOTICE: put_bucket_info on bucket=" << s->bucket.name << " returned err=" << op_ret << dendl;
./rgw/rgw_op.cc:2304:    ldout(s->cct, 0) << "NOTICE: put_bucket_info on bucket=" << s->bucket.name << " returned err=" << op_ret << dendl;
./rgw/rgw_op.cc:2406:    ldout(s->cct, 0) <<
./rgw/rgw_op.cc:2465:    ldout(s->cct, 10) << "user cannot create a bucket in a different tenant"
./rgw/rgw_op.cc:2499:    ldout(s->cct, 0) << "rest connection is invalid" << dendl;
./rgw/rgw_op.cc:2502:  ldout(s->cct, 0) << "sending request to master zonegroup" << dendl;
./rgw/rgw_op.cc:2511:  ldout(s->cct, 20) << "response: " << response.c_str() << dendl;
./rgw/rgw_op.cc:2513:    ldout(s->cct, 0) << "failed parsing response from master zonegroup" << dendl;
./rgw/rgw_op.cc:2708:      ldout(s->cct, 0) << "location constraint (" << location_constraint << ")"
./rgw/rgw_op.cc:2717:    ldout(s->cct, 0) << "location constraint (" << location_constraint << ")"
./rgw/rgw_op.cc:2728:    ldout(s->cct, 0) << "placement target (" << placement_rule << ")"
./rgw/rgw_op.cc:2773:    ldout(s->cct, 20) << "parsed: objv.tag=" << objv.tag << " objv.ver=" << objv.ver << dendl;
./rgw/rgw_op.cc:2774:    ldout(s->cct, 20) << "got creation time: << " << master_info.creation_time << dendl;
./rgw/rgw_op.cc:2860:  ldout(s->cct, 20) << "rgw_create_bucket returned ret=" << op_ret << " bucket=" << s->bucket << dendl;
./rgw/rgw_op.cc:2888:      ldout(s->cct, 0) << "WARNING: failed to unlink bucket: ret=" << op_ret
./rgw/rgw_op.cc:2976:    ldout(s->cct, 0) << "ERROR: bucket " << s->bucket_name << " not found" << dendl;
./rgw/rgw_op.cc:2992:        ldout(s->cct, 0) << "failed to parse ver param" << dendl;
./rgw/rgw_op.cc:3002:     ldout(s->cct, 1) << "WARNING: failed to sync user stats before bucket delete: op_ret= " << op_ret << dendl;
./rgw/rgw_op.cc:3058:      ldout(s->cct, 0) << "WARNING: failed to unlink bucket: ret=" << op_ret
./rgw/rgw_op.cc:3108:    ldout(s->cct, 20) << "get_params() returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:3171:    ldout(s->cct, 10) << "part number is empty" << dendl;
./rgw/rgw_op.cc:3179:    ldout(s->cct, 10) << "bad part number: " << part_num << ": " << err << dendl;
./rgw/rgw_op.cc:3473:    ldout(s->cct, 20) << "get_system_versioning_params() returned ret="
./rgw/rgw_op.cc:3481:    ldout(s->cct, 15) << "supplied_md5_b64=" << supplied_md5_b64 << dendl;
./rgw/rgw_op.cc:3484:    ldout(s->cct, 15) << "ceph_armor ret=" << op_ret << dendl;
./rgw/rgw_op.cc:3491:    ldout(s->cct, 15) << "supplied_md5=" << supplied_md5 << dendl;
./rgw/rgw_op.cc:3499:      ldout(s->cct, 20) << "check_quota() returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:3504:      ldout(s->cct, 20) << "check_bucket_shards() returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:3533:    ldout(s->cct, 20) << "processor->prepare() returned ret=" << op_ret
./rgw/rgw_op.cc:3546:      ldout(s->cct, 0) << "ERROR: get copy source obj state returned with error" << op_ret << dendl;
./rgw/rgw_op.cc:3571:        ldout(s->cct, 1) << "Cannot load plugin for compression type "
./rgw/rgw_op.cc:3598:      ldout(s->cct, 20) << "get_data() returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:3623:        ldout(s->cct, 20) << "processor->thottle_data() returned ret="
./rgw/rgw_op.cc:3628:      ldout(s->cct, 5) << "NOTICE: processor->throttle_data() returned -EEXIST, need to restart write" << dendl;
./rgw/rgw_op.cc:3646:        ldout(s->cct, 0) << "ERROR: processor->prepare() returned "
./rgw/rgw_op.cc:3697:    ldout(s->cct, 20) << "second check_quota() returned op_ret=" << op_ret << dendl;
./rgw/rgw_op.cc:3703:    ldout(s->cct, 20) << "check_bucket_shards() returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:3717:    ldout(s->cct, 20) << "storing " << RGW_ATTR_COMPRESSION
./rgw/rgw_op.cc:3738:      ldout(s->cct, 0) << "bad user manifest: " << dlo_manifest << dendl;
./rgw/rgw_op.cc:3742:    ldout(s->cct, 10) << __func__ << ": calculated md5 for user manifest: " << etag << dendl;
./rgw/rgw_op.cc:3752:    ldout(s->cct, 10) << __func__ << ": calculated md5 for user manifest: " << etag << dendl;
./rgw/rgw_op.cc:3797:      ldout(s->cct, 0) << "ERROR: torrent.handle_data() returned " << op_ret << dendl;
./rgw/rgw_op.cc:3877:      ldout(s->cct, 15) << "supplied_md5_b64=" << supplied_md5_b64 << dendl;
./rgw/rgw_op.cc:3880:      ldout(s->cct, 15) << "ceph_armor ret=" << op_ret << dendl;
./rgw/rgw_op.cc:3887:      ldout(s->cct, 15) << "supplied_md5=" << supplied_md5 << dendl;
./rgw/rgw_op.cc:3918:          ldout(s->cct, 1) << "Cannot load plugin for compression type "
./rgw/rgw_op.cc:4288:      ldout(s->cct, 0) << "bad user manifest: " << dlo_manifest << dendl;
./rgw/rgw_op.cc:4303:    ldout(s->cct, 0) << "ERROR: failed to decode slo manifest" << dendl;
./rgw/rgw_op.cc:4366:    ldout(s->cct, 5) << "NOTICE: object delete request with a versioned object, mfa auth not provided" << dendl;
./rgw/rgw_op.cc:4409:          ldout(s->cct, 0) << "ERROR: failed to handle slo manifest ret=" << op_ret << dendl;
./rgw/rgw_op.cc:4894:      ldout(s->cct, 4) << "The size of request xml data is larger than the max limitation, data size = "
./rgw/rgw_op.cc:4904:  ldout(s->cct, 15) << "read len=" << len << " data=" << (data ? data : "") << dendl;
./rgw/rgw_op.cc:4942:    ldout(s->cct, 4) << "An acl can have up to "
./rgw/rgw_op.cc:4962:      ldout(s->cct, 20) << __func__ << " forward_request_to_master returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:4968:    ldout(s->cct, 15) << "Old AccessControlPolicy";
./rgw/rgw_op.cc:4978:    ldout(s->cct, 15) << "New AccessControlPolicy:";
./rgw/rgw_op.cc:5025:    ldout(s->cct, 5) << s->err.message << dendl;
./rgw/rgw_op.cc:5035:    ldout(s->cct, 5) << s->err.message << dendl;
./rgw/rgw_op.cc:5049:  ldout(s->cct, 15) << "read len=" << len << " data=" << (data ? data : "") << dendl;
./rgw/rgw_op.cc:5059:    ldout(s->cct, 5) << s->err.message
./rgw/rgw_op.cc:5081:    ldout(s->cct, 15) << "New LifecycleConfiguration:";
./rgw/rgw_op.cc:5131:    ldout(s->cct, 0) << "RGWLC::RGWDeleteLC() failed to set attrs on bucket=" << s->bucket.name
./rgw/rgw_op.cc:5199:      ldout(s->cct, 20) << __func__ << " forward_request_to_master returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:5235:	ldout(s->cct, 0) << "RGWLC::RGWDeleteCORS() failed to set attrs on bucket=" << s->bucket.name
./rgw/rgw_op.cc:5336:    ldout(s->cct, 0) << "NOTICE: put_bucket_info on bucket=" << s->bucket.name
./rgw/rgw_op.cc:5451:          ldout(s->cct, 0) << "ERROR: could not decode policy, caught buffer::error" << dendl;
./rgw/rgw_op.cc:5590:    ldout(s->cct, 0) << "ERROR: failed to get obj attrs, obj=" << meta_obj
./rgw/rgw_op.cc:5606:      ldout(s->cct, 0) << "NOTICE: total parts mismatch: have: " << total_parts
./rgw/rgw_op.cc:5622:        ldout(s->cct, 0) << "NOTICE: parts num mismatch: next requested: "
./rgw/rgw_op.cc:5630:        ldout(s->cct, 0) << "NOTICE: etag mismatch: part: " << iter->first
./rgw/rgw_op.cc:5648:        ldout(s->cct, 0) << "ERROR: empty manifest for object part: obj="
./rgw/rgw_op.cc:5660:          ldout(s->cct, 0) << "ERROR: compression type was changed during multipart upload ("
./rgw/rgw_op.cc:5701:  ldout(s->cct, 10) << "calculated etag: " << final_etag_str << dendl;
./rgw/rgw_op.cc:5750:      ldout(store->ctx(), 0) << "WARNING: failed to remove object "
./rgw/rgw_op.cc:5776:      ldout(store->ctx(), 0) << "WARNING: failed to unlock "
./rgw/rgw_op.cc:5994:      ldout(s->cct, 5) << "NOTICE: multi-object delete request with a versioned object, mfa auth not provided" << dendl;
./rgw/rgw_op.cc:6122:        ldout(s->cct, 0) << "WARNING: failed to unlink bucket: ret=" << ret
./rgw/rgw_op.cc:6151:      ldout(store->ctx(), 20) << "cannot find bucket = " << path.bucket_name << dendl;
./rgw/rgw_op.cc:6154:      ldout(store->ctx(), 20) << "cannot get bucket info, ret = " << ret
./rgw/rgw_op.cc:6166:    ldout(store->ctx(), 20) << "wrong auth for " << path << dendl;
./rgw/rgw_op.cc:6178:      ldout(store->ctx(), 20) << "cannot find entry " << path << dendl;
./rgw/rgw_op.cc:6192:  ldout(store->ctx(), 20) << "in delete_chunk" << dendl;
./rgw/rgw_op.cc:6194:    ldout(store->ctx(), 20) << "bulk deleting path: " << path << dendl;
./rgw/rgw_op.cc:6244:    ldout(s->cct, 10) << "user cannot create a bucket in a different tenant"
./rgw/rgw_op.cc:6341:  ldout(cct, 20) << "append the bucket: "<< bucket_name << " to req_info" << dendl;
./rgw/rgw_op.cc:6349:  ldout(s->cct, 20) << "bulk upload: got directory=" << path << dendl;
./rgw/rgw_op.cc:6406:    ldout(s->cct, 20) << "parsed: objv.tag=" << objv.tag << " objv.ver="
./rgw/rgw_op.cc:6408:    ldout(s->cct, 20) << "got creation_time="<< master_info.creation_time
./rgw/rgw_op.cc:6434:      ldout(s->cct, 20) << "bulk upload: non-coherent placement rule" << dendl;
./rgw/rgw_op.cc:6465:  ldout(s->cct, 20) << "rgw_create_bucket returned ret=" << op_ret
./rgw/rgw_op.cc:6482:      ldout(s->cct, 20) << "bulk upload: conflicting bucket name" << dendl;
./rgw/rgw_op.cc:6495:      ldout(s->cct, 0) << "bulk upload: WARNING: failed to unlink bucket: ret="
./rgw/rgw_op.cc:6499:    ldout(s->cct, 20) << "bulk upload: containers already exists"
./rgw/rgw_op.cc:6516:    ldout(s->cct, 20) << "bulk upload: cannot read_policy() for bucket"
./rgw/rgw_op.cc:6543:  ldout(s->cct, 20) << "bulk upload: got file=" << path << ", size=" << size
./rgw/rgw_op.cc:6565:    ldout(s->cct, 20) << "bulk upload: non existent directory=" << bucket_name
./rgw/rgw_op.cc:6574:    ldout(s->cct, 20) << "bulk upload: object creation unauthorized" << dendl;
./rgw/rgw_op.cc:6604:    ldout(s->cct, 20) << "bulk upload: cannot prepare processor due to ret="
./rgw/rgw_op.cc:6615:      ldout(s->cct, 1) << "Cannot load plugin for rgw_compression_type "
./rgw/rgw_op.cc:6631:    ldout(s->cct, 20) << "bulk upload: body=" << data.c_str() << dendl;
./rgw/rgw_op.cc:6639:        ldout(s->cct, 20) << "processor->thottle_data() returned ret="
./rgw/rgw_op.cc:6650:    ldout(s->cct, 10) << "bulk upload: real file size different from declared"
./rgw/rgw_op.cc:6658:    ldout(s->cct, 20) << "bulk upload: quota exceeded for path=" << path
./rgw/rgw_op.cc:6702:    ldout(s->cct, 20) << "bulk upload: processor::complete returned op_ret="
./rgw/rgw_op.cc:6713:  ldout(s->cct, 20) << "bulk upload: start" << dendl;
./rgw/rgw_op.cc:6731:      ldout(s->cct, 2) << "bulk upload: cannot read header" << dendl;
./rgw/rgw_op.cc:6749:          ldout(s->cct, 2) << "bulk upload: handling regular file" << dendl;
./rgw/rgw_op.cc:6767:          ldout(s->cct, 2) << "bulk upload: handling regular directory" << dendl;
./rgw/rgw_op.cc:6787:        ldout(s->cct, 2) << "bulk upload: terminating due to ret=" << op_ret
./rgw/rgw_op.cc:6792:      ldout(s->cct, 2) << "bulk upload: an empty block" << dendl;
./rgw/rgw_op.cc:6915:    ldout(s->cct, 20) << "NOTICE: get_params() returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:6923:    ldout(s->cct, 0) << "NOTICE: put_bucket_info on bucket=" << s->bucket.name << " returned err=" << op_ret << dendl;
./rgw/rgw_op.cc:6962:    ldout(s->cct, 0) << "NOTICE: put_bucket_info on bucket=" << s->bucket.name << " returned err=" << op_ret << dendl;
./rgw/rgw_op.cc:6986:    ldout(s->cct, 10) << "init_permissions on " << s->bucket
./rgw/rgw_op.cc:7004:    ldout(s->cct, 10) << "read_permissions on " << s->bucket << ":"
./rgw/rgw_op.cc:7064:      ldout(s->cct, 20) << "forward_request_to_master returned ret=" << op_ret << dendl;
./rgw/rgw_op.cc:7080:    ldout(s->cct, 20) << "failed to parse policy: " << e.what() << dendl;
./rgw/rgw_op.cc:7109:    ldout(s->cct, 0) << __func__ << " can't find bucket IAM POLICY attr" 
./rgw/rgw_op.cc:7118:      ldout(s->cct, 10) << "The bucket policy does not exist, bucket: " << s->bucket_name << dendl;
./rgw/rgw_acl_s3.cc:233:      ldout(cct, 0) << "ERROR: group_to_uri failed with group=" << (int)group << dendl;
./rgw/rgw_acl_s3.cc:491:    ldout(cct, 10) << "owner info does not exist" << dendl;
./rgw/rgw_acl_s3.cc:498:  ldout(cct, 20) << "owner id=" << owner->get_id() << dendl;
./rgw/rgw_acl_s3.cc:499:  ldout(cct, 20) << "dest owner id=" << dest.get_owner().get_id() << dendl;
./rgw/rgw_acl_s3.cc:518:          ldout(cct, 0) << "ERROR: src_grant.get_id() failed" << dendl;
./rgw/rgw_acl_s3.cc:522:        ldout(cct, 10) << "grant user email=" << email << dendl;
./rgw/rgw_acl_s3.cc:524:          ldout(cct, 10) << "grant user email not found or other error" << dendl;
./rgw/rgw_acl_s3.cc:533:            ldout(cct, 0) << "ERROR: src_grant.get_id() failed" << dendl;
./rgw/rgw_acl_s3.cc:539:          ldout(cct, 10) << "grant user does not exist:" << uid << dendl;
./rgw/rgw_acl_s3.cc:547:          ldout(cct, 10) << "new grant: " << new_id << ":" << grant_user.display_name << dendl;
./rgw/rgw_acl_s3.cc:557:          ldout(cct, 10) << "new grant: " << uri << dendl;
./rgw/rgw_acl_s3.cc:559:          ldout(cct, 10) << "bad grant group:" << (int)src_grant.get_group() << dendl;
./rgw/rgw_auth.cc:264:      ldout(s->cct, 5) << "Failed the auth strategy, reason="
./rgw/rgw_auth.cc:291:      ldout(s->cct, 5) << "applier throwed err=" << err << dendl;
./rgw/rgw_auth.cc:295:    ldout(s->cct, 5) << "auth engine throwed err=" << err << dendl;
./rgw/rgw_auth.cc:335:  ldout(cct, 20) << "from ACL got perm=" << perm << dendl;
./rgw/rgw_auth.cc:410:    ldout(cct, 0) << "ERROR: failed to store new user info: user="
./rgw/rgw_auth.cc:445:    ldout(cct, 0) << "NOTICE: couldn't map swift user " << acct_user << dendl;
./rgw/rgw_sync_log_trim.cc:275:    ldout(store->ctx(), 10) << "Watching " << ref.oid << dendl;
./rgw/rgw_sync_log_trim.cc:331:      ldout(store->ctx(), 4) << "Disconnected watch on " << ref.oid << dendl;
./rgw/rgw_sync_log_trim.cc:405:      ldout(cct, 10) << "trimming bilog shard " << shard_id
./rgw/rgw_sync_log_trim.cc:447:    ldout(cct, 4) << "starting trim on bucket=" << bucket_instance << dendl;
./rgw/rgw_sync_log_trim.cc:487:      ldout(cct, 4) << "failed to correlate bucket sync status from peers" << dendl;
./rgw/rgw_sync_log_trim.cc:492:    ldout(cct, 10) << "trimming bilogs for bucket=" << bucket_info.bucket
./rgw/rgw_sync_log_trim.cc:501:      ldout(cct, 4) << "failed to trim bilog shards: "
./rgw/rgw_sync_log_trim.cc:603:    ldout(cct, 10) << "failed to init metadata listing: "
./rgw/rgw_sync_log_trim.cc:607:  ldout(cct, 20) << "starting metadata listing at " << start_marker << dendl;
./rgw/rgw_sync_log_trim.cc:617:      ldout(cct, 10) << "failed to list metadata: "
./rgw/rgw_sync_log_trim.cc:643:    ldout(cct, 10) << "failed to restart metadata listing: "
./rgw/rgw_sync_log_trim.cc:647:  ldout(cct, 20) << "restarting metadata listing" << dendl;
./rgw/rgw_sync_log_trim.cc:653:      ldout(cct, 10) << "failed to list metadata: "
./rgw/rgw_sync_log_trim.cc:747:      ldout(cct, 10) << "fetching active bucket counters" << dendl;
./rgw/rgw_sync_log_trim.cc:760:        ldout(cct, 10) << "failed to fetch peer bucket counters" << dendl;
./rgw/rgw_sync_log_trim.cc:767:        ldout(cct, 4) << "failed to correlate peer bucket counters" << dendl;
./rgw/rgw_sync_log_trim.cc:787:        ldout(cct, 10) << "failed to read bilog trim status: "
./rgw/rgw_sync_log_trim.cc:794:      ldout(cct, 10) << "listing cold buckets from marker="
./rgw/rgw_sync_log_trim.cc:823:        ldout(cct, 4) << "failed to list bucket instance metadata: "
./rgw/rgw_sync_log_trim.cc:831:    ldout(cct, 4) << "collected " << buckets.size() << " buckets for trim" << dendl;
./rgw/rgw_sync_log_trim.cc:840:      ldout(cct, 20) << "writing bucket trim marker=" << status.marker << dendl;
./rgw/rgw_sync_log_trim.cc:845:        ldout(cct, 4) << "failed to write updated trim status: "
./rgw/rgw_sync_log_trim.cc:863:      ldout(cct, 10) << "failed to notify peers of trim completion" << dendl;
./rgw/rgw_sync_log_trim.cc:867:    ldout(cct, 4) << "bucket index log processing completed in "
./rgw/rgw_sync_log_trim.cc:908:        ldout(cct, 4) << "failed to lock: " << cpp_strerror(retcode) << dendl;
./rgw/rgw_sync_log_trim.cc:1032:    ldout(store->ctx(), 20) << "get_bucket_counters: " << buckets << dendl;
./rgw/rgw_sync_log_trim.cc:1036:    ldout(store->ctx(), 20) << "bucket trim completed" << dendl;
./rgw/rgw_sync_log_trim.cc:1044:    ldout(store->ctx(), 20) << "trimmed bucket instance " << bucket_instance << dendl;
./rgw/rgw_tools.cc:144:    ldout(cct, 0) << __func__ << " failed to open file=" << ext_map
./rgw/rgw_tools.cc:153:    ldout(cct, 0) << __func__ << " failed to stat file=" << ext_map
./rgw/rgw_tools.cc:161:    ldout(cct, 0) << __func__ << " failed to allocate buf" << dendl;
./rgw/rgw_tools.cc:168:    ldout(cct, 0) << __func__ << " raced! will retry.." << dendl;
./osdc/Journaler.cc:45:  ldout(cct, 1) << "set_readonly" << dendl;
./osdc/Journaler.cc:53:  ldout(cct, 1) << "set_writeable" << dendl;
./osdc/Journaler.cc:73:  ldout(cct, 1) << "created blank journal at inode 0x" << std::hex << ino
./osdc/Journaler.cc:165:  ldout(cct, 1) << "recover start" << dendl;
./osdc/Journaler.cc:173:    ldout(cct, 1) << "recover - already recovering" << dendl;
./osdc/Journaler.cc:177:  ldout(cct, 1) << "read_head" << dendl;
./osdc/Journaler.cc:209:  ldout(cct, 10) << "reread_head" << dendl;
./osdc/Journaler.cc:258:    ldout(cct, 0) << "error getting journal off disk" << dendl;
./osdc/Journaler.cc:266:    ldout(cct, 1) << "_finish_read_head r=" << r
./osdc/Journaler.cc:283:      ldout(cct, 0) << "on disk magic '" << h.magic << "' != my magic '"
./osdc/Journaler.cc:287:      ldout(cct, 0) << "Corrupt header (bad offsets): " << h << dendl;
./osdc/Journaler.cc:311:  ldout(cct, 1) << "_finish_read_head " << h
./osdc/Journaler.cc:322:  ldout(cct, 1) << "probing for end of the log" << dendl;
./osdc/Journaler.cc:331:  ldout(cct, 10) << "reprobe" << dendl;
./osdc/Journaler.cc:350:  ldout(cct, 1) << "_finish_reprobe new_end = " << new_end
./osdc/Journaler.cc:370:    ldout(cct, 1) << "_finish_probe_end write_pos = " << end << " (header had "
./osdc/Journaler.cc:375:    ldout(cct, 1) << "_finish_probe_end write_pos = " << end
./osdc/Journaler.cc:455:  ldout(cct, 10) << "write_head " << last_written << dendl;
./osdc/Journaler.cc:487:  ldout(cct, 10) << "_finish_write_head " << wrote << dendl;
./osdc/Journaler.cc:539:  ldout(cct, 10) << "_finish_flush safe from " << start
./osdc/Journaler.cc:574:    ldout(cct, 10) << "write_buf_throttle wait, delta " << delta << dendl;
./osdc/Journaler.cc:578:  ldout(cct, 20) << "write_buf_throttle get, delta " << delta << dendl;
./osdc/Journaler.cc:580:  ldout(cct, 10) << "append_entry len " << s << " to " << write_pos << "~"
./osdc/Journaler.cc:591:    ldout(cct, 10) << " flushing completed object(s) (su " << su << " wro "
./osdc/Journaler.cc:631:      ldout(cct, 10) << "_do_flush wanted to do " << flush_pos << "~" << len
./osdc/Journaler.cc:638:      ldout(cct, 10) << "_do_flush wanted to do " << flush_pos << "~" << len
./osdc/Journaler.cc:645:  ldout(cct, 10) << "_do_flush flushing " << flush_pos << "~" << len << dendl;
./osdc/Journaler.cc:684:  ldout(cct, 20) << "write_buf_throttle put, len " << len << dendl;
./osdc/Journaler.cc:686:  ldout(cct, 10)
./osdc/Journaler.cc:712:    ldout(cct, 10)
./osdc/Journaler.cc:744:    ldout(cct, 10) << "flush nothing to flush, (prezeroing/prezero)/write/"
./osdc/Journaler.cc:795:    ldout(cct, 20) << "_issue_prezero target " << to << " <= prezeroing_pos "
./osdc/Journaler.cc:804:      ldout(cct, 10) << "_issue_prezero removing " << prezeroing_pos << "~"
./osdc/Journaler.cc:808:      ldout(cct, 10) << "_issue_prezero zeroing " << prezeroing_pos << "~"
./osdc/Journaler.cc:827:  ldout(cct, 10) << "_prezeroed to " << start << "~" << len
./osdc/Journaler.cc:861:  ldout(cct, 10) << "_prezeroed prezeroing/prezero now " << prezeroing_pos
./osdc/Journaler.cc:913:    ldout(cct, 0) << "_finish_read got error " << r << dendl;
./osdc/Journaler.cc:916:    ldout(cct, 10) << "_finish_read got " << offset << "~" << bl.length()
./osdc/Journaler.cc:919:      ldout(cct, 0) << "_finish_read got less than expected (" << length << ")"
./osdc/Journaler.cc:960:      ldout(cct, 10) << "_assimilate_prefetch gap of " << gap
./osdc/Journaler.cc:966:    ldout(cct, 10) << "_assimilate_prefetch " << p->first << "~"
./osdc/Journaler.cc:976:    ldout(cct, 10) << "_assimilate_prefetch read_buf now " << read_pos << "~"
./osdc/Journaler.cc:988:    ldout(cct, 10) << "_finish_read now readable (or at journal end) readable="
./osdc/Journaler.cc:1005:    ldout(cct, 10) << "_issue_read requested_pos = safe_pos = " << safe_pos
./osdc/Journaler.cc:1027:    ldout(cct, 10) << "_issue_read reading only up to safe_pos " << safe_pos
./osdc/Journaler.cc:1032:  ldout(cct, 10) << "_issue_read reading " << requested_pos << "~" << len
./osdc/Journaler.cc:1060:  ldout(cct, 10) << "_prefetch" << dendl;
./osdc/Journaler.cc:1064:    ldout(cct, 10) << "_prefetch temp_fetch_len " << temp_fetch_len << dendl;
./osdc/Journaler.cc:1085:    ldout(cct, 10) << "_prefetch " << pf << " requested_pos " << requested_pos
./osdc/Journaler.cc:1094:      ldout(cct, 10) << "_prefetch: requested_pos=" << requested_pos
./osdc/Journaler.cc:1121:  ldout (cct, 10) << "_is_readable read_buf.length() == " << read_buf.length()
./osdc/Journaler.cc:1127:    ldout(cct, 10) << "is_readable() detected partial entry at tail, "
./osdc/Journaler.cc:1146:    ldout(cct, 10) << "_is_readable noting temp_fetch_len " << temp_fetch_len
./osdc/Journaler.cc:1150:  ldout(cct, 10) << "_is_readable: not readable, returning false" << dendl;
./osdc/Journaler.cc:1231:    ldout(cct, 10) << "try_read_entry at " << read_pos << " not readable"
./osdc/Journaler.cc:1249:  ldout(cct, 10) << "try_read_entry at " << read_pos << " read "
./osdc/Journaler.cc:1278:    ldout(cct, 10) << "wait_for_readable at " << read_pos << " onreadable "
./osdc/Journaler.cc:1323:  ldout(cct, 10) << "trim last_commited head was " << last_committed
./osdc/Journaler.cc:1327:    ldout(cct, 10) << "trim already trimmed/trimming to "
./osdc/Journaler.cc:1333:    ldout(cct, 10) << "trim already trimming atm, try again later.  "
./osdc/Journaler.cc:1342:  ldout(cct, 10) << "trim trimming to " << trim_to
./osdc/Journaler.cc:1362:  ldout(cct, 10) << "_finish_trim trimmed_pos was " << trimmed_pos
./osdc/Journaler.cc:1567:  ldout(cct, 1) << __func__ << dendl;
./osdc/Filer.cc:79:  ldout(cct, 10) << "probe " << (fwd ? "fwd ":"bwd ")
./osdc/Filer.cc:102:  ldout(cct, 10) << "probe " << (fwd ? "fwd ":"bwd ")
./osdc/Filer.cc:148:  ldout(cct, 10) << "_probe " << hex << probe->ino << dec
./osdc/Filer.cc:162:    ldout(cct, 10) << "_probe  probing " << p->oid << dendl;
./osdc/Filer.cc:187:  ldout(cct, 10) << "_probed " << probe->ino << " object " << oid
./osdc/Filer.cc:218:    ldout(cct, 10) << "_probed  " << probe->ino << " object " << hex
./osdc/Filer.cc:240:	  ldout(cct, 10) << "_probed  end is in buffer_extent " << i->first
./osdc/Filer.cc:246:	  ldout(cct, 10) << "_probed found size at " << end << dendl;
./osdc/Filer.cc:262:    ldout(cct, 10) << "_probed probing further" << dendl;
./osdc/Filer.cc:279:    ldout(cct, 10) << "_probed found mtime " << probe->max_mtime << dendl;
./osdc/Filer.cc:282:    ldout(cct, 10) << "_probed found mtime " << probe->max_mtime << dendl;
./osdc/Filer.cc:350:  ldout(cct, 10) << "_do_purge_range " << pr->ino << " objects " << pr->first
./osdc/Filer.cc:448:  ldout(cct, 10) << "_do_truncate_range " << tr->ino << " objects " << tr->offset
./osdc/Striper.cc:50:  ldout(cct, 10) << "file_to_extents " << offset << "~" << len
./osdc/Striper.cc:66:    ldout(cct, 20) << " sc is one, reset su to os" << dendl;
./osdc/Striper.cc:70:  ldout(cct, 20) << " su " << su << " sc " << stripe_count << " os "
./osdc/Striper.cc:105:    ldout(cct, 20) << " off " << cur << " blockno " << blockno << " stripeno "
./osdc/Striper.cc:126:      ldout(cct, 20) << " added new " << *ex << dendl;
./osdc/Striper.cc:130:      ldout(cct, 20) << " adding in to " << *ex << dendl;
./osdc/Striper.cc:136:    ldout(cct, 15) << "file_to_extents  " << *ex << " in " << ex->oloc
./osdc/Striper.cc:138:    // ldout(cct, 0) << "map: ino " << ino << " oid " << ex.oid << " osd "
./osdc/Striper.cc:168:  ldout(cct, 10) << "extent_to_file " << objectno << " " << off << "~"
./osdc/Striper.cc:176:  ldout(cct, 20) << " stripes_per_object " << stripes_per_object << dendl;
./osdc/Striper.cc:191:    ldout(cct, 20) << " object " << off << "~" << extent_len
./osdc/Striper.cc:236:  ldout(cct, 20) << "object_truncate_size " << objectno << " "
./osdc/Striper.cc:263:  ldout(cct, 10) << "add_partial_result(" << this << ") " << bl.length()
./osdc/Striper.cc:281:  ldout(cct, 10) << "add_partial_sparse_result(" << this << ") " << bl.length()
./osdc/Striper.cc:291:    ldout(cct, 30) << " be " << tofs << "~" << tlen << dendl;
./osdc/Striper.cc:293:      ldout(cct, 20) << "  t " << tofs << "~" << tlen
./osdc/Striper.cc:298:	ldout(cct, 20) << "  s at end" << dendl;
./osdc/Striper.cc:305:      ldout(cct, 30) << "  s " << s->first << "~" << s->second << dendl;
./osdc/Striper.cc:309:	ldout(cct, 30) << "  s len 0, skipping" << dendl;
./osdc/Striper.cc:318:	ldout(cct, 20) << "  s gap " << gap << ", skipping" << dendl;
./osdc/Striper.cc:334:	ldout(cct, 20) << "  s has " << actual << ", copying" << dendl;
./osdc/Striper.cc:344:	ldout(cct, 30) << "  s advancing" << dendl;
./osdc/Striper.cc:355:  ldout(cct, 10) << "assemble_result(" << this << ") zero_tail=" << zero_tail
./osdc/Striper.cc:389:    ldout(cct, 20) << "assemble_result(" << this << ") " << p->first << "~" << p->second.second
./osdc/Objecter.cc:461:  ldout(cct, 20) << __func__ << " clearing up homeless session..." << dendl;
./osdc/Objecter.cc:465:    ldout(cct, 10) << " linger_op " << i->first << dendl;
./osdc/Objecter.cc:478:    ldout(cct, 10) << " op " << i->first << dendl;
./osdc/Objecter.cc:490:    ldout(cct, 10) << " command_op " << i->first << dendl;
./osdc/Objecter.cc:501:      ldout(cct, 10) <<  " successfully canceled tick" << dendl;
./osdc/Objecter.cc:536:    ldout(cct, 15) << "send_linger " << info->linger_id << " reconnect"
./osdc/Objecter.cc:545:    ldout(cct, 15) << "send_linger " << info->linger_id << " register"
./osdc/Objecter.cc:590:  ldout(cct, 10) << "_linger_commit " << info->linger_id << dendl;
./osdc/Objecter.cc:609:      ldout(cct, 10) << "_linger_commit  notify_id=" << info->notify_id
./osdc/Objecter.cc:652:  ldout(cct, 10) << __func__ << " " << info->linger_id << " = " << r
./osdc/Objecter.cc:673:    ldout(cct, 10) << __func__ << " " << info->linger_id << " SKIPPING"
./osdc/Objecter.cc:678:    ldout(cct, 10) << __func__ << " PAUSERD" << dendl;
./osdc/Objecter.cc:683:  ldout(cct, 10) << __func__ << " " << info->linger_id << " now " << now
./osdc/Objecter.cc:711:  ldout(cct, 10) << __func__ << " " << info->linger_id
./osdc/Objecter.cc:726:    ldout(cct, 20) << " ignoring old gen" << dendl;
./osdc/Objecter.cc:739:  ldout(cct, 10) << __func__ << " " << info->linger_id
./osdc/Objecter.cc:759:  ldout(cct, 20) << __func__ << " linger_id=" << info->linger_id << dendl;
./osdc/Objecter.cc:795:  ldout(cct, 10) << __func__ << " info " << info
./osdc/Objecter.cc:903:    ldout(cct, 7) << __func__ << " cookie " << m->cookie << " dne" << dendl;
./osdc/Objecter.cc:920:      ldout(cct, 10) << __func__ << " reply notify " << m->notify_id
./osdc/Objecter.cc:937:  ldout(cct, 10) << __func__ << " " << *m << dendl;
./osdc/Objecter.cc:969:  ldout(cct, 10) << __func__ << " " << cct << " " << *m << dendl;
./osdc/Objecter.cc:1040:    ldout(cct, 10) << " checking linger op " << op->linger_id << dendl;
./osdc/Objecter.cc:1058:	ldout(cct, 10) << " need to unregister linger op "
./osdc/Objecter.cc:1072:    ldout(cct, 10) << " checking op " << op->tid << dendl;
./osdc/Objecter.cc:1104:    ldout(cct, 10) << " checking command " << c->tid << dendl;
./osdc/Objecter.cc:1148:    ldout(cct, 0) << "handle_osd_map fsid " << m->fsid
./osdc/Objecter.cc:1169:    ldout(cct, 3) << "handle_osd_map ignoring epochs ["
./osdc/Objecter.cc:1173:    ldout(cct, 3) << "handle_osd_map got epochs ["
./osdc/Objecter.cc:1186:	  ldout(cct, 3) << "handle_osd_map decoding incremental epoch " << e
./osdc/Objecter.cc:1196:	  ldout(cct, 3) << "handle_osd_map decoding full epoch " << e << dendl;
./osdc/Objecter.cc:1208:	    ldout(cct, 3) << "handle_osd_map requesting missing epoch "
./osdc/Objecter.cc:1213:	  ldout(cct, 3) << "handle_osd_map missing epoch "
./osdc/Objecter.cc:1265:	ldout(cct, 3) << "handle_osd_map decoding full epoch "
./osdc/Objecter.cc:1273:	ldout(cct, 3) << "handle_osd_map hmm, i want a full map, requesting"
./osdc/Objecter.cc:1285:      ldout(cct, 10) << __func__ << "  checking op " << p->first << dendl;
./osdc/Objecter.cc:1540:    ldout(cct, 10) << "check_op_pool_dne tid " << op->tid
./osdc/Objecter.cc:1544:    ldout(cct, 10) << "check_op_pool_dne tid " << op->tid
./osdc/Objecter.cc:1552:      ldout(cct, 10) << "check_op_pool_dne tid " << op->tid
./osdc/Objecter.cc:1645:    ldout(cct, 10) << "_check_linger_pool_dne linger_id " << op->linger_id
./osdc/Objecter.cc:1650:    ldout(cct, 10) << "_check_linger_pool_dne linger_id " << op->linger_id
./osdc/Objecter.cc:1732:  ldout(cct, 10) << "_check_command_map_dne tid " << c->tid
./osdc/Objecter.cc:1785:    ldout(cct, 20) << __func__ << " osd=" << osd << " returning homeless"
./osdc/Objecter.cc:1795:    ldout(cct, 20) << __func__ << " s=" << s << " osd=" << osd << " "
./osdc/Objecter.cc:1810:  ldout(cct, 20) << __func__ << " s=" << s << " osd=" << osd << " "
./osdc/Objecter.cc:1818:    ldout(cct, 20) << __func__ << " s=" << s << " osd=" << s->osd << " "
./osdc/Objecter.cc:1829:    ldout(cct, 20) << __func__ << " s=" << s << " osd=" << s->osd << " "
./osdc/Objecter.cc:1840:  ldout(cct, 10) << "reopen_session osd." << s->osd << " session, addr now "
./osdc/Objecter.cc:1857:  ldout(cct, 10) << "close_session for osd." << s->osd << dendl;
./osdc/Objecter.cc:1871:    ldout(cct, 10) << " linger_op " << i->first << dendl;
./osdc/Objecter.cc:1878:    ldout(cct, 10) << " op " << i->first << dendl;
./osdc/Objecter.cc:1885:    ldout(cct, 10) << " command_op " << i->first << dendl;
./osdc/Objecter.cc:1955:  ldout(cct, 10) << __func__ << dendl;
./osdc/Objecter.cc:1971:  ldout(cct, 10) << __func__ << " latest " << newest << ", have it" << dendl;
./osdc/Objecter.cc:1977:  ldout(cct, 10) << __func__ << " latest " << newest << ", waiting" << dendl;
./osdc/Objecter.cc:1994:    ldout(cct, 10) << "_maybe_request_map subscribing (continuous) to next "
./osdc/Objecter.cc:1997:    ldout(cct, 10)
./osdc/Objecter.cc:2126:  ldout(cct, 10) << "tick" << dendl;
./osdc/Objecter.cc:2133:    ldout(cct, 10) << __func__ << " raced with shutdown" << dendl;
./osdc/Objecter.cc:2157:	ldout(cct, 2) << " tid " << p->first << " on osd." << op->session->osd
./osdc/Objecter.cc:2169:      ldout(cct, 10) << " pinging osd that serves lingering tid " << p->first
./osdc/Objecter.cc:2180:      ldout(cct, 10) << " pinging osd that serves command tid " << p->first
./osdc/Objecter.cc:2215:  ldout(cct, 10) << "resend_mon_ops" << dendl;
./osdc/Objecter.cc:2315:    ldout(cct, 20) << " note: not requesting reply" << dendl;
./osdc/Objecter.cc:2384:  ldout(cct, 10) << __func__ << " op " << op << dendl;
./osdc/Objecter.cc:2405:      ldout(cct, 10) << __func__ << " relock raced with osdmap, recalc target"
./osdc/Objecter.cc:2436:    ldout(cct, 10) << " barrier, paused " << op << " tid " << op->tid
./osdc/Objecter.cc:2442:    ldout(cct, 10) << " paused modify " << op << " tid " << op->tid
./osdc/Objecter.cc:2448:    ldout(cct, 10) << " paused read " << op << " tid " << op->tid
./osdc/Objecter.cc:2455:    ldout(cct, 0) << " FULL, paused modify " << op << " tid "
./osdc/Objecter.cc:2469:  ldout(cct, 10) << "_op_submit oid " << op->target.base_oid
./osdc/Objecter.cc:2494:  ldout(cct, 5) << num_in_flight << " in flight" << dendl;
./osdc/Objecter.cc:2505:    ldout(cct, 10) << __func__ << " tid " << tid << " dne in session "
./osdc/Objecter.cc:2511:    ldout(cct, 20) << " revoking rx buffer for " << tid
./osdc/Objecter.cc:2516:  ldout(cct, 10) << __func__ << " tid " << tid << " in session " << s->osd
./osdc/Objecter.cc:2544:  ldout(cct,10) << __func__ << " " << tids << dendl;
./osdc/Objecter.cc:2555:  ldout(cct, 5) << __func__ << ": cancelling tid " << tid << " r=" << r
./osdc/Objecter.cc:2575:  ldout(cct, 5) << __func__ << ": tid " << tid
./osdc/Objecter.cc:2593:  ldout(cct, 5) << __func__ << ": tid " << tid
./osdc/Objecter.cc:2699:    ldout(cct, 4) << __func__ << ": DNE pool " << pool_id << dendl;
./osdc/Objecter.cc:2787:      ldout(cct,10) << __func__ << " op " << op->tid << " snapc " << op->snapc
./osdc/Objecter.cc:2799:  ldout(cct,20) << __func__ << " epoch " << t->epoch
./osdc/Objecter.cc:2812:  ldout(cct,30) << __func__ << "  base pi " << pi
./osdc/Objecter.cc:2854:  ldout(cct,20) << __func__ << " target " << t->target_oid << " "
./osdc/Objecter.cc:2856:  ldout(cct,30) << __func__ << "  target pi " << pi
./osdc/Objecter.cc:2925:    ldout(cct, 10) << __func__ << " "
./osdc/Objecter.cc:2940:	ldout(cct, 10) << " chose random osd." << osd << " of " << acting
./osdc/Objecter.cc:2951:	  ldout(cct, 20) << __func__ << " localize: rank " << i
./osdc/Objecter.cc:3002:  ldout(cct, 15) << __func__ << " " << to->osd << " " << op->tid << dendl;
./osdc/Objecter.cc:3018:  ldout(cct, 15) << __func__ << " " << from->osd << " " << op->tid << dendl;
./osdc/Objecter.cc:3034:  ldout(cct, 15) << __func__ << " " << to->osd << " " << op->linger_id
./osdc/Objecter.cc:3051:  ldout(cct, 15) << __func__ << " " << from->osd << " " << op->linger_id
./osdc/Objecter.cc:3068:  ldout(cct, 15) << __func__ << " " << from->osd << " " << op->tid << dendl;
./osdc/Objecter.cc:3085:  ldout(cct, 15) << __func__ << " " << to->osd << " " << op->tid << dendl;
./osdc/Objecter.cc:3095:    ldout(cct, 10) << "recalc_linger_op_target tid " << linger_op->linger_id
./osdc/Objecter.cc:3121:  ldout(cct, 15) << "cancel_op " << op->tid << dendl;
./osdc/Objecter.cc:3134:  ldout(cct, 15) << "finish_op " << op->tid << dendl;
./osdc/Objecter.cc:3161:  ldout(cct, 15) << "finish_op " << tid << dendl;
./osdc/Objecter.cc:3246:      ldout(cct, 20) << __func__ << " ? " << q->first << " [" << q->second.begin
./osdc/Objecter.cc:3250:	ldout(cct, 10) << __func__ << " backoff " << op->target.actual_pgid
./osdc/Objecter.cc:3262:    ldout(cct, 10) << __func__ << " " << op->tid << " pgid change from "
./osdc/Objecter.cc:3269:  ldout(cct, 15) << "_send_op " << op->tid << " to "
./osdc/Objecter.cc:3278:    ldout(cct, 20) << " revoking rx buffer for " << op->tid << " on "
./osdc/Objecter.cc:3285:    ldout(cct, 20) << " posting rx buffer for " << op->tid << " on " << con
./osdc/Objecter.cc:3354:  ldout(cct, 10) << "in handle_osd_op_reply" << dendl;
./osdc/Objecter.cc:3368:    ldout(cct, 7) << __func__ << " no session on con " << con << dendl;
./osdc/Objecter.cc:3380:    ldout(cct, 7) << "handle_osd_op_reply " << tid
./osdc/Objecter.cc:3390:  ldout(cct, 7) << "handle_osd_op_reply " << tid
./osdc/Objecter.cc:3402:    ldout(cct, 7) << "retrying write after first reply: " << tid << dendl;
./osdc/Objecter.cc:3417:      ldout(cct, 7) << " ignoring reply from attempt "
./osdc/Objecter.cc:3438:    ldout(cct, 5) << " got redirect reply; redirecting" << dendl;
./osdc/Objecter.cc:3457:    ldout(cct, 7) << " got -EAGAIN, resubmitting" << dendl;
./osdc/Objecter.cc:3495:    ldout(cct, 0) << "WARNING: tid " << op->tid << " reply ops " << out_ops
./osdc/Objecter.cc:3508:    ldout(cct, 10) << " op " << i << " rval " << p->rval
./osdc/Objecter.cc:3517:      ldout(cct, 10) << " op " << i << " handler " << *ph << dendl;
./osdc/Objecter.cc:3536:  ldout(cct, 15) << "handle_osd_op_reply completed tid " << tid << dendl;
./osdc/Objecter.cc:3539:  ldout(cct, 5) << num_in_flight << " in flight" << dendl;
./osdc/Objecter.cc:3561:  ldout(cct, 10) << __func__ << " " << *m << dendl;
./osdc/Objecter.cc:3571:    ldout(cct, 7) << __func__ << " no session on con " << con << dendl;
./osdc/Objecter.cc:3619:	ldout(cct, 10) << __func__ << " unblock backoff " << b->pgid
./osdc/Objecter.cc:3635:	    ldout(cct, 20) << __func__ <<  " contained_by " << r << " on "
./osdc/Objecter.cc:3651:    ldout(cct, 10) << __func__ << " unrecognized op " << (int)m->op << dendl;
./osdc/Objecter.cc:3667:  ldout(cct, 10) << __func__ << " " << list_context
./osdc/Objecter.cc:3679:  ldout(cct, 10) << "list_nobjects_seek " << list_context << dendl;
./osdc/Objecter.cc:3704:  ldout(cct, 10) << __func__ << " pool_id " << list_context->pool_id
./osdc/Objecter.cc:3733:    ldout(cct, 10) << " hobject sort order changed, restarting this pg at "
./osdc/Objecter.cc:3739:      ldout(cct, 10) << " pg_num changed; restarting with " << pg_num << dendl;
./osdc/Objecter.cc:3746:    ldout(cct, 20) << __func__ << " end of pool, list "
./osdc/Objecter.cc:3777:  ldout(cct, 10) << __func__ << " " << list_context << dendl;
./osdc/Objecter.cc:3807:  ldout(cct, 20) << " response.entries.size " << response_size
./osdc/Objecter.cc:3817:    ldout(cct, 20) << " hit max, returning results so far, "
./osdc/Objecter.cc:3833:    ldout(cct, 10) << " release listing context's budget " <<
./osdc/Objecter.cc:3846:  ldout(cct, 10) << "create_pool_snap; pool: " << pool << "; snap: "
./osdc/Objecter.cc:3892:  ldout(cct, 10) << "allocate_selfmanaged_snap; pool: " << pool << dendl;
./osdc/Objecter.cc:3911:  ldout(cct, 10) << "delete_pool_snap; pool: " << pool << "; snap: "
./osdc/Objecter.cc:3939:  ldout(cct, 10) << "delete_selfmanaged_snap; pool: " << pool << "; snap: "
./osdc/Objecter.cc:3959:  ldout(cct, 10) << "create_pool name=" << name << dendl;
./osdc/Objecter.cc:3984:  ldout(cct, 10) << "delete_pool " << pool << dendl;
./osdc/Objecter.cc:3996:  ldout(cct, 10) << "delete_pool " << pool_name << dendl;
./osdc/Objecter.cc:4027:  ldout(cct, 10) << "change_pool_auid " << pool << " to " << auid << dendl;
./osdc/Objecter.cc:4059:  ldout(cct, 10) << "pool_op_submit " << op->tid << dendl;
./osdc/Objecter.cc:4088:  ldout(cct, 10) << "handle_pool_op_reply " << *m << dendl;
./osdc/Objecter.cc:4093:    ldout(cct, 10) << "have request " << tid << " at " << op << " Op: "
./osdc/Objecter.cc:4108:	ldout(cct, 20) << "waiting for client to reach epoch " << m->epoch
./osdc/Objecter.cc:4132:    ldout(cct, 10) << "unknown request " << tid << dendl;
./osdc/Objecter.cc:4139:  ldout(cct, 10) << "done" << dendl;
./osdc/Objecter.cc:4151:    ldout(cct, 10) << __func__ << " tid " << tid << " dne" << dendl;
./osdc/Objecter.cc:4155:  ldout(cct, 10) << __func__ << " tid " << tid << dendl;
./osdc/Objecter.cc:4184:  ldout(cct, 10) << "get_pool_stats " << pools << dendl;
./osdc/Objecter.cc:4211:  ldout(cct, 10) << "_poolstat_submit " << op->tid << dendl;
./osdc/Objecter.cc:4222:  ldout(cct, 10) << "handle_get_pool_stats_reply " << *m << dendl;
./osdc/Objecter.cc:4234:    ldout(cct, 10) << "have request " << tid << " at " << op << dendl;
./osdc/Objecter.cc:4242:    ldout(cct, 10) << "unknown request " << tid << dendl;
./osdc/Objecter.cc:4244:  ldout(cct, 10) << "done" << dendl;
./osdc/Objecter.cc:4256:    ldout(cct, 10) << __func__ << " tid " << tid << " dne" << dendl;
./osdc/Objecter.cc:4260:  ldout(cct, 10) << __func__ << " tid " << tid << dendl;
./osdc/Objecter.cc:4286:  ldout(cct, 10) << "get_fs_stats" << dendl;
./osdc/Objecter.cc:4313:  ldout(cct, 10) << "fs_stats_submit" << op->tid << dendl;
./osdc/Objecter.cc:4330:  ldout(cct, 10) << "handle_fs_stats_reply " << *m << dendl;
./osdc/Objecter.cc:4335:    ldout(cct, 10) << "have request " << tid << " at " << op << dendl;
./osdc/Objecter.cc:4342:    ldout(cct, 10) << "unknown request " << tid << dendl;
./osdc/Objecter.cc:4345:  ldout(cct, 10) << "done" << dendl;
./osdc/Objecter.cc:4356:    ldout(cct, 10) << __func__ << " tid " << tid << " dne" << dendl;
./osdc/Objecter.cc:4360:  ldout(cct, 10) << __func__ << " tid " << tid << dendl;
./osdc/Objecter.cc:4389:  ldout(cct, 15) << "_sg_read_finish" << dendl;
./osdc/Objecter.cc:4402:    ldout(cct, 15) << "  only one frag" << dendl;
./osdc/Objecter.cc:4408:  ldout(cct, 7) << "_sg_read_finish " << bytes_read << " bytes" << dendl;
./osdc/Objecter.cc:4418:  ldout(cct, 10) << "ms_handle_connect " << con << dendl;
./osdc/Objecter.cc:4433:      ldout(cct, 1) << "ms_handle_reset " << con << " session " << session
./osdc/Objecter.cc:4469:      ldout(cct, 1) << "ms_handle_refused on osd." << osd << dendl;
./osdc/Objecter.cc:4506:    ldout(cct, 20) << op->tid << "\t" << op->target.pgid
./osdc/Objecter.cc:4515:  ldout(cct, 20) << "dump_active .. " << num_homeless_ops << " homeless"
./osdc/Objecter.cc:4736:  ldout(cct, 10) << "blacklist_self " << (set ? "add" : "rm") << dendl;
./osdc/Objecter.cc:4767:    ldout(cct, 7) << __func__ << " no session on con " << con << dendl;
./osdc/Objecter.cc:4777:    ldout(cct, 10) << "handle_command_reply tid " << m->get_tid()
./osdc/Objecter.cc:4788:    ldout(cct, 10) << "handle_command_reply tid " << m->get_tid()
./osdc/Objecter.cc:4816:  ldout(cct, 10) << "_submit_command " << tid << " " << c->cmd << dendl;
./osdc/Objecter.cc:4894:  ldout(cct, 20) << "_recalc_command_target " << c->tid << " no change, "
./osdc/Objecter.cc:4925:  ldout(cct, 10) << "_send_command " << c->tid << dendl;
./osdc/Objecter.cc:4944:    ldout(cct, 10) << __func__ << " tid " << tid << " dne" << dendl;
./osdc/Objecter.cc:4948:  ldout(cct, 10) << __func__ << " tid " << tid << dendl;
./osdc/Objecter.cc:4963:  ldout(cct, 10) << "_finish_command " << c->tid << " = " << r << " "
./osdc/Objecter.cc:5022:  ldout(cct, 7) << __func__ << ": barrier " << epoch << " (was "
./osdc/Objecter.cc:5119:  ldout(cct, 20) << __func__ << ": start=" << start << " end=" << end << dendl;
./osdc/Objecter.cc:5150:    ldout(cct, 4) << __func__ << ": remote error " << r << dendl;
./osdc/Objecter.cc:5168:  ldout(cct, 10) << __func__ << ": got " << response.entries.size()
./osdc/Objecter.cc:5171:  ldout(cct, 20) << __func__ << ": response.entries.size "
./osdc/Objecter.cc:5177:    ldout(cct, 10) << __func__ << ": adjusted next down to end " << end
./osdc/Objecter.cc:5204:      ldout(cct, 20) << __func__ << " dropping item " << last
./osdc/ObjectCacher.cc:98:  ldout(oc->cct, 20) << "split " << *left << " at " << off << dendl;
./osdc/ObjectCacher.cc:143:      ldout(oc->cct, 20) << "split  moving waiters at byte " << p->first
./osdc/ObjectCacher.cc:151:  ldout(oc->cct, 20) << "split    left is " << *left << dendl;
./osdc/ObjectCacher.cc:152:  ldout(oc->cct, 20) << "split   right is " << *right << dendl;
./osdc/ObjectCacher.cc:161:  ldout(oc->cct, 10) << "merge_left " << *left << " + " << *right << dendl;
./osdc/ObjectCacher.cc:193:  ldout(oc->cct, 10) << "merge_left result " << *left << dendl;
./osdc/ObjectCacher.cc:210:  ldout(oc->cct, 10) << "try_merge_bh " << *bh << dendl;
./osdc/ObjectCacher.cc:290:  ldout(oc->cct, 10) << "map_read " << ex.oid << " "
./osdc/ObjectCacher.cc:308:        ldout(oc->cct, 20) << "map_read miss+complete+zero " << left << " left, " << *n << dendl;
./osdc/ObjectCacher.cc:311:        ldout(oc->cct, 20) << "map_read miss " << left << " left, " << *n << dendl;
./osdc/ObjectCacher.cc:327:        ldout(oc->cct, 20) << "map_read hit " << *e << dendl;
./osdc/ObjectCacher.cc:330:        ldout(oc->cct, 20) << "map_read rx " << *e << dendl;
./osdc/ObjectCacher.cc:333:        ldout(oc->cct, 20) << "map_read error " << *e << dendl;
./osdc/ObjectCacher.cc:355:        ldout(oc->cct, 20) << "map_read gap+complete+zero " << *n << dendl;
./osdc/ObjectCacher.cc:358:        ldout(oc->cct, 20) << "map_read gap " << *n << dendl;
./osdc/ObjectCacher.cc:416:  ldout(oc->cct, 10) << "map_write oex " << ex.oid
./osdc/ObjectCacher.cc:434:        ldout(oc->cct, 10) << "map_write adding trailing bh " << *final << dendl;
./osdc/ObjectCacher.cc:445:    ldout(oc->cct, 10) << "cur is " << cur << ", p is " << *p->second << dendl;
./osdc/ObjectCacher.cc:450:      ldout(oc->cct, 10) << "map_write bh " << *bh << " intersected" << dendl;
./osdc/ObjectCacher.cc:499:      ldout(oc->cct, 10) << "map_write gap " << cur << "~" << glen << dendl;
./osdc/ObjectCacher.cc:521:  ldout(oc->cct, 10) << "map_write final is " << *final << dendl;
./osdc/ObjectCacher.cc:542:  ldout(oc->cct, 10) << "truncate " << *this << " to " << s << dendl;
./osdc/ObjectCacher.cc:568:  ldout(oc->cct, 10) << "discard " << *this << " " << off << "~" << len
./osdc/ObjectCacher.cc:572:    ldout(oc->cct, 10) << " setting exists on " << *this << dendl;
./osdc/ObjectCacher.cc:576:    ldout(oc->cct, 10) << " clearing complete on " << *this << dendl;
./osdc/ObjectCacher.cc:599:    ldout(oc->cct, 10) << "discard " << *this << " bh " << *bh << dendl;
./osdc/ObjectCacher.cc:747:  ldout(cct, 10) << "close_object " << *ob << dendl;
./osdc/ObjectCacher.cc:761:  ldout(cct, 7) << "bh_read on " << *bh << " outstanding reads "
./osdc/ObjectCacher.cc:793:  ldout(cct, 7) << "bh_read_finish "
./osdc/ObjectCacher.cc:803:    ldout(cct, 7) << "bh_read_finish " << oid << " padding " << start << "~"
./osdc/ObjectCacher.cc:813:    ldout(cct, 7) << "bh_read_finish no object cache" << dendl;
./osdc/ObjectCacher.cc:841:	ldout(cct, 7)
./osdc/ObjectCacher.cc:860:	  ldout(cct, 10)
./osdc/ObjectCacher.cc:882:	ldout(cct, 20) << "break due to opos " << opos << " >= start+length "
./osdc/ObjectCacher.cc:889:      ldout(cct, 20) << "checking bh " << *bh << dendl;
./osdc/ObjectCacher.cc:900:	ldout(cct, 1) << "bh_read_finish skipping gap "
./osdc/ObjectCacher.cc:908:	ldout(cct, 10) << "bh_read_finish skipping non-rx " << *bh << dendl;
./osdc/ObjectCacher.cc:914:	ldout(cct, 10) << "bh_read_finish bh->last_read_tid "
./osdc/ObjectCacher.cc:932:	  ldout(cct, 10) << "bh_read_finish removing " << *bh << dendl;
./osdc/ObjectCacher.cc:936:	  ldout(cct, 10) << "skipping unstrusted -ENOENT and will retry for "
./osdc/ObjectCacher.cc:952:      ldout(cct, 10) << "bh_read_finish read " << *bh << dendl;
./osdc/ObjectCacher.cc:959:  ldout(cct, 20) << "finishing waiters " << ls << dendl;
./osdc/ObjectCacher.cc:1056:    ldout(cct, 7) << "bh_write_scattered " << *bh << dendl;
./osdc/ObjectCacher.cc:1094:  ldout(cct, 7) << "bh_write " << *bh << dendl;
./osdc/ObjectCacher.cc:1117:  ldout(cct, 20) << " tid " << tid << " on " << bh->ob->get_oid() << dendl;
./osdc/ObjectCacher.cc:1136:  ldout(cct, 7) << "bh_write_commit " << oid << " tid " << tid
./osdc/ObjectCacher.cc:1140:    ldout(cct, 7) << "bh_write_commit no object cache" << dendl;
./osdc/ObjectCacher.cc:1153:      ldout(cct, 10) << "bh_write_commit marking exists on " << *ob << dendl;
./osdc/ObjectCacher.cc:1158:	ldout(cct, 10) << "bh_write_commit may copy on write, clearing "
./osdc/ObjectCacher.cc:1176:	ldout(cct, 10) << "bh_write_commit skipping non-tx " << *bh << dendl;
./osdc/ObjectCacher.cc:1183:	ldout(cct, 10) << "bh_write_commit newer tid on " << *bh << dendl;
./osdc/ObjectCacher.cc:1198:	ldout(cct, 10) << "bh_write_commit clean " << *bh << dendl;
./osdc/ObjectCacher.cc:1201:	ldout(cct, 10) << "bh_write_commit marking dirty again due to error "
./osdc/ObjectCacher.cc:1245:  ldout(cct, 10) << "flush " << amount << dendl;
./osdc/ObjectCacher.cc:1273:  ldout(cct, 10) << "trim  start: bytes: max " << max_size << "  clean "
./osdc/ObjectCacher.cc:1286:    ldout(cct, 10) << "trim trimming " << *bh << dendl;
./osdc/ObjectCacher.cc:1296:      ldout(cct, 10) << "trim clearing complete on " << *ob << dendl;
./osdc/ObjectCacher.cc:1306:    ldout(cct, 10) << "trim trimming " << *ob << dendl;
./osdc/ObjectCacher.cc:1310:  ldout(cct, 10) << "trim finish:  max " << max_size << "  clean "
./osdc/ObjectCacher.cc:1326:    ldout(cct, 10) << "is_cached " << *ex_it << dendl;
./osdc/ObjectCacher.cc:1385:    ldout(cct, 10) << "readx " << *ex_it << dendl;
./osdc/ObjectCacher.cc:1398:      ldout(cct, 10) << "readx  object !exists, 1 extent..." << dendl;
./osdc/ObjectCacher.cc:1403:	ldout(cct, 20) << "readx  may copy on write" << dendl;
./osdc/ObjectCacher.cc:1411:	    ldout(cct, 10) << "readx  flushing " << *bh << dendl;
./osdc/ObjectCacher.cc:1424:	  ldout(cct, 10) << "readx  waiting on tid " << o->last_write_tid
./osdc/ObjectCacher.cc:1438:	ldout(cct, 20) << "readx  ob has bh " << *bh_it->second << dendl;
./osdc/ObjectCacher.cc:1445:	ldout(cct, 10) << "readx  ob has all zero|rx, returning ENOENT"
./osdc/ObjectCacher.cc:1480:	    ldout(cct, 10) << "readx missed, waiting on cache to complete "
./osdc/ObjectCacher.cc:1501:	ldout(cct, 10) << "readx missed, waiting on " << *last->second
./osdc/ObjectCacher.cc:1514:	  ldout(cct, 10) << "readx missed, waiting on " << *bh_it->second
./osdc/ObjectCacher.cc:1536:	ldout(cct, 10) << "readx hit bh " << *bh << dendl;
./osdc/ObjectCacher.cc:1573:	  ldout(cct, 10) << "readx rmap opos " << opos << ": " << *bh << " +"
./osdc/ObjectCacher.cc:1621:      ldout(cct, 20) << "readx defer " << rd << dendl;
./osdc/ObjectCacher.cc:1623:      ldout(cct, 20) << "readx drop " << rd << " (no complete, but no waiter)"
./osdc/ObjectCacher.cc:1636:  ldout(cct, 10) << "readx has all buffers" << dendl;
./osdc/ObjectCacher.cc:1646:      ldout(cct, 10) << "readx  adding buffer len " << i->second.length()
./osdc/ObjectCacher.cc:1652:    ldout(cct, 10) << "readx  result is " << rd->bl->length() << dendl;
./osdc/ObjectCacher.cc:1654:    ldout(cct, 10) << "readx  no bufferlist ptr (readahead?), done." << dendl;
./osdc/ObjectCacher.cc:1661:  ldout(cct, 20) << "readx done " << rd << " " << ret << dendl;
./osdc/ObjectCacher.cc:1728:      ldout(cct, 10) << "writex writing " << f_it->first << "~"
./osdc/ObjectCacher.cc:1821:    ldout(cct, 10) << __func__ << " waiting for dirty|tx "
./osdc/ObjectCacher.cc:1832:    ldout(cct, 10) << __func__ << " woke up" << dendl;
./osdc/ObjectCacher.cc:1871:    ldout(cct, 10) << "wait_for_write waiting on write-thru of " << len
./osdc/ObjectCacher.cc:1876:      ldout(cct, 10) << "wait_for_write woke up, ret " << ret << dendl;
./osdc/ObjectCacher.cc:1884:    ldout(cct, 10) << "wait_for_write " << get_stat_dirty() << " > target "
./osdc/ObjectCacher.cc:1893:  ldout(cct, 10) << "flusher start" << dendl;
./osdc/ObjectCacher.cc:1898:    ldout(cct, 11) << "flusher "
./osdc/ObjectCacher.cc:1917:      ldout(cct, 10) << "flusher " << get_stat_dirty() << " dirty + "
./osdc/ObjectCacher.cc:1931:	ldout(cct, 10) << "flusher flushing aged dirty bh " << *bh << dendl;
./osdc/ObjectCacher.cc:1962:    ldout(cct, 10) << "Waiting for all reads to complete. Number left: "
./osdc/ObjectCacher.cc:1968:  ldout(cct, 10) << "flusher finish" << dendl;
./osdc/ObjectCacher.cc:2035:  ldout(cct, 10) << "purge " << *ob << dendl;
./osdc/ObjectCacher.cc:2052:  ldout(cct, 10) << "flush " << *ob << " " << offset << "~" << length << dendl;
./osdc/ObjectCacher.cc:2057:    ldout(cct, 20) << "flush  " << *bh << dendl;
./osdc/ObjectCacher.cc:2091:  ldout(cct, 10) << "flush_set has no dirty|tx bhs" << dendl;
./osdc/ObjectCacher.cc:2103:    ldout(cct, 10) << "flush_set on " << oset << " dne" << dendl;
./osdc/ObjectCacher.cc:2108:  ldout(cct, 10) << "flush_set " << oset << dendl;
./osdc/ObjectCacher.cc:2190:    ldout(cct, 10) << "flush_set " << oset << " will wait for ack tid "
./osdc/ObjectCacher.cc:2207:    ldout(cct, 10) << "flush_set on " << oset << " dne" << dendl;
./osdc/ObjectCacher.cc:2212:  ldout(cct, 10) << "flush_set " << oset << " on " << exv.size()
./osdc/ObjectCacher.cc:2227:    ldout(cct, 20) << "flush_set " << oset << " ex " << ex << " ob " << soid
./osdc/ObjectCacher.cc:2232:      ldout(cct, 10) << "flush_set " << oset << " will wait for ack tid "
./osdc/ObjectCacher.cc:2248:  ldout(cct, 10) << "flush_all " << dendl;
./osdc/ObjectCacher.cc:2290:    ldout(cct, 10) << "flush_all will wait for ack tid "
./osdc/ObjectCacher.cc:2302:    ldout(cct, 10) << "purge_set on " << oset << " dne" << dendl;
./osdc/ObjectCacher.cc:2306:  ldout(cct, 10) << "purge_set " << oset << dendl;
./osdc/ObjectCacher.cc:2348:    ldout(cct, 10) << "release trimming " << *ob << dendl;
./osdc/ObjectCacher.cc:2355:    ldout(cct, 10) << "release clearing complete on " << *ob << dendl;
./osdc/ObjectCacher.cc:2359:    ldout(cct, 10) << "release setting exists on " << *ob << dendl;
./osdc/ObjectCacher.cc:2373:    ldout(cct, 10) << "release_set on " << oset << " dne" << dendl;
./osdc/ObjectCacher.cc:2377:  ldout(cct, 10) << "release_set " << oset << dendl;
./osdc/ObjectCacher.cc:2390:      ldout(cct, 10) << "release_set " << oset << " " << *ob
./osdc/ObjectCacher.cc:2397:    ldout(cct, 10) << "release_set " << oset
./osdc/ObjectCacher.cc:2408:  ldout(cct, 10) << "release_all" << dendl;
./osdc/ObjectCacher.cc:2425:	ldout(cct, 10) << "release_all " << *ob
./osdc/ObjectCacher.cc:2434:    ldout(cct, 10) << "release_all unclean " << unclean << " bytes left"
./osdc/ObjectCacher.cc:2444:  ldout(cct, 10) << "clear_nonexistence() " << oset << dendl;
./osdc/ObjectCacher.cc:2450:      ldout(cct, 10) << " setting exists and complete on " << *ob << dendl;
./osdc/ObjectCacher.cc:2506:    ldout(cct, 10) << __func__ << " on " << oset << " dne" << dendl;
./osdc/ObjectCacher.cc:2510:  ldout(cct, 10) << __func__ << " " << oset << dendl;
./osdc/ObjectCacher.cc:2513:    ldout(cct, 10) << __func__ << " " << oset << " ex " << ex << dendl;
./osdc/ObjectCacher.cc:2542:  ldout(cct, 10) << "verify_stats" << dendl;
./osdc/ObjectCacher.cc:2588:  ldout(cct, 10) << " clean " << clean << " rx " << rx << " tx " << tx
./osdc/ObjectCacher.cc:2712:  ldout(cct, 30) << "bh_add " << *ob << " " << *bh << dendl;
./osdc/ObjectCacher.cc:2734:  ldout(cct, 30) << "bh_remove " << *ob << " " << *bh << dendl;
./crush/CrushWrapper.cc:355:    ldout(cct, 5) << "_maybe_remove_last_instance removing bucket " << item << dendl;
./crush/CrushWrapper.cc:362:    ldout(cct, 5) << "_maybe_remove_last_instance removing name for item " << item << dendl;
./crush/CrushWrapper.cc:407:  ldout(cct, 5) << "remove_item " << item
./crush/CrushWrapper.cc:415:      ldout(cct, 1) << "remove_item bucket " << item << " does not exist"
./crush/CrushWrapper.cc:421:      ldout(cct, 1) << "remove_item bucket " << item << " has " << t->size
./crush/CrushWrapper.cc:438:	ldout(cct, 5) << "remove_item removing item " << item
./crush/CrushWrapper.cc:501:  ldout(cct, 5) << "_remove_item_under " << item << " under " << ancestor
./crush/CrushWrapper.cc:517:      ldout(cct, 5) << "_remove_item_under removing item " << item
./crush/CrushWrapper.cc:540:  ldout(cct, 5) << "remove_item_under " << item << " under " << ancestor
./crush/CrushWrapper.cc:554:      ldout(cct, 1) << "remove_item_under bucket " << item
./crush/CrushWrapper.cc:560:      ldout(cct, 1) << "remove_item_under bucket " << item << " has " << t->size
./crush/CrushWrapper.cc:575:  ldout(cct, 5) << __func__ << " " << id << " " << loc << dendl;
./crush/CrushWrapper.cc:579:  ldout(cct, 20) << " id is at " << id_loc << dendl;
./crush/CrushWrapper.cc:640:  ldout(cct, 5) << "check_item_loc item " << item << " loc " << loc << dendl;
./crush/CrushWrapper.cc:650:      ldout(cct, 2) << "warning: did not specify location for '" << p->second << "' level (levels are "
./crush/CrushWrapper.cc:656:      ldout(cct, 5) << "check_item_loc bucket " << q->second << " dne" << dendl;
./crush/CrushWrapper.cc:662:      ldout(cct, 5) << "check_item_loc requested " << q->second << " for type " << p->second
./crush/CrushWrapper.cc:673:	ldout(cct, 2) << "check_item_loc " << item << " exists in bucket " << b->id << dendl;
./crush/CrushWrapper.cc:682:  ldout(cct, 2) << __func__ << " item " << item << " loc " << loc << dendl;
./crush/CrushWrapper.cc:908:  ldout(cct, 5) << "insert_item item " << item << " weight " << weight
./crush/CrushWrapper.cc:924:      ldout(cct, 10) << "device name '" << name << "' already exists as id "
./crush/CrushWrapper.cc:945:      ldout(cct, 2) << "warning: did not specify location for '"
./crush/CrushWrapper.cc:952:      ldout(cct, 5) << "insert_item creating bucket " << q->second << dendl;
./crush/CrushWrapper.cc:957:        ldout(cct, 1) << "add_bucket failure error: " << cpp_strerror(r)
./crush/CrushWrapper.cc:970:      ldout(cct, 1) << "insert_item doesn't have bucket " << id << dendl;
./crush/CrushWrapper.cc:976:      ldout(cct, 1) << "insert_item item " << cur << " already exists beneath "
./crush/CrushWrapper.cc:985:      ldout(cct, 1) << "insert_item existing bucket has type "
./crush/CrushWrapper.cc:993:      ldout(cct, 1) << "insert_item " << cur << " already contains " << b->id
./crush/CrushWrapper.cc:998:    ldout(cct, 5) << "insert_item adding " << cur << " weight " << weight
./crush/CrushWrapper.cc:1009:      ldout(cct, 5) << "insert_item max_devices now " << crush->max_devices
./crush/CrushWrapper.cc:1014:      ldout(cct, 0) << __func__ << " unable to rebuild roots with classes: "
./crush/CrushWrapper.cc:1021:  ldout(cct, 1) << "error: didn't find anywhere to add item " << item
./crush/CrushWrapper.cc:1191:    ldout(cct, 5) << "create_or_move_item " << item << " already at " << loc
./crush/CrushWrapper.cc:1196:      ldout(cct, 10) << "create_or_move_item " << item
./crush/CrushWrapper.cc:1200:    ldout(cct, 5) << "create_or_move_item adding " << item
./crush/CrushWrapper.cc:1214:  ldout(cct, 5) << "update_item item " << item << " weight " << weight
./crush/CrushWrapper.cc:1233:    ldout(cct, 5) << "update_item " << item << " already at " << loc << dendl;
./crush/CrushWrapper.cc:1235:      ldout(cct, 5) << "update_item " << item << " adjusting weight "
./crush/CrushWrapper.cc:1242:      ldout(cct, 5) << "update_item setting " << item << " name to " << name
./crush/CrushWrapper.cc:1251:    ldout(cct, 5) << "update_item adding " << item << " weight " << weight
./crush/CrushWrapper.cc:1294:  ldout(cct, 5) << "adjust_item_weight " << id << " weight " << weight << dendl;
./crush/CrushWrapper.cc:1303:	ldout(cct, 5) << "adjust_item_weight " << id << " diff " << diff
./crush/CrushWrapper.cc:1317:  ldout(cct, 5) << "adjust_item_weight_in_loc " << id << " weight " << weight
./crush/CrushWrapper.cc:1329:	ldout(cct, 5) << "adjust_item_weight_in_loc " << id << " diff " << diff
./crush/CrushWrapper.cc:1343:  ldout(cct, 5) << __func__ << " " << id << " weight " << weight << dendl;
./crush/CrushWrapper.cc:1578:    ldout(cct, 5) << "reweight bucket " << *p << dendl;
./crush/CrushWrapper.cc:3133:      ldout(cct, 1) << "loc["
./crush/CrushWrapper.cc:3156:  ldout(cct, 10) << __func__ << " stack " << stack
./crush/CrushWrapper.cc:3168:  ldout(cct, 10) << __func__ << " cumulative_fanout " << cumulative_fanout
./crush/CrushWrapper.cc:3187:      ldout(cct, 10) << __func__ << " underfull " << osd << " type " << type
./crush/CrushWrapper.cc:3192:  ldout(cct, 20) << __func__ << " underfull_buckets " << underfull_buckets << dendl;
./crush/CrushWrapper.cc:3198:    ldout(cct, 10) << " level " << j << ": type " << type << " fanout " << fanout
./crush/CrushWrapper.cc:3204:      ldout(cct, 10) << __func__ << " end of orig, break 0" << dendl;
./crush/CrushWrapper.cc:3208:      ldout(cct, 10) << " from " << from << dendl;
./crush/CrushWrapper.cc:3223:	  ldout(cct, 10) << __func__ << "   from " << *tmpi << " got " << item
./crush/CrushWrapper.cc:3230:	      ldout(cct, 10) << __func__ << " pos " << pos
./crush/CrushWrapper.cc:3234:		ldout(cct, 20) << __func__ << "   in used " << used << dendl;
./crush/CrushWrapper.cc:3238:		ldout(cct, 20) << __func__ << "   not in subtree " << from << dendl;
./crush/CrushWrapper.cc:3242:		ldout(cct, 20) << __func__ << "   in orig " << orig << dendl;
./crush/CrushWrapper.cc:3247:	      ldout(cct, 10) << __func__ << " pos " << pos << " replace "
./crush/CrushWrapper.cc:3256:	    ldout(cct, 10) << __func__ << " pos " << pos << " keep " << *i
./crush/CrushWrapper.cc:3263:	    ldout(cct, 10) << __func__ << " end of orig, break 1" << dendl;
./crush/CrushWrapper.cc:3281:	      ldout(cct, 10) << " bucket " << o[pos] << " has no underfull targets and "
./crush/CrushWrapper.cc:3292:		      ldout(cct, 10) << "  replacing " << o[pos]
./crush/CrushWrapper.cc:3298:		      ldout(cct, 10) << "  replacing " << o[pos]
./crush/CrushWrapper.cc:3304:		    ldout(cct, 30) << "  alt " << alt << " for " << o[pos]
./crush/CrushWrapper.cc:3314:	ldout(cct, 10) << __func__ << " end of orig, break 2" << dendl;
./crush/CrushWrapper.cc:3318:    ldout(cct, 10) << __func__ << "  w <- " << o << " was " << w << dendl;
./crush/CrushWrapper.cc:3338:  ldout(cct, 10) << __func__ << " ruleno " << ruleno
./crush/CrushWrapper.cc:3352:    ldout(cct, 10) << __func__ << " step " << step << " w " << w << dendl;
./crush/CrushWrapper.cc:3360:	ldout(cct, 10) << __func__ << " take " << w << dendl;
./crush/CrushWrapper.cc:3362:	ldout(cct, 1) << " bad take value " << curstep->arg1 << dendl;
./crush/CrushWrapper.cc:3396:      ldout(cct, 10) << " emit " << w << dendl;
./crush/CrushWrapper.cc:3434:    ldout(cct, 10) << __func__ << "  no crush_choose_arg for bucket " << b->id
./crush/CrushWrapper.cc:3442:    ldout(cct, 10) << __func__ << "  no weight_set for bucket " << b->id
./crush/CrushWrapper.cc:3449:    ldout(cct, 10) << __func__ << "  weight_set_size != " << weight.size()
./crush/CrushWrapper.cc:3458:      ldout(cct, 5) << __func__ << "  set " << id << " to " << weight
./crush/CrushWrapper.cc:3482:  ldout(cct, 5) << __func__ << " " << id << " weight " << weight << dendl;
./librados/RadosClient.cc:60:  //ldout(cct, 0) << "RadosClient::ms_get_authorizer type=" << dest_type << dendl;
./librados/RadosClient.cc:236:    ldout(cct, 10) << __func__ << " build monmap" << dendl;
./librados/RadosClient.cc:282:  ldout(cct, 1) << "starting msgr at " << messenger->get_myaddr() << dendl;
./librados/RadosClient.cc:284:  ldout(cct, 1) << "starting objecter" << dendl;
./librados/RadosClient.cc:304:  ldout(cct, 1) << "setting wanted keys" << dendl;
./librados/RadosClient.cc:307:  ldout(cct, 1) << "calling monclient init" << dendl;
./librados/RadosClient.cc:310:    ldout(cct, 0) << conf->name << " initialization error " << cpp_strerror(-err) << dendl;
./librados/RadosClient.cc:317:    ldout(cct, 0) << conf->name << " authentication error " << cpp_strerror(-err) << dendl;
./librados/RadosClient.cc:333:    ldout(cct, 10) << __func__ << " registering as " << service_name << "."
./librados/RadosClient.cc:353:  ldout(cct, 1) << "init done" << dendl;
./librados/RadosClient.cc:408:  ldout(cct, 1) << "shutdown" << dendl;
./librados/RadosClient.cc:413:  ldout(cct, 10) << __func__ << " enter" << dendl;
./librados/RadosClient.cc:424:  ldout(cct, 10) << __func__ << " exit" << dendl;
./librados/RadosClient.cc:453:  ldout(cct, 10) << __func__ << " enter" << dendl;
./librados/RadosClient.cc:456:  ldout(cct, 10) << __func__ << " exit" << dendl;
./librados/RadosClient.cc:517:    ldout(cct, 10) << "disconnected, discarding " << *m << dendl;
./librados/RadosClient.cc:593:      ldout(cct, 10) << __func__ << " waiting" << dendl;
./librados/RadosClient.cc:606:      ldout(cct, 10) << __func__ << " done waiting" << dendl;
./librados/RadosClient.cc:989:    ldout(cct, 10) << __func__ << " removing cb " << (void*)log_cb
./librados/RadosClient.cc:1011:    ldout(cct, 10) << __func__ << " invalid level " << level << dendl;
./librados/RadosClient.cc:1019:  ldout(cct, 10) << __func__ << " add cb " << (void*)cb << " " << (void*)cb2
./librados/RadosClient.cc:1034:  ldout(cct, 10) << __func__ << " version " << m->version << dendl;
./librados/RadosClient.cc:1051:        ldout(cct, 20) << __func__ << " delivering " << ss.str() << dendl;
./librados/RadosClient.cc:1093:  ldout(cct,10) << __func__ << " " << service << "." << name << dendl;
./librados/snap_set_diff.cc:23:  ldout(cct, 10) << "calc_snap_set_diff start " << start << " end " << end
./librados/snap_set_diff.cc:44:      ldout(cct, 1) << "clone " << r->cloneid
./librados/snap_set_diff.cc:53:    ldout(cct, 20) << " clone " << r->cloneid << " snaps " << r->snaps
./librados/snap_set_diff.cc:65:	ldout(cct, 20) << "  start, after " << start << dendl;
./librados/snap_set_diff.cc:71:	ldout(cct, 20) << "  start" << dendl;
./librados/snap_set_diff.cc:79:      ldout(cct, 20) << " past end " << end << ", end object does not exist" << dendl;
./librados/snap_set_diff.cc:88:      ldout(cct, 20) << " end" << dendl;
./librados/snap_set_diff.cc:111:    ldout(cct, 20) << "  diff_to_next " << diff_to_next << dendl;
./librados/snap_set_diff.cc:113:    ldout(cct, 20) << "  diff now " << *diff << dendl;
./librados/IoCtxImpl.cc:56:    ldout(cct, 10) << __func__ << " completed notify (linger op "
./librados/IoCtxImpl.cc:175:    ldout(cct, 10) << __func__ << " linger op " << oncomplete->linger_op << " "
./librados/IoCtxImpl.cc:247:  ldout(client->cct, 10) << "set snap read " << snap_seq << " -> " << s << dendl;
./librados/IoCtxImpl.cc:254:  ldout(client->cct, 10) << "set snap write context: seq = " << seq
./librados/IoCtxImpl.cc:290:  ldout(client->cct, 20) << "queue_aio_write " << this << " completion " << c
./librados/IoCtxImpl.cc:298:  ldout(client->cct, 20) << "complete_aio_write " << c << dendl;
./librados/IoCtxImpl.cc:307:      ldout(client->cct, 20) << " next outstanding write is " << aio_write_list.front()->aio_write_seq
./librados/IoCtxImpl.cc:312:    ldout(client->cct, 20) << " waking waiters on seq " << waiters->first << dendl;
./librados/IoCtxImpl.cc:328:  ldout(client->cct, 20) << "flush_aio_writes_async " << this
./librados/IoCtxImpl.cc:333:    ldout(client->cct, 20) << "flush_aio_writes_async no writes. (tid "
./librados/IoCtxImpl.cc:337:    ldout(client->cct, 20) << "flush_aio_writes_async " << aio_write_list.size()
./librados/IoCtxImpl.cc:346:  ldout(client->cct, 20) << "flush_aio_writes" << dendl;
./librados/IoCtxImpl.cc:710:  ldout(client->cct, 10) << ceph_osd_op_name(op) << " oid=" << oid
./librados/IoCtxImpl.cc:721:  ldout(client->cct, 10) << "Objecter returned from "
./librados/IoCtxImpl.cc:746:  ldout(client->cct, 10) << ceph_osd_op_name(op) << " oid=" << oid << " nspace=" << oloc.nspace << dendl;
./librados/IoCtxImpl.cc:756:  ldout(client->cct, 10) << "Objecter returned from "
./librados/IoCtxImpl.cc:989:  ldout(client->cct, 20) << "aio_write " << oid << " " << off << "~" << len << " snapc=" << snapc << " snap_seq=" << snap_seq << dendl;
./librados/IoCtxImpl.cc:1216:      ldout(cdata->client->cct, 10) << "IoCtxImpl::getxattrs: xattr=" << p->first << dendl;
./librados/IoCtxImpl.cc:1447:    ldout(client->cct, 10) << "Returned length " << bl.length()
./librados/IoCtxImpl.cc:1486:  ldout(client->cct, 10) << "Objecter returned from read r=" << r << dendl;
./librados/IoCtxImpl.cc:1623:      ldout(client->cct, 10) << "IoCtxImpl::getxattrs: xattr=" << p->first << dendl;
./librados/IoCtxImpl.cc:1663:    ldout(ioctx->client->cct, 10) << __func__ << " " << notify_id
./librados/IoCtxImpl.cc:1680:    ldout(ioctx->client->cct, 10) << __func__ << " cookie " << cookie
./librados/IoCtxImpl.cc:1850:  ldout(client->cct, 10) << __func__ << " issued linger op " << linger_op << dendl;
./librados/IoCtxImpl.cc:1852:  ldout(client->cct, 10) << __func__ << " linger op " << linger_op
./librados/IoCtxImpl.cc:1856:    ldout(client->cct, 10) << __func__ << " waiting for watch_notify finish "
./librados/IoCtxImpl.cc:1861:    ldout(client->cct, 10) << __func__ << " failed to initiate notify, r = "
./objclass/class_api.cc:719:       ldout(ch->cct, ceph::dout::need_dynamic(level)) << buf << dendl;
